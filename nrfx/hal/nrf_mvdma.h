/*$$$LICENCE_NORDIC_STANDARD<2020>$$$*/

#ifndef NRF_MVDMA_H__
#define NRF_MVDMA_H__

#include <nrfx.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @defgroup nrf_mvdma_hal MVDMA HAL
 * @{
 * @ingroup nrf_mvdma
 * @brief   Hardware access layer for managing the Memory-to-Memory Vector DMA (MVDMA) peripheral.
 */

/** @brief MVDMA tasks. */
typedef enum
{
    NRF_MVDMA_TASK_STOP   = offsetof(NRF_MVDMA_Type, TASKS_STOP),     ///< Stop DMA transaction immediately, or after an ongoing AXI burst.
    NRF_MVDMA_TASK_RESET  = offsetof(NRF_MVDMA_Type, TASKS_RESET),    ///< Return all registers to default state and FSMs to IDLE.
    NRF_MVDMA_TASK_START0 = offsetof(NRF_MVDMA_Type, TASKS_START[0]), ///< Start or continue processing of descriptor list 0.
    NRF_MVDMA_TASK_START1 = offsetof(NRF_MVDMA_Type, TASKS_START[1]), ///< Start or continue processing of descriptor list 1.
    NRF_MVDMA_TASK_START2 = offsetof(NRF_MVDMA_Type, TASKS_START[2]), ///< Start or continue processing of descriptor list 2.
    NRF_MVDMA_TASK_START3 = offsetof(NRF_MVDMA_Type, TASKS_START[3]), ///< Start or continue processing of descriptor list 3.
    NRF_MVDMA_TASK_START4 = offsetof(NRF_MVDMA_Type, TASKS_START[4]), ///< Start or continue processing of descriptor list 4.
    NRF_MVDMA_TASK_START5 = offsetof(NRF_MVDMA_Type, TASKS_START[5]), ///< Start or continue processing of descriptor list 5.
    NRF_MVDMA_TASK_START6 = offsetof(NRF_MVDMA_Type, TASKS_START[6]), ///< Start or continue processing of descriptor list 6.
    NRF_MVDMA_TASK_START7 = offsetof(NRF_MVDMA_Type, TASKS_START[7]), ///< Start or continue processing of descriptor list 7.
} nrf_mvdma_task_t;

/** @brief MVDMA events. */
typedef enum
{
    NRF_MVDMA_EVENT_END            = offsetof(NRF_MVDMA_Type, EVENTS_END),            ///< Sink data descriptor list has been completed.
    NRF_MVDMA_EVENT_STARTED        = offsetof(NRF_MVDMA_Type, EVENTS_STARTED),        ///< Data descriptor list processing has been started.
    NRF_MVDMA_EVENT_STOPPED        = offsetof(NRF_MVDMA_Type, EVENTS_STOPPED),        ///< Data descriptor list processing has been stopped.
    NRF_MVDMA_EVENT_RESET          = offsetof(NRF_MVDMA_Type, EVENTS_RESET),          ///< MVDMA has been reset.
    NRF_MVDMA_EVENT_SOURCEBUSERROR = offsetof(NRF_MVDMA_Type, EVENTS_SOURCEBUSERROR), ///< Bus error has been received on the source channel.
    NRF_MVDMA_EVENT_SINKBUSERROR   = offsetof(NRF_MVDMA_Type, EVENTS_SINKBUSERROR),   ///< Bus error has been received on the sink channel.
} nrf_mvdma_event_t;

/** @brief MVDMA interrupts. */
typedef enum
{
    NRF_MVDMA_INT_END_MASK            = MVDMA_INTENSET_END_Msk,            ///< Interrupt on END event.
    NRF_MVDMA_INT_STARTED_MASK        = MVDMA_INTENSET_STARTED_Msk,        ///< Interrupt on STARTED event.
    NRF_MVDMA_INT_STOPPED_MASK        = MVDMA_INTENSET_STOPPED_Msk,        ///< Interrupt on STOPPED event.
    NRF_MVDMA_INT_RESET_MASK          = MVDMA_INTENSET_RESET_Msk,          ///< Interrupt on RESET event.
    NRF_MVDMA_INT_SOURCEBUSERROR_MASK = MVDMA_INTENSET_SOURCEBUSERROR_Msk, ///< Interrupt on SOURCEBUSERROR event.
    NRF_MVDMA_INT_SINKBUSERROR_MASK   = MVDMA_INTENSET_SINKBUSERROR_Msk,   ///< Interrupt on SINKBUSERROR event.
} nrf_mvdma_int_mask_t;

/** @brief MVDMA modes of operation. */
typedef enum
{
    NRF_MVDMA_MODE_SINGLE = MVDMA_CONFIG_MODE_MODE_SingleMode, ///< Descriptor list pointers are stored in SOURCELISTPTR and SINKLISTPTR registers.
    NRF_MVDMA_MODE_MULTI  = MVDMA_CONFIG_MODE_MODE_MultiMode,  ///< Descriptor list pointers are stored in a list in the memory.
} nrf_mvdma_mode_t;

/** @brief MVDMA FIFO status. */
typedef enum
{
    NRF_MVDMA_FIFO_STATUS_EMPTY       = MVDMA_STATUS_FIFO_FIFOSTATUS_Empty,      ///< No data in intermediate FIFO.
    NRF_MVDMA_FIFO_STATUS_ALMOST_FULL = MVDMA_STATUS_FIFO_FIFOSTATUS_AlmostFull, ///< Intermediate FIFO is almost full.
    NRF_MVDMA_FIFO_STATUS_FULL        = MVDMA_STATUS_FIFO_FIFOSTATUS_Full,       ///< Intermediate FIFO is full.
} nrf_mvdma_fifo_status_t;

/** @brief MVDMA data source errors. */
typedef enum
{
    NRF_MVDMA_SOURCE_ERROR_NONE   = MVDMA_STATUS_SOURCEBUSERROR_BUSERROR_NoError,     ///< No error.
    NRF_MVDMA_SOURCE_ERROR_SLAVE  = MVDMA_STATUS_SOURCEBUSERROR_BUSERROR_SlaveError,  ///< Error generated by AXI slave.
    NRF_MVDMA_SOURCE_ERROR_DECODE = MVDMA_STATUS_SOURCEBUSERROR_BUSERROR_DecodeError, ///< Error generated by interconnect.
} nrf_mvdma_source_error_t;

/** @brief MVDMA data sink errors. */
typedef enum
{
    NRF_MVDMA_SINK_ERROR_NONE         = MVDMA_STATUS_SINKBUSERROR_BUSERROR_NoError,          ///< No error.
    NRF_MVDMA_SINK_ERROR_SLAVE_READ   = MVDMA_STATUS_SINKBUSERROR_BUSERROR_ReadSlaveError,   ///< Read error generated by AXI slave.
    NRF_MVDMA_SINK_ERROR_SLAVE_WRITE  = MVDMA_STATUS_SINKBUSERROR_BUSERROR_WriteSlaveError,  ///< Write error generated by AXI slave.
    NRF_MVDMA_SINK_ERROR_DECODE_READ  = MVDMA_STATUS_SINKBUSERROR_BUSERROR_ReadDecodeError,  ///< Read error generated by interconnect.
    NRF_MVDMA_SINK_ERROR_DECODE_WRITE = MVDMA_STATUS_SINKBUSERROR_BUSERROR_WriteDecodeError, ///< Write error generated by interconnect.
} nrf_mvdma_sink_error_t;

/**
 * @brief Function for activating the specified MVDMA task.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] task  Task to be activated.
 */
NRF_STATIC_INLINE void nrf_mvdma_task_trigger(NRF_MVDMA_Type * p_reg,
                                              nrf_mvdma_task_t task);

/**
 * @brief Function for getting the address of the specified MVDMA task register.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] task  Specified task.
 *
 * @return Address of the specified task register.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_task_address_get(NRF_MVDMA_Type const * p_reg,
                                                      nrf_mvdma_task_t       task);

/**
 * @brief Function for getting START task by its index.
 *
 * @param[in] index Index of the START task.
 *
 * @return START task.
 */
NRF_STATIC_INLINE nrf_mvdma_task_t nrf_mvdma_start_task_get(NRF_MVDMA_Type const * p_reg,
                                                            uint8_t                index);

/**
 * @brief Function for clearing the specified MVDMA event.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] event Event to clear.
 */
NRF_STATIC_INLINE void nrf_mvdma_event_clear(NRF_MVDMA_Type *  p_reg,
                                             nrf_mvdma_event_t event);

/**
 * @brief Function for retrieving the state of the MVDMA event.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] event Event to be checked.
 *
 * @retval true  The event has been generated.
 * @retval false The event has not been generated.
 */
NRF_STATIC_INLINE bool nrf_mvdma_event_check(NRF_MVDMA_Type const * p_reg,
                                             nrf_mvdma_event_t      event);

/**
 * @brief Function for getting the address of the specified MVDMA event register.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] event Specified event.
 *
 * @return Address of the specified event register.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_event_address_get(NRF_MVDMA_Type const * p_reg,
                                                       nrf_mvdma_event_t      event);

/**
 * @brief Function for enabling specified interrupts.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] mask  Mask of interrupts to be enabled.
 */
NRF_STATIC_INLINE void nrf_mvdma_int_enable(NRF_MVDMA_Type * p_reg, uint32_t mask);

/**
 * @brief Function for disabling specified interrupts.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] mask  Mask of interrupts to be disabled.
 */
NRF_STATIC_INLINE void nrf_mvdma_int_disable(NRF_MVDMA_Type * p_reg, uint32_t mask);

/**
 * @brief Function for checking if the specified interrupts are enabled.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] mask  Mask of interrupts to be checked.
 *
 * @return Mask of enabled interrupts.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_int_enable_check(NRF_MVDMA_Type const * p_reg, uint32_t mask);

/**
 * @brief Function for retrieving the state of pending interrupts.
 *
 * States of pending interrupts are saved as a bitmask.
 * One set at particular position means that interrupt is pending.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Bitmask with information about pending interrupts composed of @ref nrf_mvdma_int_mask_t.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_int_pending_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for setting the subscribe configuration for a given
 *        MVDMA task.
 *
 * @param[in] p_reg   Pointer to the structure of registers of the peripheral.
 * @param[in] task    Task for which to set the configuration.
 * @param[in] channel Channel through which to subscribe events.
 */
NRF_STATIC_INLINE void nrf_mvdma_subscribe_set(NRF_MVDMA_Type * p_reg,
                                               nrf_mvdma_task_t task,
                                               uint8_t          channel);

/**
 * @brief Function for clearing the subscribe configuration for a given
 *        MVDMA task.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] task  Task for which to clear the configuration.
 */
NRF_STATIC_INLINE void nrf_mvdma_subscribe_clear(NRF_MVDMA_Type * p_reg,
                                                 nrf_mvdma_task_t task);

/**
 * @brief Function for setting the publish configuration for a given
 *        MVDMA event.
 *
 * @param[in] p_reg   Pointer to the structure of registers of the peripheral.
 * @param[in] event   Event for which to set the configuration.
 * @param[in] channel Channel through which to publish the event.
 */
NRF_STATIC_INLINE void nrf_mvdma_publish_set(NRF_MVDMA_Type *  p_reg,
                                             nrf_mvdma_event_t event,
                                             uint8_t           channel);

/**
 * @brief Function for clearing the publish configuration for a given
 *        MVDMA event.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] event Event for which to clear the configuration.
 */
NRF_STATIC_INLINE void nrf_mvdma_publish_clear(NRF_MVDMA_Type *  p_reg,
                                               nrf_mvdma_event_t event);

/**
 * @brief Function for enabling the MVDMA peripheral.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 */
NRF_STATIC_INLINE void nrf_mvdma_enable(NRF_MVDMA_Type * p_reg);

/**
 * @brief Function for disabling the MVDMA peripheral.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 */
NRF_STATIC_INLINE void nrf_mvdma_disable(NRF_MVDMA_Type * p_reg);

/**
 * @brief Function for setting the MVDMA mode.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] mode  Desired operating mode for MVDMA.
 */
NRF_STATIC_INLINE void nrf_mvdma_mode_set(NRF_MVDMA_Type * p_reg, nrf_mvdma_mode_t mode);

/**
 * @brief Function for setting the start address of source descriptor list
 *        or list of descriptor list pointers, depending on configured @ref nrf_mvdma_mode_t mode.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] addr  Address to be set.
 */
NRF_STATIC_INLINE void nrf_mvdma_source_address_set(NRF_MVDMA_Type * p_reg, uint32_t addr);

/**
 * @brief Function for getting the start address of source descriptor list
 *        or list of descriptor list pointers, depending on configured @ref nrf_mvdma_mode_t mode.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Source start address.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_source_address_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for setting the start address of sink descriptor list
 *        or list of descriptor list pointers, depending on configured @ref nrf_mvdma_mode_t mode.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 * @param[in] addr  Address to be set.
 */
NRF_STATIC_INLINE void nrf_mvdma_sink_address_set(NRF_MVDMA_Type * p_reg, uint32_t addr);

/**
 * @brief Function for getting the start address of sink descriptor list
 *        or list of descriptor list pointers, depending on configured @ref nrf_mvdma_mode_t mode.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Sink start address.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_sink_address_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the result of CRC checksum calculation.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Result of CRC checksum calculation.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_crc_result_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the status of intermediate FIFO.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Intermediate FIFO status.
 */
NRF_STATIC_INLINE nrf_mvdma_fifo_status_t nrf_mvdma_fifo_status_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for checking the MVDMA activity.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @retval true  MVDMA is processing data.
 * @retval false MVDMA is idle.
 */
NRF_STATIC_INLINE bool nrf_mvdma_activity_check(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the bus error of MVDMA data source.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Bus error of data source.
 */
NRF_STATIC_INLINE nrf_mvdma_source_error_t nrf_mvdma_source_error_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the bus error of MVDMA data source.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Bus error of data sink.
 */
NRF_STATIC_INLINE nrf_mvdma_sink_error_t nrf_mvdma_sink_error_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the latest address being accessed on the source AXI channel.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Latest address being accessed on the source AXI channel.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_last_source_address_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the latest address being accessed on the sink AXI channel.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Latest address being accessed on the sink AXI channel.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_last_sink_address_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the number of completed jobs in the current source descriptor list.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Number of completed jobs in the current source descriptor list.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_source_job_count_get(NRF_MVDMA_Type const * p_reg);

/**
 * @brief Function for getting the number of completed jobs in the current sink descriptor list.
 *
 * @param[in] p_reg Pointer to the structure of registers of the peripheral.
 *
 * @return Number of completed jobs in the current sink descriptor list.
 */
NRF_STATIC_INLINE uint32_t nrf_mvdma_sink_job_count_get(NRF_MVDMA_Type const * p_reg);

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_mvdma_task_trigger(NRF_MVDMA_Type * p_reg,
                                              nrf_mvdma_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1uL;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_task_address_get(NRF_MVDMA_Type const * p_reg,
                                                      nrf_mvdma_task_t       task)
{
    return ((uint32_t)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE nrf_mvdma_task_t nrf_mvdma_start_task_get(NRF_MVDMA_Type const * p_reg,
                                                            uint8_t                index)
{
    return (nrf_mvdma_task_t)(NRFX_OFFSETOF(NRF_MVDMA_Type, TASKS_START[index]));
}

NRF_STATIC_INLINE void nrf_mvdma_event_clear(NRF_MVDMA_Type *  p_reg,
                                             nrf_mvdma_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0uL;
}

NRF_STATIC_INLINE bool nrf_mvdma_event_check(NRF_MVDMA_Type const * p_reg,
                                             nrf_mvdma_event_t      event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_event_address_get(NRF_MVDMA_Type const * p_reg,
                                                       nrf_mvdma_event_t      event)
{
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_mvdma_int_enable(NRF_MVDMA_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_mvdma_int_disable(NRF_MVDMA_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_int_enable_check(NRF_MVDMA_Type const * p_reg, uint32_t mask)
{
    return (p_reg->INTENSET & mask);
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_int_pending_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->INTPEND;
}

NRF_STATIC_INLINE void nrf_mvdma_subscribe_set(NRF_MVDMA_Type * p_reg,
                                               nrf_mvdma_task_t task,
                                               uint8_t          channel)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
            ((uint32_t)channel | MVDMA_SUBSCRIBE_STOP_EN_Msk);
}

NRF_STATIC_INLINE void nrf_mvdma_subscribe_clear(NRF_MVDMA_Type * p_reg,
                                                 nrf_mvdma_task_t task)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
}

NRF_STATIC_INLINE void nrf_mvdma_publish_set(NRF_MVDMA_Type *  p_reg,
                                             nrf_mvdma_event_t event,
                                             uint8_t           channel)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
            ((uint32_t)channel | MVDMA_PUBLISH_STOPPED_EN_Msk);
}

NRF_STATIC_INLINE void nrf_mvdma_publish_clear(NRF_MVDMA_Type *  p_reg,
                                               nrf_mvdma_event_t event)
{
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
}

NRF_STATIC_INLINE void nrf_mvdma_enable(NRF_MVDMA_Type * p_reg)
{
    p_reg->ENABLE = (MVDMA_ENABLE_ENABLE_Enabled << MVDMA_ENABLE_ENABLE_Pos);
}

NRF_STATIC_INLINE void nrf_mvdma_disable(NRF_MVDMA_Type * p_reg)
{
    p_reg->ENABLE = (MVDMA_ENABLE_ENABLE_Disabled << MVDMA_ENABLE_ENABLE_Pos);
}

NRF_STATIC_INLINE void nrf_mvdma_mode_set(NRF_MVDMA_Type * p_reg, nrf_mvdma_mode_t mode)
{
    p_reg->CONFIG.MODE = ((uint32_t)mode << MVDMA_CONFIG_MODE_MODE_Pos);
}

NRF_STATIC_INLINE void nrf_mvdma_source_address_set(NRF_MVDMA_Type * p_reg, uint32_t addr)
{
    p_reg->CONFIG.SOURCELISTPTR = addr;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_source_address_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->CONFIG.SOURCELISTPTR;
}

NRF_STATIC_INLINE void nrf_mvdma_sink_address_set(NRF_MVDMA_Type * p_reg, uint32_t addr)
{
    p_reg->CONFIG.SINKLISTPTR = addr;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_sink_address_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->CONFIG.SINKLISTPTR;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_crc_result_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->STATUS.CRCRESULT;
}

NRF_STATIC_INLINE nrf_mvdma_fifo_status_t nrf_mvdma_fifo_status_get(NRF_MVDMA_Type const * p_reg)
{
    return (nrf_mvdma_fifo_status_t)(p_reg->STATUS.FIFO);
}

NRF_STATIC_INLINE bool nrf_mvdma_activity_check(NRF_MVDMA_Type const * p_reg)
{
    return (p_reg->STATUS.ACTIVE ==
            (MVDMA_STATUS_ACTIVE_ACTIVE_Active << MVDMA_STATUS_ACTIVE_ACTIVE_Pos));
}

NRF_STATIC_INLINE nrf_mvdma_source_error_t nrf_mvdma_source_error_get(NRF_MVDMA_Type const * p_reg)
{
    return (nrf_mvdma_source_error_t)(p_reg->STATUS.SOURCEBUSERROR);
}

NRF_STATIC_INLINE nrf_mvdma_sink_error_t nrf_mvdma_sink_error_get(NRF_MVDMA_Type const * p_reg)
{
    return (nrf_mvdma_source_error_t)(p_reg->STATUS.SINKBUSERROR);
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_last_source_address_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->STATUS.SOURCEADDRESS;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_last_sink_address_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->STATUS.SINKADDRESS;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_source_job_count_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->STATUS.SOURCEJOBCOUNT;
}

NRF_STATIC_INLINE uint32_t nrf_mvdma_sink_job_count_get(NRF_MVDMA_Type const * p_reg)
{
    return p_reg->STATUS.SINKJOBCOUNT;
}

#endif // NRF_DECLARE_ONLY

/** @} */

#ifdef __cplusplus
}
#endif

#endif // NRF_MVDMA_H__
