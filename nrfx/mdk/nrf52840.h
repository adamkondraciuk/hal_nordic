/*
 * Copyright (c) 2010 - 2020, Nordic Semiconductor ASA
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form, except as embedded into a Nordic
 * Semiconductor ASA integrated circuit in a product or a software update for
 * such product, must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * 
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * 
 * 4. This software, with or without modification, must only be used with a
 * Nordic Semiconductor ASA integrated circuit.
 * 
 * 5. Any software provided in binary form under this license must not be reverse
 * engineered, decompiled, modified and/or disassembled.
 * 
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf52840.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     01. October 2020
 * @note     Generated by SVDConv V3.3.35 on Thursday, 01.10.2020 15:17:36
 *           from File 'nrf52840.svd',
 *           last modified on Thursday, 01.10.2020 13:17:18
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf52840
  * @{
  */


#ifndef NRF52840_H
#define NRF52840_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M4 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  nrf52840 Specific Interrupt Numbers  ========================================== */
  POWER_CLOCK_IRQn          =   0,              /*!< 0  POWER_CLOCK                                                            */
  RADIO_IRQn                =   1,              /*!< 1  RADIO                                                                  */
  UARTE0_UART0_IRQn         =   2,              /*!< 2  UARTE0_UART0                                                           */
  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn=   3,  /*!< 3  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0                                      */
  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn=   4,  /*!< 4  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1                                      */
  NFCT_IRQn                 =   5,              /*!< 5  NFCT                                                                   */
  GPIOTE_IRQn               =   6,              /*!< 6  GPIOTE                                                                 */
  SAADC_IRQn                =   7,              /*!< 7  SAADC                                                                  */
  TIMER0_IRQn               =   8,              /*!< 8  TIMER0                                                                 */
  TIMER1_IRQn               =   9,              /*!< 9  TIMER1                                                                 */
  TIMER2_IRQn               =  10,              /*!< 10 TIMER2                                                                 */
  RTC0_IRQn                 =  11,              /*!< 11 RTC0                                                                   */
  TEMP_IRQn                 =  12,              /*!< 12 TEMP                                                                   */
  RNG_IRQn                  =  13,              /*!< 13 RNG                                                                    */
  ECB_IRQn                  =  14,              /*!< 14 ECB                                                                    */
  CCM_AAR_IRQn              =  15,              /*!< 15 CCM_AAR                                                                */
  WDT_IRQn                  =  16,              /*!< 16 WDT                                                                    */
  RTC1_IRQn                 =  17,              /*!< 17 RTC1                                                                   */
  QDEC_IRQn                 =  18,              /*!< 18 QDEC                                                                   */
  COMP_LPCOMP_IRQn          =  19,              /*!< 19 COMP_LPCOMP                                                            */
  SWI0_EGU0_IRQn            =  20,              /*!< 20 SWI0_EGU0                                                              */
  SWI1_EGU1_IRQn            =  21,              /*!< 21 SWI1_EGU1                                                              */
  SWI2_EGU2_IRQn            =  22,              /*!< 22 SWI2_EGU2                                                              */
  SWI3_EGU3_IRQn            =  23,              /*!< 23 SWI3_EGU3                                                              */
  SWI4_EGU4_IRQn            =  24,              /*!< 24 SWI4_EGU4                                                              */
  SWI5_EGU5_IRQn            =  25,              /*!< 25 SWI5_EGU5                                                              */
  TIMER3_IRQn               =  26,              /*!< 26 TIMER3                                                                 */
  TIMER4_IRQn               =  27,              /*!< 27 TIMER4                                                                 */
  PWM0_IRQn                 =  28,              /*!< 28 PWM0                                                                   */
  PDM_IRQn                  =  29,              /*!< 29 PDM                                                                    */
  MWU_IRQn                  =  32,              /*!< 32 MWU                                                                    */
  PWM1_IRQn                 =  33,              /*!< 33 PWM1                                                                   */
  PWM2_IRQn                 =  34,              /*!< 34 PWM2                                                                   */
  SPIM2_SPIS2_SPI2_IRQn     =  35,              /*!< 35 SPIM2_SPIS2_SPI2                                                       */
  RTC2_IRQn                 =  36,              /*!< 36 RTC2                                                                   */
  I2S_IRQn                  =  37,              /*!< 37 I2S                                                                    */
  FPU_IRQn                  =  38,              /*!< 38 FPU                                                                    */
  USBD_IRQn                 =  39,              /*!< 39 USBD                                                                   */
  UARTE1_IRQn               =  40,              /*!< 40 UARTE1                                                                 */
  QSPI_IRQn                 =  41,              /*!< 41 QSPI                                                                   */
  CRYPTOCELL_IRQn           =  42,              /*!< 42 CRYPTOCELL                                                             */
  PWM3_IRQn                 =  45,              /*!< 45 PWM3                                                                   */
  SPIM3_IRQn                =  47,              /*!< 47 SPIM3                                                                  */
  RAMBISTHUB_IRQn           = 108               /*!< 108  RAMBISTHUB                                                           */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M4 Processor and Core Peripherals  =========================== */
#define __CM4_REV                 0x0001U       /*!< CM4 Core Revision                                                         */
#define __DSP_PRESENT                  1        /*!< DSP present or not                                                        */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  1        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"                           /*!< ARM Cortex-M4 processor and core peripherals                              */
#include "system_nrf52840.h"                    /*!< nrf52840 System                                                           */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  PART;                         /*!< (@ 0x00000000) Part code                                                  */
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000004) Build code (hardware version and production configuration) */
  __IM  uint32_t  PACKAGE;                      /*!< (@ 0x00000008) Package option                                             */
  __IM  uint32_t  RAM;                          /*!< (@ 0x0000000C) RAM variant                                                */
  __IM  uint32_t  FLASH;                        /*!< (@ 0x00000010) Flash variant                                              */
} FICR_INFO_Type;                               /*!< Size = 20 (0x14)                                                          */


/**
  * @brief FICR_TEMP [TEMP] (Registers storing factory TEMP module linearization coefficients)
  */
typedef struct {
  __IM  uint32_t  A0;                           /*!< (@ 0x00000000) Slope definition A0                                        */
  __IM  uint32_t  A1;                           /*!< (@ 0x00000004) Slope definition A1                                        */
  __IM  uint32_t  A2;                           /*!< (@ 0x00000008) Slope definition A2                                        */
  __IM  uint32_t  A3;                           /*!< (@ 0x0000000C) Slope definition A3                                        */
  __IM  uint32_t  A4;                           /*!< (@ 0x00000010) Slope definition A4                                        */
  __IM  uint32_t  A5;                           /*!< (@ 0x00000014) Slope definition A5                                        */
  __IM  uint32_t  B0;                           /*!< (@ 0x00000018) Y-intercept B0                                             */
  __IM  uint32_t  B1;                           /*!< (@ 0x0000001C) Y-intercept B1                                             */
  __IM  uint32_t  B2;                           /*!< (@ 0x00000020) Y-intercept B2                                             */
  __IM  uint32_t  B3;                           /*!< (@ 0x00000024) Y-intercept B3                                             */
  __IM  uint32_t  B4;                           /*!< (@ 0x00000028) Y-intercept B4                                             */
  __IM  uint32_t  B5;                           /*!< (@ 0x0000002C) Y-intercept B5                                             */
  __IM  uint32_t  T0;                           /*!< (@ 0x00000030) Segment end T0                                             */
  __IM  uint32_t  T1;                           /*!< (@ 0x00000034) Segment end T1                                             */
  __IM  uint32_t  T2;                           /*!< (@ 0x00000038) Segment end T2                                             */
  __IM  uint32_t  T3;                           /*!< (@ 0x0000003C) Segment end T3                                             */
  __IM  uint32_t  T4;                           /*!< (@ 0x00000040) Segment end T4                                             */
} FICR_TEMP_Type;                               /*!< Size = 68 (0x44)                                                          */


/**
  * @brief FICR_NFC [NFC] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  TAGHEADER0;                   /*!< (@ 0x00000000) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER1;                   /*!< (@ 0x00000004) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER2;                   /*!< (@ 0x00000008) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER3;                   /*!< (@ 0x0000000C) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
} FICR_NFC_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
  */
typedef struct {
  __IM  uint32_t  BYTES;                        /*!< (@ 0x00000000) Amount of bytes for the required entropy bits              */
  __IM  uint32_t  RCCUTOFF;                     /*!< (@ 0x00000004) Repetition counter cutoff                                  */
  __IM  uint32_t  APCUTOFF;                     /*!< (@ 0x00000008) Adaptive proportion cutoff                                 */
  __IM  uint32_t  STARTUP;                      /*!< (@ 0x0000000C) Amount of bytes for the startup tests                      */
  __IM  uint32_t  ROSC1;                        /*!< (@ 0x00000010) Sample count for ring oscillator 1                         */
  __IM  uint32_t  ROSC2;                        /*!< (@ 0x00000014) Sample count for ring oscillator 2                         */
  __IM  uint32_t  ROSC3;                        /*!< (@ 0x00000018) Sample count for ring oscillator 3                         */
  __IM  uint32_t  ROSC4;                        /*!< (@ 0x0000001C) Sample count for ring oscillator 4                         */
} FICR_TRNG90B_Type;                            /*!< Size = 32 (0x20)                                                          */


/**
  * @brief AMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  CPU0;                         /*!< (@ 0x00000000) AHB bus master priority register for CPU0                  */
  __IOM uint32_t  SPIS1;                        /*!< (@ 0x00000004) AHB bus master priority register for SPIM1, SPIS1,
                                                                    TWIM1 and TWIS1                                            */
  __IOM uint32_t  RADIO;                        /*!< (@ 0x00000008) AHB bus master priority register for RADIO                 */
  __IOM uint32_t  ECB;                          /*!< (@ 0x0000000C) AHB bus master priority register for ECB                   */
  __IOM uint32_t  CCM;                          /*!< (@ 0x00000010) AHB bus master priority register for CCM                   */
  __IOM uint32_t  AAR;                          /*!< (@ 0x00000014) AHB bus master priority register for AAR                   */
  __IOM uint32_t  SAADC;                        /*!< (@ 0x00000018) AHB bus master priority register for SAADC                 */
  __IOM uint32_t  UARTE;                        /*!< (@ 0x0000001C) AHB bus master priority register for UARTE                 */
  __IOM uint32_t  SERIAL0;                      /*!< (@ 0x00000020) AHB bus master priority register for SPIM0, SPIS0,
                                                                    TWIM0 and TWIS0                                            */
  __IOM uint32_t  SERIAL2;                      /*!< (@ 0x00000024) AHB bus master priority register for SPIM2 and
                                                                    SPIS2                                                      */
  __IOM uint32_t  NFCT;                         /*!< (@ 0x00000028) AHB bus master priority register for NFCT                  */
  __IOM uint32_t  I2S;                          /*!< (@ 0x0000002C) AHB bus master priority register for I2S                   */
  __IOM uint32_t  PDM;                          /*!< (@ 0x00000030) AHB bus master priority register for PDM                   */
  __IOM uint32_t  PWM;                          /*!< (@ 0x00000034) AHB bus master priority register for PWM0, PWM1
                                                                    and PWM2                                                   */
  __IOM uint32_t  QSPI;                         /*!< (@ 0x00000038) AHB bus master priority register for QSPI                  */
  __IOM uint32_t  SPIM3;                        /*!< (@ 0x0000003C) AHB bus master priority register for SPIM3                 */
} AMLI_RAMPRI_Type;                             /*!< Size = 64 (0x40)                                                          */


/**
  * @brief CLOCK_GATE [GATE] (Clock gating control)
  */
typedef struct {
  __IOM uint32_t  CPU;                          /*!< (@ 0x00000000) CPU clock gating                                           */
} CLOCK_GATE_Type;                              /*!< Size = 4 (0x4)                                                            */


/**
  * @brief POWER_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000000) Description cluster: RAMn power control register           */
  __OM  uint32_t  POWERSET;                     /*!< (@ 0x00000004) Description cluster: RAMn power control set register       */
  __OM  uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAMn power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} POWER_RAM_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief GPIO_PIN [PIN] (Pin n direct access)
  */
typedef struct {
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000000) Description cluster: Pin n direct access output
                                                                    register                                                   */
  __IOM uint32_t  IN;                           /*!< (@ 0x00000004) Description cluster: Pin n direct access input
                                                                    register                                                   */
} GPIO_PIN_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief RADIO_DEBUGPSEL [DEBUGPSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLOCK;                        /*!< (@ 0x00000000) Pin select for RADIO clock (direct mode, base
                                                                    band debug. Refer to digip_064 and digip_061,
                                                                    txCk and ckDataIn signals)                                 */
  __IOM uint32_t  DATA;                         /*!< (@ 0x00000004) Pin select for RADIO data (direct mode, base
                                                                    band debug. Refer to digip_064 and digip_061,
                                                                    txRadioData and dataIn signals)                            */
} RADIO_DEBUGPSEL_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief RADIO_DFEPSEL [DFEPSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  GPIO[6];                      /*!< (@ 0x00000000) Description collection: Pin select for DFE pin
                                                                    n                                                          */
} RADIO_DFEPSEL_Type;                           /*!< Size = 24 (0x18)                                                          */


/**
  * @brief RADIO_DFEPACKET [DFEPACKET] (DFE packet EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAX;                          /*!< (@ 0x00000004) Maximum number of buffer words to transfer                 */
  __IOM uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) Linked list type                                           */
} RADIO_DFEPACKET_Type;                         /*!< Size = 16 (0x10)                                                          */


/**
  * @brief RADIO_ACQDMA [ACQDMA] (EasyDMA channel for data acquisition (refer to 4378_164))
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) EasyDMA pointer for data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 32-bit words to transfer (refer
                                                                    to 4378_164)                                               */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 32-bit words transferred in the last
                                                                    transaction (refer to 4378_164)                            */
} RADIO_ACQDMA_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief UART_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS                                         */
  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD                                         */
  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS                                         */
  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD                                         */
} UART_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS signal                                  */
  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD signal                                  */
  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS signal                                  */
  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD signal                                  */
} UARTE_PSEL_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_RXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_TXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
} SPI_PSEL_Type;                                /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN                                         */
} SPIM_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of bytes in transmit buffer                         */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RXDELAY;                      /*!< (@ 0x00000000) Sample delay for input serial data on MISO                 */
  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
                                                                    of SCK and minimum duration CSN must stay
                                                                    high between transactions                                  */
} SPIM_IFTIMING_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000004) Pin select for MISO signal                                 */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000008) Pin select for MOSI signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN signal                                  */
} SPIS_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes received in last granted transaction       */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transmitted in last granted transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL                                         */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA                                         */
} TWI_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIM_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIS_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in RXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last RXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in TXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last TXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief NFCT_FRAMESTATUS [FRAMESTATUS] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RX;                           /*!< (@ 0x00000000) Result of last incoming frame                              */
} NFCT_FRAMESTATUS_Type;                        /*!< Size = 4 (0x4)                                                            */


/**
  * @brief NFCT_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of outgoing frames                           */
  __IOM uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of outgoing frame                                     */
} NFCT_TXD_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief NFCT_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of incoming frames                           */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of last incoming frame                                */
} NFCT_RXD_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief GPIOTE_TASKS_PCPPEN [TASKS_PCPPEN] (Peripheral tasks.)
  */
typedef struct {
  __OM  uint32_t  LOW;                          /*!< (@ 0x00000000) Description cluster: Configure PCP[n] requests
                                                                    to have lowest possible penalty                            */
  __OM  uint32_t  HIGH;                         /*!< (@ 0x00000004) Description cluster: Configure PCP[n] requests
                                                                    to have highest possible penalty                           */
} GPIOTE_TASKS_PCPPEN_Type;                     /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last result is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last result is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring of a channel                                    */
} SAADC_CH_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 16-bit samples to be written
                                                                    to output RAM buffer                                       */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 16-bit samples written to output RAM
                                                                    buffer since the previous START task                       */
} SAADC_RESULT_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief QDEC_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LED;                          /*!< (@ 0x00000000) Pin select for LED signal                                  */
  __IOM uint32_t  A;                            /*!< (@ 0x00000004) Pin select for A signal                                    */
  __IOM uint32_t  B;                            /*!< (@ 0x00000008) Pin select for B signal                                    */
} QDEC_PSEL_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief PWM_SEQ [SEQ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
                                                                    of this sequence                                           */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
                                                                    in this sequence                                           */
  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
                                                                    periods between samples loaded into compare
                                                                    register                                                   */
  __IOM uint32_t  ENDDELAY;                     /*!< (@ 0x0000000C) Description cluster: Time added after the sequence         */
  __IM  uint32_t  RESERVED[4];
} PWM_SEQ_Type;                                 /*!< Size = 32 (0x20)                                                          */


/**
  * @brief PWM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
                                                                    PWM channel n                                              */
} PWM_PSEL_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief PDM_FILTER [FILTER] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  HPPOLE;                       /*!< (@ 0x00000000) Settings for the high-pass filter                          */
  __IOM uint32_t  HPDISABLE;                    /*!< (@ 0x00000004) High pass filter disable                                   */
  __IOM uint32_t  SOFTMUTE;                     /*!< (@ 0x00000008) Soft mute function                                         */
  __IOM uint32_t  SOFTCYCLES;                   /*!< (@ 0x0000000C) Soft mute settings                                         */
  __IOM uint32_t  SAMPLEDELAY;                  /*!< (@ 0x00000010) Input Data Sampling with Number of PDM_CLK Clock
                                                                    Cycle Delay                                                */
} PDM_FILTER_Type;                              /*!< Size = 20 (0x14)                                                          */


/**
  * @brief PDM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLK;                          /*!< (@ 0x00000000) Pin number configuration for PDM CLK signal                */
  __IOM uint32_t  DIN;                          /*!< (@ 0x00000004) Pin number configuration for PDM DIN signal                */
} PDM_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
                                                                    EasyDMA                                                    */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
                                                                    mode                                                       */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of samples transferred into Data RAM since
                                                                    last START task                                            */
} PDM_SAMPLE_Type;                              /*!< Size = 12 (0xc)                                                           */


/**
  * @brief ACL_ACL [ACL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  ADDR;                         /*!< (@ 0x00000000) Description cluster: Configure the word-aligned
                                                                    start address of region n to protect                       */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Size of region to protect
                                                                    counting from address ACL[n].ADDR. Write
                                                                    '0' as no effect.                                          */
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000008) Description cluster: Access permissions for region
                                                                    n as defined by start address ACL[n].ADDR
                                                                    and size ACL[n].SIZE                                       */
  __IM  uint32_t  RESERVED;
} ACL_ACL_Type;                                 /*!< Size = 16 (0x10)                                                          */


/**
  * @brief PPI_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Enable channel group n                */
  __OM  uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Disable channel group n               */
} PPI_TASKS_CHG_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PPI_CH [CH] (PPI Channel)
  */
typedef struct {
  __IOM uint32_t  EEP;                          /*!< (@ 0x00000000) Description cluster: Channel n event end-point             */
  __IOM uint32_t  TEP;                          /*!< (@ 0x00000004) Description cluster: Channel n task end-point              */
} PPI_CH_Type;                                  /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PPI_FORK [FORK] (Fork)
  */
typedef struct {
  __IOM uint32_t  TEP;                          /*!< (@ 0x00000000) Description cluster: Channel n task end-point              */
} PPI_FORK_Type;                                /*!< Size = 4 (0x4)                                                            */


/**
  * @brief MWU_EVENTS_REGION [EVENTS_REGION] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to region n
                                                                    detected                                                   */
  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to region n
                                                                    detected                                                   */
} MWU_EVENTS_REGION_Type;                       /*!< Size = 8 (0x8)                                                            */


/**
  * @brief MWU_EVENTS_PREGION [EVENTS_PREGION] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to peripheral
                                                                    region n detected                                          */
  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to peripheral
                                                                    region n detected                                          */
} MWU_EVENTS_PREGION_Type;                      /*!< Size = 8 (0x8)                                                            */


/**
  * @brief MWU_PERREGION [PERREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SUBSTATWA;                    /*!< (@ 0x00000000) Description cluster: Source of event/interrupt
                                                                    in region n, write access detected while
                                                                    corresponding subregion was enabled for
                                                                    watching                                                   */
  __IOM uint32_t  SUBSTATRA;                    /*!< (@ 0x00000004) Description cluster: Source of event/interrupt
                                                                    in region n, read access detected while
                                                                    corresponding subregion was enabled for
                                                                    watching                                                   */
} MWU_PERREGION_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief MWU_REGION [REGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  START;                        /*!< (@ 0x00000000) Description cluster: Start address for region
                                                                    n                                                          */
  __IOM uint32_t  END;                          /*!< (@ 0x00000004) Description cluster: End address of region n               */
  __IM  uint32_t  RESERVED[2];
} MWU_REGION_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief MWU_PREGION [PREGION] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  START;                        /*!< (@ 0x00000000) Description cluster: Reserved for future use               */
  __IM  uint32_t  END;                          /*!< (@ 0x00000004) Description cluster: Reserved for future use               */
  __IOM uint32_t  SUBS;                         /*!< (@ 0x00000008) Description cluster: Subregions of region n                */
  __IM  uint32_t  RESERVED;
} MWU_PREGION_Type;                             /*!< Size = 16 (0x10)                                                          */


/**
  * @brief I2S_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000000) I2S mode.                                                  */
  __IOM uint32_t  RXEN;                         /*!< (@ 0x00000004) Reception (RX) enable.                                     */
  __IOM uint32_t  TXEN;                         /*!< (@ 0x00000008) Transmission (TX) enable.                                  */
  __IOM uint32_t  MCKEN;                        /*!< (@ 0x0000000C) Master clock generator enable.                             */
  __IOM uint32_t  MCKFREQ;                      /*!< (@ 0x00000010) Master clock generator frequency.                          */
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000014) MCK / LRCK ratio.                                          */
  __IOM uint32_t  SWIDTH;                       /*!< (@ 0x00000018) Sample width.                                              */
  __IOM uint32_t  ALIGN;                        /*!< (@ 0x0000001C) Alignment of sample within a frame.                        */
  __IOM uint32_t  FORMAT;                       /*!< (@ 0x00000020) Frame format.                                              */
  __IOM uint32_t  CHANNELS;                     /*!< (@ 0x00000024) Enable channels.                                           */
} I2S_CONFIG_Type;                              /*!< Size = 40 (0x28)                                                          */


/**
  * @brief I2S_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Receive buffer RAM start address.                          */
} I2S_RXD_Type;                                 /*!< Size = 4 (0x4)                                                            */


/**
  * @brief I2S_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Transmit buffer RAM start address.                         */
} I2S_TXD_Type;                                 /*!< Size = 4 (0x4)                                                            */


/**
  * @brief I2S_RXTXD [RXTXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000000) Size of RXD and TXD buffers.                               */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Number of 32 bit words sent and received since
                                                                    the previous END event. Nice to have only.
                                                                    TBD.                                                       */
} I2S_RXTXD_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief I2S_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MCK;                          /*!< (@ 0x00000000) Pin select for MCK signal.                                 */
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000004) Pin select for SCK signal.                                 */
  __IOM uint32_t  LRCK;                         /*!< (@ 0x00000008) Pin select for LRCK signal.                                */
  __IOM uint32_t  SDIN;                         /*!< (@ 0x0000000C) Pin select for SDIN signal.                                */
  __IOM uint32_t  SDOUT;                        /*!< (@ 0x00000010) Pin select for SDOUT signal.                               */
} I2S_PSEL_Type;                                /*!< Size = 20 (0x14)                                                          */


/**
  * @brief USBD_HALTED [HALTED] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  EPIN[8];                      /*!< (@ 0x00000000) Description collection: IN endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  EPOUT[8];                     /*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
} USBD_HALTED_Type;                             /*!< Size = 68 (0x44)                                                          */


/**
  * @brief USBD_SIZE [SIZE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  EPOUT[8];                     /*!< (@ 0x00000000) Description collection: Number of bytes received
                                                                    last in the data stage of this OUT endpoint                */
  __IM  uint32_t  ISOOUT;                       /*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
                                                                    data endpoint                                              */
} USBD_SIZE_Type;                               /*!< Size = 36 (0x24)                                                          */


/**
  * @brief USBD_EPIN [EPIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Description cluster: Endpoint EasyDMA configuration        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x00000010) Description cluster: EasyDMA list type                     */
} USBD_EPIN_Type;                               /*!< Size = 20 (0x14)                                                          */


/**
  * @brief USBD_ISOIN [ISOIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Isochronous endpoint EasyDMA configuration                 */
} USBD_ISOIN_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief USBD_EPOUT [EPOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Description cluster: Endpoint EasyDMA configuration        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x00000010) Description cluster: EasyDMA list type                     */
} USBD_EPOUT_Type;                              /*!< Size = 20 (0x14)                                                          */


/**
  * @brief USBD_ISOOUT [ISOOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Isochronous endpoint EasyDMA configuration                 */
} USBD_ISOOUT_Type;                             /*!< Size = 16 (0x10)                                                          */


/**
  * @brief QSPI_READ [READ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SRC;                          /*!< (@ 0x00000000) Flash memory source address                                */
  __IOM uint32_t  DST;                          /*!< (@ 0x00000004) RAM destination address                                    */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Read transfer length                                       */
} QSPI_READ_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief QSPI_WRITE [WRITE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DST;                          /*!< (@ 0x00000000) Flash destination address                                  */
  __IOM uint32_t  SRC;                          /*!< (@ 0x00000004) RAM source address                                         */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Write transfer length                                      */
} QSPI_WRITE_Type;                              /*!< Size = 12 (0xc)                                                           */


/**
  * @brief QSPI_ERASE [ERASE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Start address of flash block to be erased                  */
  __IOM uint32_t  LEN;                          /*!< (@ 0x00000004) Size of block to be erased.                                */
} QSPI_ERASE_Type;                              /*!< Size = 8 (0x8)                                                            */


/**
  * @brief QSPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for serial clock SCK Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
  __IOM uint32_t  CSN;                          /*!< (@ 0x00000004) Pin select for chip select signal CSN. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL.                     */
  __IOM uint32_t  CSN1;                         /*!< (@ 0x00000008) Pin select for chip select signal CSN1. Not implemented!.  */
  __IOM uint32_t  IO0;                          /*!< (@ 0x0000000C) Pin select for serial data MOSI/IO0. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL                      */
  __IOM uint32_t  IO1;                          /*!< (@ 0x00000010) Pin select for serial data MISO/IO1. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL.                     */
  __IOM uint32_t  IO2;                          /*!< (@ 0x00000014) Pin select for serial data IO2. Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
  __IOM uint32_t  IO3;                          /*!< (@ 0x00000018) Pin select for serial data IO3. Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
} QSPI_PSEL_Type;                               /*!< Size = 28 (0x1c)                                                          */


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           FICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory information configuration registers (FICR)
  */

typedef struct {                                /*!< (@ 0x10000000) FICR Structure                                             */
  __IM  uint32_t  CPTEST0;                      /*!< (@ 0x00000000) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST00;                     /*!< (@ 0x00000004) Result from Circuit Probe test                             */
  __IM  uint32_t  RESERVED[2];
  __IM  uint32_t  CODEPAGESIZE;                 /*!< (@ 0x00000010) Code memory page size                                      */
  __IM  uint32_t  CODESIZE;                     /*!< (@ 0x00000014) Code memory size                                           */
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  TESTSTATUS;                   /*!< (@ 0x0000001C) Code memory test status. Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  RESERVED2[14];
  __IM  uint32_t  DEVICETYPE;                   /*!< (@ 0x00000058) Device type                                                */
  __IM  uint32_t  CONFIGID;                     /*!< (@ 0x0000005C) Configuration identifier                                   */
  __IM  uint32_t  DEVICEID[2];                  /*!< (@ 0x00000060) Description collection: Device identifier                  */
  __IM  uint32_t  RESERVED3[2];
  __IM  uint32_t  CPTEST1;                      /*!< (@ 0x00000070) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST2;                      /*!< (@ 0x00000074) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST3;                      /*!< (@ 0x00000078) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST4;                      /*!< (@ 0x0000007C) Result from Circuit Probe test                             */
  __IM  uint32_t  ER[4];                        /*!< (@ 0x00000080) Description collection: Encryption root, word
                                                                    n                                                          */
  __IM  uint32_t  IR[4];                        /*!< (@ 0x00000090) Description collection: Identity Root, word n              */
  __IM  uint32_t  DEVICEADDRTYPE;               /*!< (@ 0x000000A0) Device address type                                        */
  __IM  uint32_t  DEVICEADDR[2];                /*!< (@ 0x000000A4) Description collection: Device address n                   */
  __IM  uint32_t  RESERVED4[21];
  __IM  FICR_INFO_Type INFO;                    /*!< (@ 0x00000100) Device info                                                */
  __IM  uint32_t  RESERVED5[3];
  __IM  uint32_t  OTP[2];                       /*!< (@ 0x00000120) Description collection: One-time programmable
                                                                    memory register n                                          */
  __IM  uint32_t  RESERVED6[2];
  __IM  uint32_t  PARTNO;                       /*!< (@ 0x00000130) Part number of the device. Will be updated in
                                                                    production test.                                           */
  __IM  uint32_t  HWREVISION;                   /*!< (@ 0x00000134) Hardware Revision of the device. Will be updated
                                                                    in production test.                                        */
  __IM  uint32_t  PRODUCTIONREVISION;           /*!< (@ 0x00000138) Production revision of the device. Will be updated
                                                                    in production test.                                        */
  __IM  uint32_t  RESERVED7[49];
  __IM  uint32_t  CPTEST5;                      /*!< (@ 0x00000200) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST6;                      /*!< (@ 0x00000204) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST7;                      /*!< (@ 0x00000208) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST8;                      /*!< (@ 0x0000020C) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  RESERVED8[12];
  __IM  uint32_t  CHIPCONF00;                   /*!< (@ 0x00000240) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF01;                   /*!< (@ 0x00000244) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF02;                   /*!< (@ 0x00000248) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF03;                   /*!< (@ 0x0000024C) SAADC and POWER related presets. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  RADIOTRIM00;                  /*!< (@ 0x00000250) Radio presets register                                     */
  __IM  uint32_t  RADIOTRIM01;                  /*!< (@ 0x00000254) Radio presets register.                                    */
  __IM  uint32_t  CHIPCONF07;                   /*!< (@ 0x00000258) SRAM TRIM values. Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  RESERVED9[9];
  __IM  uint32_t  FLASHPWRUP0;                  /*!< (@ 0x00000280) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP1;                  /*!< (@ 0x00000284) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP2;                  /*!< (@ 0x00000288) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP3;                  /*!< (@ 0x0000028C) Power-up pattern for flash                                 */
  __IM  uint32_t  RESERVED10[28];
  __IM  uint32_t  CHIPCONF05;                   /*!< (@ 0x00000300) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF06;                   /*!< (@ 0x00000304) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  RCNFMODE[6];                  /*!< (@ 0x00000308) Description collection: Mode-specific RADIO configuration
                                                                    register for RADIO mode m=n                                */
  __IM  uint32_t  RCNF;                         /*!< (@ 0x00000320) Mode independent RADIO configuration register              */
  __IM  uint32_t  CHIPCONF04;                   /*!< (@ 0x00000324) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  RCNFMODE6;                    /*!< (@ 0x00000328) Mode-specific RADIO configuration register for
                                                                    RADIO mode m=6                                             */
  __IM  uint32_t  RCNFMODE15;                   /*!< (@ 0x0000032C) Mode-specific RADIO configuration register for
                                                                    RADIO mode m=15                                            */
  __IM  uint32_t  RESERVED11[8];
  __IM  uint32_t  PRODTEST[3];                  /*!< (@ 0x00000350) Description collection: Production test signature
                                                                    n                                                          */
  __IM  uint32_t  RESERVED12[42];
  __IM  FICR_TEMP_Type TEMP;                    /*!< (@ 0x00000404) Registers storing factory TEMP module linearization
                                                                    coefficients                                               */
  __IM  uint32_t  RESERVED13[2];
  __IOM FICR_NFC_Type NFC;                      /*!< (@ 0x00000450) Unspecified                                                */
  __IM  uint32_t  RESERVED14[488];
  __IOM FICR_TRNG90B_Type TRNG90B;              /*!< (@ 0x00000C00) NIST800-90B RNG calibration data                           */
  __IM  uint32_t  RESERVED15[246];
  __IM  uint32_t  CHECKSUM;                     /*!< (@ 0x00000FF8) Checksum of FICR. Written and verified during
                                                                    production.                                                */
  __IM  uint32_t  USBRECALIBRATED;              /*!< (@ 0x00000FFC) Device USB PLL Calibration has been updated.               */
} NRF_FICR_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           UICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief User information configuration registers (UICR)
  */

typedef struct {                                /*!< (@ 0x10001000) UICR Structure                                             */
  __IM  uint32_t  RESERVED[5];
  __IOM uint32_t  NRFFW[13];                    /*!< (@ 0x00000014) Description collection: Reserved for Nordic firmware
                                                                    design                                                     */
  __IOM uint32_t  CARRIERCAL;                   /*!< (@ 0x00000048) Calibration settings for RADIO FSFINETUNE                  */
  __IOM uint32_t  RSSICAL;                      /*!< (@ 0x0000004C) Calibration settings for RADIO RSSI                        */
  __IOM uint32_t  NRFHW[12];                    /*!< (@ 0x00000050) Description collection: Reserved for Nordic hardware
                                                                    design                                                     */
  __IOM uint32_t  CUSTOMER[32];                 /*!< (@ 0x00000080) Description collection: Reserved for customer              */
  __IM  uint32_t  RESERVED1[64];
  __IOM uint32_t  PSELRESET[2];                 /*!< (@ 0x00000200) Description collection: Mapping of the nRESET
                                                                    function (see POWER chapter for details)                   */
  __IOM uint32_t  APPROTECT;                    /*!< (@ 0x00000208) Access port protection                                     */
  __IOM uint32_t  NFCPINS;                      /*!< (@ 0x0000020C) Setting of pins dedicated to NFC functionality:
                                                                    NFC antenna or GPIO                                        */
  __IOM uint32_t  DEBUGCTRL;                    /*!< (@ 0x00000210) Processor debug control                                    */
  __IM  uint32_t  RESERVED2[59];
  __IOM uint32_t  DCDCDRIVE0;                   /*!< (@ 0x00000300) Set drive level for REG0 DCDC mode. Using high
                                                                    drive will slightly reduce DCDC efficiency.                */
  __IOM uint32_t  REGOUT0;                      /*!< (@ 0x00000304) Output voltage from REG0 regulator stage. The
                                                                    maximum output voltage from this stage is
                                                                    given as VDDH - VREG0DROP.                                 */
} NRF_UICR_Type;                                /*!< Size = 776 (0x308)                                                        */



/* =========================================================================================================================== */
/* ================                                           AMLI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AHB Multi-Layer Interface (AMLI)
  */

typedef struct {                                /*!< (@ 0x40000000) AMLI Structure                                             */
  __IM  uint32_t  RESERVED[896];
  __IOM AMLI_RAMPRI_Type RAMPRI;                /*!< (@ 0x00000E00) RAM configurable priority configuration structure          */
} NRF_AMLI_Type;                                /*!< Size = 3648 (0xe40)                                                       */



/* =========================================================================================================================== */
/* ================                                         APPROTECT                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Access Port Protection (APPROTECT)
  */

typedef struct {                                /*!< (@ 0x40000000) APPROTECT Structure                                        */
  __IM  uint32_t  RESERVED[340];
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000550) DISABLE register lock                                      */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000558) Software disable APPROTECT mechanism                       */
} NRF_APPROTECT_Type;                           /*!< Size = 1372 (0x55c)                                                       */



/* =========================================================================================================================== */
/* ================                                           CLOCK                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock control (CLOCK)
  */

typedef struct {                                /*!< (@ 0x40000000) CLOCK Structure                                            */
  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFXO crystal oscillator                              */
  __OM  uint32_t  TASKS_HFCLKSTOP;              /*!< (@ 0x00000004) Stop HFXO crystal oscillator                               */
  __OM  uint32_t  TASKS_LFCLKSTART;             /*!< (@ 0x00000008) Start LFCLK                                                */
  __OM  uint32_t  TASKS_LFCLKSTOP;              /*!< (@ 0x0000000C) Stop LFCLK                                                 */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000010) Start calibration of LFRC                                  */
  __OM  uint32_t  TASKS_CTSTART;                /*!< (@ 0x00000014) Start calibration timer                                    */
  __OM  uint32_t  TASKS_CTSTOP;                 /*!< (@ 0x00000018) Stop calibration timer                                     */
  __IM  uint32_t  RESERVED[57];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;          /*!< (@ 0x00000100) HFXO crystal oscillator started                            */
  __IOM uint32_t  EVENTS_LFCLKSTARTED;          /*!< (@ 0x00000104) LFCLK started                                              */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x0000010C) Calibration of LFRC completed                              */
  __IOM uint32_t  EVENTS_CTTO;                  /*!< (@ 0x00000110) Calibration timer timeout                                  */
  __IM  uint32_t  RESERVED2[5];
  __IOM uint32_t  EVENTS_CTSTARTED;             /*!< (@ 0x00000128) Calibration timer has been started and is ready
                                                                    to process new tasks                                       */
  __IOM uint32_t  EVENTS_CTSTOPPED;             /*!< (@ 0x0000012C) Calibration timer has been stopped and is ready
                                                                    to process new tasks                                       */
  __IM  uint32_t  RESERVED3[117];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[63];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) HFCLK status                                               */
  __IM  uint32_t  HFCLKSRCCOPY;                 /*!< (@ 0x00000410) Copy of HFCLKSRC register, set when HFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) LFCLK status                                               */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RCOSC32KIFINE;                /*!< (@ 0x00000420) Fine calibration read value for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IM  uint32_t  RCOSC32KICOARSE;              /*!< (@ 0x00000424) Coarse calibration read value for 32.768 kHz
                                                                    RC oscillator. Initialized with FICR value
                                                                    from RC32KTRIM. The value may be updated
                                                                    during execution of CAL task.                              */
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  HFCLKCURRFREQ;                /*!< (@ 0x00000430) Current frequency                                          */
  __IM  uint32_t  RESERVED6[56];
  __IOM uint32_t  HFCLKSRC;                     /*!< (@ 0x00000514) Clock source for the HFCLK oscillator, and configuration
                                                                    of XTAL oscillator. This register shall
                                                                    only be written while no oscillation is
                                                                    present on XC1. Failing to do so may cause
                                                                    unexpected behaviour.                                      */
  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for the LFCLK                                 */
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  HFXODEBOUNCE;                 /*!< (@ 0x00000528) HFXO debounce time. The HFXO is started by triggering
                                                                    the TASKS_HFCLKSTART task.                                 */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  RCOSC32KICALTEST;             /*!< (@ 0x00000534) 32.768 kHz RC oscillator calibration debug register        */
  __IOM uint32_t  CTIV;                         /*!< (@ 0x00000538) Calibration timer interval                                 */
  __IOM uint32_t  RCOSC32KICALLENGTH;           /*!< (@ 0x0000053C) 32kHz RC oscillator calibration length                     */
  __IOM uint32_t  RCOSC32KICOARSEIN;            /*!< (@ 0x00000540) RCOSC coarse calibration input                             */
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  RCOSC32KICIRC;                /*!< (@ 0x0000054C) Rotating current source for for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  HFCLKCTRL;                    /*!< (@ 0x00000558) High frequency clock configuration request. Changes
                                                                    made in this register do not apply before
                                                                    all HF clocks are stopped.                                 */
  __IOM uint32_t  TRACECONFIG;                  /*!< (@ 0x0000055C) Clocking options for the trace port debug interface        */
  __IOM CLOCK_GATE_Type GATE;                   /*!< (@ 0x00000560) Clock gating control                                       */
  __IM  uint32_t  RESERVED11[8];
  __IOM uint32_t  ATECLOCK;                     /*!< (@ 0x00000584) Analog test bus control for clock modules                  */
  __IM  uint32_t  RESERVED12[11];
  __IOM uint32_t  LFRCMODE;                     /*!< (@ 0x000005B4) LFRC mode configuration                                    */
  __IOM uint32_t  RCOSC32KIULPCOARSEIN;         /*!< (@ 0x000005B8) 32kHz RC oscillator coarse calibration input
                                                                    for ULP mode                                               */
  __IOM uint32_t  RCOSC32KIULPCALLENGTH;        /*!< (@ 0x000005BC) 32kHz RC oscillator calibration length in number
                                                                    of cycles for ULP mode                                     */
} NRF_CLOCK_Type;                               /*!< Size = 1472 (0x5c0)                                                       */



/* =========================================================================================================================== */
/* ================                                           POWER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control (POWER)
  */

typedef struct {                                /*!< (@ 0x40000000) POWER Structure                                            */
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;               /*!< (@ 0x00000078) Enable Constant Latency mode                               */
  __OM  uint32_t  TASKS_LOWPWR;                 /*!< (@ 0x0000007C) Enable Low-power mode (variable latency)                   */
  __IM  uint32_t  RESERVED1[34];
  __IOM uint32_t  EVENTS_POFWARN;               /*!< (@ 0x00000108) Power failure warning                                      */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;            /*!< (@ 0x00000114) CPU entered WFI/WFE sleep                                  */
  __IOM uint32_t  EVENTS_SLEEPEXIT;             /*!< (@ 0x00000118) CPU exited WFI/WFE sleep                                   */
  __IOM uint32_t  EVENTS_USBDETECTED;           /*!< (@ 0x0000011C) Voltage supply detected on VBUS                            */
  __IOM uint32_t  EVENTS_USBREMOVED;            /*!< (@ 0x00000120) Voltage supply removed from VBUS                           */
  __IOM uint32_t  EVENTS_USBPWRRDY;             /*!< (@ 0x00000124) USB 3.3 V supply ready                                     */
  __IM  uint32_t  RESERVED3[119];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[61];
  __IOM uint32_t  RESETREAS;                    /*!< (@ 0x00000400) Reset reason                                               */
  __IM  uint32_t  PERRDY;                       /*!< (@ 0x00000404) Peripheral on/off status                                   */
  __IM  uint32_t  RESERVED5[8];
  __IM  uint32_t  RAMSTATUS;                    /*!< (@ 0x00000428) Deprecated register - RAM status register                  */
  __IM  uint32_t  PERRDY2;                      /*!< (@ 0x0000042C) Peripheral on/off status 2                                 */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  DISABLEHPBOR;                 /*!< (@ 0x00000434) Enable or disable high-precision brown-out reset           */
  __IM  uint32_t  USBREGSTATUS;                 /*!< (@ 0x00000438) USB supply status                                          */
  __IM  uint32_t  RESERVED7[49];
  __OM  uint32_t  SYSTEMOFF;                    /*!< (@ 0x00000500) System OFF register                                        */
  __IOM uint32_t  PERPOWER;                     /*!< (@ 0x00000504) Peripheral power configuration                             */
  __IOM uint32_t  FORCEON1V2;                   /*!< (@ 0x00000508) Force on 1.2 V regulator                                   */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  POFCON;                       /*!< (@ 0x00000510) Power-fail comparator configuration                        */
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  GPREGRET;                     /*!< (@ 0x0000051C) General purpose retention register                         */
  __IOM uint32_t  GPREGRET2;                    /*!< (@ 0x00000520) General purpose retention register                         */
  __IM  uint32_t  RESERVED10[21];
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000578) Enable DC/DC converter for REG1 stage                      */
  __IOM uint32_t  PERPOWER2;                    /*!< (@ 0x0000057C) Peripheral power configuration 2                           */
  __IOM uint32_t  DCDCEN0;                      /*!< (@ 0x00000580) Enable DC/DC converter for REG0 stage                      */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  ATEPOWER;                     /*!< (@ 0x00000588) Analog test bus control for power modules                  */
  __IM  uint32_t  RESERVED12[19];
  __IOM uint32_t  DCDCDRIVE0;                   /*!< (@ 0x000005D8) Shadow register for corresponding register in
                                                                    UICR.                                                      */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  USBVREGDELAY;                 /*!< (@ 0x000005E0) Control of the delay from USB VREG turned on
                                                                    to USBPWRRDY event                                         */
  __IOM uint32_t  USBVDETFILTER;                /*!< (@ 0x000005E4) Control of the VBUS detection filter                       */
  __IM  uint32_t  RESERVED14[2];
  __IOM uint32_t  FORCEVBUSDET;                 /*!< (@ 0x000005F0) Force VBUS detection indication                            */
  __IOM uint32_t  FORCEPHY0V9;                  /*!< (@ 0x000005F4) Force USB PHY 0V9 supply switch                            */
  __IOM uint32_t  VREGUSBCFG;                   /*!< (@ 0x000005F8) Spare configuration signals                                */
  __IOM uint32_t  VREGUSBTRIM;                  /*!< (@ 0x000005FC) Output voltage fine trimming                               */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  BUCKVIOCAL;                   /*!< (@ 0x00000604) BUCK_VIO output voltage fine calibration                   */
  __IOM uint32_t  BUCKVIOCALILIM;               /*!< (@ 0x00000608) BUCK_VIO output current limit calibration                  */
  __IOM uint32_t  VIOULPICMPTRIM;               /*!< (@ 0x0000060C) Trimming of VREG_VIO_ULP load current measurement          */
  __IOM uint32_t  VIOVREGICMPTRIM;              /*!< (@ 0x00000610) Trimming of VREG_VIO load current measurement              */
  __IM  uint32_t  RESERVED16[2];
  __IOM uint32_t  RFSHTRIMPWM;                  /*!< (@ 0x0000061C) Trimmed value for refresh mode counter for automatic
                                                                    mode change to PWM                                         */
  __IOM uint32_t  RFSHTRIMULP;                  /*!< (@ 0x00000620) Trimmed value for refresh mode counter for automatic
                                                                    mode change to ULP                                         */
  __IOM uint32_t  RFSHPOLLSEL;                  /*!< (@ 0x00000624) Programmable value for counter for poller in
                                                                    PWM mode                                                   */
  __IOM uint32_t  RFSHBUCKCAL;                  /*!< (@ 0x00000628) Refresh mode trim register                                 */
  __IOM uint32_t  POWERVIOCFG;                  /*!< (@ 0x0000062C) Spare configuration signals for POWER_VIO                  */
  __IOM uint32_t  BUCKVIOCKDIV2;                /*!< (@ 0x00000630) Sets BUCK_VIO switching frequency                          */
  __IM  uint32_t  RESERVED17;
  __IOM uint32_t  REG0ULPDISABLE;               /*!< (@ 0x00000638) Override Reg 0 ULP mode                                    */
  __IM  uint32_t  REG0CURRENTPWRREGMODE;        /*!< (@ 0x0000063C) Current mode in the Reg 0 (VIO) power regulator            */
  __IM  uint32_t  MAINREGSTATUS;                /*!< (@ 0x00000640) Main supply status                                         */
  __IM  uint32_t  RESERVED18[175];
  __IOM POWER_RAM_Type RAM[9];                  /*!< (@ 0x00000900) Unspecified                                                */
  __IM  uint32_t  RESERVED19[30];
  __IOM uint32_t  DCDCFORCE;                    /*!< (@ 0x00000A08) Force DC/DC power-up                                       */
  __IM  uint32_t  RESERVED20;
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x00000A10) 7-bit backdoor register for manual selection
                                                                    of power mode                                              */
  __IOM uint32_t  ID_VREG_0V9_PROG_0;           /*!< (@ 0x00000A14) Deprecated register - Pre-set 0v9 trim value
                                                                    0. Note: The reset value comes from FICR-&gt;CHIPCONF01.VR
                                                                    G0V9BYPASS                                                 */
  __IOM uint32_t  ID_VREG_0V9_PROG_1;           /*!< (@ 0x00000A18) Pre-set 0v9 trim value 1. Note: The reset value
                                                                    comes from FICR-&gt;CHIPCONF01.VREG0V9NORMCAL              */
  __IOM uint32_t  ID_VREG_0V9_PROG_2;           /*!< (@ 0x00000A1C) Pre-set 0v9 trim value 2. Note: The reset value
                                                                    comes from FICR-&gt;CHIPCONF01.VREG0V9REFRCAL              */
  __OM  uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x00000A20) Set threshold value of power regulator                     */
  __OM  uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000A24) Enable forcing of power mode in power regulator            */
  __OM  uint32_t  IGNOREDAPCPWRREGMODE;         /*!< (@ 0x00000A28) Ignore DAPCP power mode                                    */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000A2C) Current mode in the power regulator                        */
  __IOM uint32_t  EXTSILENTEN;                  /*!< (@ 0x00000A30) Enable silent external DCDC supply. This register
                                                                    only applies when DCDC is enabled in the
                                                                    DCDCEN0 register. Entering silent mode forbids
                                                                    the use of DCDC refresh mode internally
                                                                    in REG0.                                                   */
  __IOM uint32_t  FORCEREGEN0;                  /*!< (@ 0x00000A34) Enable force mode for REG0. Regulator(s) to be
                                                                    forces on is selected in FORCEREG0.                        */
  __IOM uint32_t  FORCEREG0;                    /*!< (@ 0x00000A38) Force regulator(s) on of for REG0 stage.                   */
  __IM  uint32_t  RESERVED21[298];
  __IOM uint32_t  SRAMTRIM;                     /*!< (@ 0x00000EE4) Backdoor trim values for SRAM                              */
} NRF_POWER_Type;                               /*!< Size = 3816 (0xee8)                                                       */



/* =========================================================================================================================== */
/* ================                                            P0                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 1 (P0)
  */

typedef struct {                                /*!< (@ 0x50000000) P0 Structure                                               */
  __IM  uint32_t  RESERVED[321];
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000504) Write GPIO port                                            */
  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000508) Set individual bits in GPIO port                           */
  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */
  __IM  uint32_t  IN;                           /*!< (@ 0x00000510) Read GPIO port                                             */
  __IOM uint32_t  DIR;                          /*!< (@ 0x00000514) Direction of GPIO pins                                     */
  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000518) DIR set register                                           */
  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000051C) DIR clear register                                         */
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000520) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000524) Select between default DETECT signal behaviour
                                                                    and LDETECT mode                                           */
  __IM  uint32_t  RESERVED1[54];
  __IOM GPIO_PIN_Type PIN[32];                  /*!< (@ 0x00000600) Pin n direct access                                        */
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;                                /*!< Size = 1920 (0x780)                                                       */



/* =========================================================================================================================== */
/* ================                                           RADIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief 2.4 GHz radio (RADIO)
  */

typedef struct {                                /*!< (@ 0x40001000) RADIO Structure                                            */
  __OM  uint32_t  TASKS_TXEN;                   /*!< (@ 0x00000000) Enable RADIO in TX mode                                    */
  __OM  uint32_t  TASKS_RXEN;                   /*!< (@ 0x00000004) Enable RADIO in RX mode                                    */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000008) Start RADIO                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x0000000C) Stop RADIO                                                 */
  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000010) Disable RADIO                                              */
  __OM  uint32_t  TASKS_RSSISTART;              /*!< (@ 0x00000014) Start the RSSI and take one single sample of
                                                                    the receive signal strength                                */
  __OM  uint32_t  TASKS_RSSISTOP;               /*!< (@ 0x00000018) Stop the RSSI measurement                                  */
  __OM  uint32_t  TASKS_BCSTART;                /*!< (@ 0x0000001C) Start the bit counter                                      */
  __OM  uint32_t  TASKS_BCSTOP;                 /*!< (@ 0x00000020) Stop the bit counter                                       */
  __OM  uint32_t  TASKS_EDSTART;                /*!< (@ 0x00000024) Start the energy detect measurement used in IEEE
                                                                    802.15.4 mode                                              */
  __OM  uint32_t  TASKS_EDSTOP;                 /*!< (@ 0x00000028) Stop the energy detect measurement                         */
  __OM  uint32_t  TASKS_CCASTART;               /*!< (@ 0x0000002C) Start the clear channel assessment used in IEEE
                                                                    802.15.4 mode                                              */
  __OM  uint32_t  TASKS_CCASTOP;                /*!< (@ 0x00000030) Stop the clear channel assessment                          */
  __OM  uint32_t  TASKS_AAFDCCAL_START;         /*!< (@ 0x00000034) Start aafdc calib                                          */
  __OM  uint32_t  TASKS_CNTP_START;             /*!< (@ 0x00000038) Start packet counter                                       */
  __OM  uint32_t  TASKS_CNTP_STOP;              /*!< (@ 0x0000003C) Stop packet counter                                        */
  __OM  uint32_t  TASKS_CNTP_CLEAR;             /*!< (@ 0x00000040) Clear packet counter                                       */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_DMA_START;              /*!< (@ 0x00000050) Start DMA transaction                                      */
  __OM  uint32_t  TASKS_DMA_STOP;               /*!< (@ 0x00000054) Stop ongoing DMA transaction                               */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_ACQSTART;               /*!< (@ 0x00000060) Start data acquisition                                     */
  __OM  uint32_t  TASKS_ACQSTOP;                /*!< (@ 0x00000064) Stop data acquisition                                      */
  __OM  uint32_t  TASKS_DFEDMA_START;           /*!< (@ 0x00000068) Start DFE DMA                                              */
  __OM  uint32_t  TASKS_DFEDMA_STOP;            /*!< (@ 0x0000006C) Stop DFE DMA                                               */
  __IM  uint32_t  RESERVED2[2];
  __OM  uint32_t  TASKS_PCGC_ZERO;              /*!< (@ 0x00000078) Zero penalty                                               */
  __OM  uint32_t  TASKS_PCGC_FULL;              /*!< (@ 0x0000007C) Full penalty                                               */
  __IM  uint32_t  RESERVED3[32];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) RADIO has ramped up and is ready to be started             */
  __IOM uint32_t  EVENTS_ADDRESS;               /*!< (@ 0x00000104) Address sent or received                                   */
  __IOM uint32_t  EVENTS_PAYLOAD;               /*!< (@ 0x00000108) Packet payload sent or received                            */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x0000010C) Packet sent or received                                    */
  __IOM uint32_t  EVENTS_DISABLED;              /*!< (@ 0x00000110) RADIO has been disabled                                    */
  __IOM uint32_t  EVENTS_DEVMATCH;              /*!< (@ 0x00000114) A device address match occurred on the last received
                                                                    packet                                                     */
  __IOM uint32_t  EVENTS_DEVMISS;               /*!< (@ 0x00000118) No device address match occurred on the last
                                                                    received packet                                            */
  __IOM uint32_t  EVENTS_RSSIEND;               /*!< (@ 0x0000011C) Sampling of receive signal strength complete               */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  EVENTS_BCMATCH;               /*!< (@ 0x00000128) Bit counter reached bit count value                        */
  __IOM uint32_t  EVENTS_DFEEND;                /*!< (@ 0x0000012C) DFE end event (nRF52 MPW2)                                 */
  __IOM uint32_t  EVENTS_CRCOK;                 /*!< (@ 0x00000130) Packet received with CRC ok                                */
  __IOM uint32_t  EVENTS_CRCERROR;              /*!< (@ 0x00000134) Packet received with CRC error                             */
  __IOM uint32_t  EVENTS_FRAMESTART;            /*!< (@ 0x00000138) IEEE 802.15.4 length field received                        */
  __IOM uint32_t  EVENTS_EDEND;                 /*!< (@ 0x0000013C) Sampling of energy detection complete. A new
                                                                    ED sample is ready for readout from the
                                                                    RADIO.EDSAMPLE register.                                   */
  __IOM uint32_t  EVENTS_EDSTOPPED;             /*!< (@ 0x00000140) The sampling of energy detection has stopped               */
  __IOM uint32_t  EVENTS_CCAIDLE;               /*!< (@ 0x00000144) Wireless medium in idle - clear to send                    */
  __IOM uint32_t  EVENTS_CCABUSY;               /*!< (@ 0x00000148) Wireless medium busy - do not send                         */
  __IOM uint32_t  EVENTS_CCASTOPPED;            /*!< (@ 0x0000014C) The CCA has stopped                                        */
  __IOM uint32_t  EVENTS_RATEBOOST;             /*!< (@ 0x00000150) Ble_LR CI field received, receive mode is changed
                                                                    from Ble_LR125Kbit to Ble_LR500Kbit.                       */
  __IOM uint32_t  EVENTS_TXREADY;               /*!< (@ 0x00000154) RADIO has ramped up and is ready to be started
                                                                    TX path                                                    */
  __IOM uint32_t  EVENTS_RXREADY;               /*!< (@ 0x00000158) RADIO has ramped up and is ready to be started
                                                                    RX path                                                    */
  __IOM uint32_t  EVENTS_MHRMATCH;              /*!< (@ 0x0000015C) MAC header match found                                     */
  __IOM uint32_t  EVENTS_ACQEND;                /*!< (@ 0x00000160) ACQDMA EasyDMA buffer full                                 */
  __IOM uint32_t  EVENTS_ACQREADY;              /*!< (@ 0x00000164) ACQDMA EasyDMA sample ready                                */
  __IOM uint32_t  EVENTS_SYNC;                  /*!< (@ 0x00000168) Preamble indicator.                                        */
  __IOM uint32_t  EVENTS_PHYEND;                /*!< (@ 0x0000016C) Generated in Ble_LR125Kbit, Ble_LR500Kbit and
                                                                    Ieee802154_250Kbit modes when last bit is
                                                                    sent on air.                                               */
  __IM  uint32_t  RESERVED5[36];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED6[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[61];
  __IM  uint32_t  CRCSTATUS;                    /*!< (@ 0x00000400) CRC status                                                 */
  __IM  uint32_t  RESERVED8;
  __IM  uint32_t  RXMATCH;                      /*!< (@ 0x00000408) Received address                                           */
  __IM  uint32_t  RXCRC;                        /*!< (@ 0x0000040C) CRC field of previously received packet                    */
  __IM  uint32_t  DAI;                          /*!< (@ 0x00000410) Device address match index                                 */
  __IM  uint32_t  PDUSTAT;                      /*!< (@ 0x00000414) Payload status                                             */
  __IM  uint32_t  DMA_STAT;                     /*!< (@ 0x00000418) DMA byte count                                             */
  __IM  uint32_t  RESERVED9;
  __IM  uint32_t  PLL_CAL_VCO;                  /*!< (@ 0x00000420) PLL Calibration                                            */
  __IM  uint32_t  LNB_OUT_SPI;                  /*!< (@ 0x00000424) Gain calibration                                           */
  __IM  uint32_t  RESERVED10[2];
  __IM  uint32_t  MISC_CAL_OUT1;                /*!< (@ 0x00000430) Misc cal readouts                                          */
  __IM  uint32_t  MISC_CAL_OUT2;                /*!< (@ 0x00000434) Misc cal readouts                                          */
  __IM  uint32_t  MISC_CAL_OUT3;                /*!< (@ 0x00000438) Misc cal readouts                                          */
  __IM  uint32_t  RESERVED11;
  __IM  uint32_t  CFO_STAT;                     /*!< (@ 0x00000440) Carrier freq. offset estimate                              */
  __IM  uint32_t  IQCAL_OUT;                    /*!< (@ 0x00000444) Test: IandQ gain/phase mismatch calibration values
                                                                    out                                                        */
  __IM  uint32_t  PBCAL_OUT;                    /*!< (@ 0x00000448) Test: PB calibration values out                            */
  __IM  uint32_t  DFESTATUS;                    /*!< (@ 0x0000044C) DFE status of packet received.                             */
  __IOM uint32_t  HYPSTDCHECKSTAT;              /*!< (@ 0x00000450) Address Check Override                                     */
  __IOM uint32_t  HYPSTDAADIFFVEC;              /*!< (@ 0x00000454) Address Diff Vector                                        */
  __IM  uint32_t  RESERVED12[43];
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000504) Packet pointer                                             */
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000508) Frequency                                                  */
  __IOM uint32_t  TXPOWER;                      /*!< (@ 0x0000050C) Output power                                               */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000510) Data rate and modulation                                   */
  __IOM uint32_t  PCNF0;                        /*!< (@ 0x00000514) Packet configuration register 0                            */
  __IOM uint32_t  PCNF1;                        /*!< (@ 0x00000518) Packet configuration register 1                            */
  __IOM uint32_t  BASE0;                        /*!< (@ 0x0000051C) Base address 0                                             */
  __IOM uint32_t  BASE1;                        /*!< (@ 0x00000520) Base address 1                                             */
  __IOM uint32_t  PREFIX0;                      /*!< (@ 0x00000524) Prefixes bytes for logical addresses 0-3                   */
  __IOM uint32_t  PREFIX1;                      /*!< (@ 0x00000528) Prefixes bytes for logical addresses 4-7                   */
  __IOM uint32_t  TXADDRESS;                    /*!< (@ 0x0000052C) Transmit address select                                    */
  __IOM uint32_t  RXADDRESSES;                  /*!< (@ 0x00000530) Receive address select                                     */
  __IOM uint32_t  CRCCNF;                       /*!< (@ 0x00000534) CRC configuration                                          */
  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000538) CRC polynomial                                             */
  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x0000053C) CRC initial value                                          */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  TIFS;                         /*!< (@ 0x00000544) Interframe spacing in us                                   */
  __IM  uint32_t  RSSISAMPLE;                   /*!< (@ 0x00000548) RSSI sample                                                */
  __IOM uint32_t  RSSI_CONFIG;                  /*!< (@ 0x0000054C) RSSI resolution                                            */
  __IM  uint32_t  STATE;                        /*!< (@ 0x00000550) Current radio state                                        */
  __IOM uint32_t  DATAWHITEIV;                  /*!< (@ 0x00000554) Data whitening initial value                               */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  DMA_MAXLEN;                   /*!< (@ 0x0000055C) DMA max length                                             */
  __IOM uint32_t  BCC;                          /*!< (@ 0x00000560) Bit counter compare                                        */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  AACHKOVERRIDE;                /*!< (@ 0x00000568) Address Check Override                                     */
  __IOM uint32_t  PB_TEST;                      /*!< (@ 0x0000056C) Test: PB calibration                                       */
  __IM  uint32_t  PACKET_CNTR1;                 /*!< (@ 0x00000570) Test: PER msrmnts                                          */
  __IM  uint32_t  PACKET_CNTR2;                 /*!< (@ 0x00000574) Test: PER msrmnts                                          */
  __IOM uint32_t  IQCAL_TEST;                   /*!< (@ 0x00000578) Test: IandQ gain/phase mismatch calibration control        */
  __IM  uint32_t  RESERVED16;
  __IOM uint32_t  DBC_COEFFS;                   /*!< (@ 0x00000580) Test and Debug: DBC coefficients override                  */
  __IOM uint32_t  FS_CONFIG;                    /*!< (@ 0x00000584) Fs config (ana+dig)                                        */
  __IOM uint32_t  FS_TEST;                      /*!< (@ 0x00000588) Fs misc test                                               */
  __IOM uint32_t  FS_TRIM;                      /*!< (@ 0x0000058C) Fs misc trim                                               */
  __IOM uint32_t  MISC_TRIM1;                   /*!< (@ 0x00000590) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  MISC_TEST1;                   /*!< (@ 0x00000594) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  MISC_TEST2;                   /*!< (@ 0x00000598) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  RX_CONFIG;                    /*!< (@ 0x0000059C) Misc RX config                                             */
  __IM  uint32_t  RESERVED17[24];
  __IOM uint32_t  DAB[8];                       /*!< (@ 0x00000600) Description collection: Device address base segment
                                                                    n                                                          */
  __IOM uint32_t  DAP[8];                       /*!< (@ 0x00000620) Description collection: Device address prefix
                                                                    n                                                          */
  __IOM uint32_t  DACNF;                        /*!< (@ 0x00000640) Device address match configuration                         */
  __IOM uint32_t  MHRMATCHCONF;                 /*!< (@ 0x00000644) Search pattern configuration                               */
  __IOM uint32_t  MHRMATCHMAS;                  /*!< (@ 0x00000648) Pattern mask                                               */
  __IOM uint32_t  ADDRWINSIZE;                  /*!< (@ 0x0000064C) address match safe window size (the number of
                                                                    bits after detect is asserted, before starting
                                                                    to look for address match). Only valid when
                                                                    OVERRIDE22.DISABLEADDRWINDOW is '0'                        */
  __IOM uint32_t  MODECNF0;                     /*!< (@ 0x00000650) Radio mode configuration register 0                        */
  __IOM uint32_t  MODECNF1;                     /*!< (@ 0x00000654) Radio mode configuration register 1                        */
  __IOM uint32_t  DFEMODE;                      /*!< (@ 0x00000658) Radio direction finding configuration                      */
  __IM  uint32_t  RESERVED18;
  __IOM uint32_t  SFD;                          /*!< (@ 0x00000660) IEEE 802.15.4 start of frame delimiter                     */
  __IOM uint32_t  EDCNT;                        /*!< (@ 0x00000664) IEEE 802.15.4 energy detect loop count                     */
  __IOM uint32_t  EDSAMPLE;                     /*!< (@ 0x00000668) IEEE 802.15.4 energy detect level                          */
  __IOM uint32_t  CCACTRL;                      /*!< (@ 0x0000066C) IEEE 802.15.4 clear channel assessment control             */
  __IOM uint32_t  STTCNFG;                      /*!< (@ 0x00000670) Symbol Tracking Timing Configuration                       */
  __IOM uint32_t  STTCNFG_LR;                   /*!< (@ 0x00000674) Strobe time control in long range mode                     */
  __IOM uint32_t  LELRMISC;                     /*!< (@ 0x00000678) Miscellaneous Controls for Long Range                      */
  __IOM uint32_t  DRIFT_LR;                     /*!< (@ 0x0000067C) Drift Controls in Long Range                               */
  __IM  uint32_t  RESERVED19[33];
  __IOM uint32_t  AGC_TOGGLE;                   /*!< (@ 0x00000704) Constant AGC Gain switching, Debug                         */
  __IOM uint32_t  AGC_EN;                       /*!< (@ 0x00000708) AGC enable                                                 */
  __IOM uint32_t  AGC_OVERRIDE;                 /*!< (@ 0x0000070C) Gain setting                                               */
  __IM  uint32_t  RESERVED20[5];
  __IOM uint32_t  QOVERRIDE0;                   /*!< (@ 0x00000724) Trim value override register 0 for nRF52                   */
  __IOM uint32_t  QOVERRIDE1;                   /*!< (@ 0x00000728) Trim value override register 1 for nRF52                   */
  __IOM uint32_t  QOVERRIDE2;                   /*!< (@ 0x0000072C) Trim value override register 2 for nRF52                   */
  __IOM uint32_t  QOVERRIDE3;                   /*!< (@ 0x00000730) Trim value override register 3 for nRF52                   */
  __IOM uint32_t  QOVERRIDE4;                   /*!< (@ 0x00000734) Trim value override register 4 for nRF52                   */
  __IOM uint32_t  QOVERRIDE5;                   /*!< (@ 0x00000738) Trim value override register 5 for nRF52                   */
  __IOM uint32_t  QOVERRIDE6;                   /*!< (@ 0x0000073C) Trim value override register 6 for nRF52                   */
  __IOM uint32_t  QOVERRIDE7;                   /*!< (@ 0x00000740) Trim value override register 7 for nRF52                   */
  __IOM uint32_t  QOVERRIDE8;                   /*!< (@ 0x00000744) Trim value override register 8 for nRF52                   */
  __IOM uint32_t  QOVERRIDE9;                   /*!< (@ 0x00000748) Trim value override register 9 for nRF52                   */
  __IOM uint32_t  QOVERRIDE10;                  /*!< (@ 0x0000074C) Trim value override register 10 for nRF52                  */
  __IOM uint32_t  QOVERRIDE11;                  /*!< (@ 0x00000750) Trim value override register 11 for nRF52                  */
  __IOM uint32_t  QOVERRIDE12;                  /*!< (@ 0x00000754) Trim value override register 12 for nRF52                  */
  __IOM uint32_t  QOVERRIDE13;                  /*!< (@ 0x00000758) Trim value override register 13 for nRF52                  */
  __IOM uint32_t  QOVERRIDE14;                  /*!< (@ 0x0000075C) Trim value override register 14 for nRF52                  */
  __IOM uint32_t  QOVERRIDE15;                  /*!< (@ 0x00000760) Trim value override register 15 for nRF52                  */
  __IOM uint32_t  QOVERRIDE16;                  /*!< (@ 0x00000764) Trim value override register 16 for nRF52                  */
  __IOM uint32_t  QOVERRIDE17;                  /*!< (@ 0x00000768) Trim value override register 17 for nRF52                  */
  __IOM uint32_t  QOVERRIDE18;                  /*!< (@ 0x0000076C) Trim value override register 18 for nRF52                  */
  __IOM uint32_t  QOVERRIDE19;                  /*!< (@ 0x00000770) Trim value override register 19 for nRF52                  */
  __IOM uint32_t  QOVERRIDE20;                  /*!< (@ 0x00000774) Trim value override register 20 for nRF52                  */
  __IOM uint32_t  QOVERRIDE21;                  /*!< (@ 0x00000778) Trim value override register 21 for nRF52                  */
  __IOM uint32_t  QOVERRIDE22;                  /*!< (@ 0x0000077C) Trim value override register 22 for nRF52                  */
  __IOM uint32_t  QOVERRIDE23;                  /*!< (@ 0x00000780) Trim value override register 23 for nRF52                  */
  __IOM uint32_t  CNRIPPLEDETECT;               /*!< (@ 0x00000784) Configuration for the CNRIPPLEWARN functionality
                                                                    used for BLE LR. Configuration is only enabled
                                                                    when OVRENCNRIPPLEWARNCFG in OVERRIDE23
                                                                    is set                                                     */
  __IM  uint32_t  RESERVED21[30];
  __IOM RADIO_DEBUGPSEL_Type DEBUGPSEL;         /*!< (@ 0x00000800) Unspecified                                                */
  __IM  uint32_t  RESERVED22[5];
  __IOM uint32_t  ATEPANTHER;                   /*!< (@ 0x0000081C) Analog test bus control for Panther radio                  */
  __IM  uint32_t  RESERVED23[56];
  __IOM uint32_t  DFECTRL1;                     /*!< (@ 0x00000900) Direction finding register 1 for nRF52                     */
  __IOM uint32_t  DFECTRL2;                     /*!< (@ 0x00000904) Direction finding register 2 for nRF52                     */
  __IM  uint32_t  DFEREAD;                      /*!< (@ 0x00000908) Direction finding read register for nRF52                  */
  __IOM uint32_t  DFEWRITE;                     /*!< (@ 0x0000090C) Direction finding write register for nRF52                 */
  __IOM RADIO_DFEPSEL_Type DFEPSEL;             /*!< (@ 0x00000910) Unspecified                                                */
  __IM  uint32_t  RESERVED24[10];
  __IOM RADIO_DFEPACKET_Type DFEPACKET;         /*!< (@ 0x00000950) DFE packet EasyDMA channel                                 */
  __IM  uint32_t  RESERVED25[52];
  __IOM uint32_t  ACQENABLE;                    /*!< (@ 0x00000A30) Enable or disable data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM RADIO_ACQDMA_Type ACQDMA;               /*!< (@ 0x00000A34) EasyDMA channel for data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  ACQMODE;                      /*!< (@ 0x00000A40) Data acquisition capture mode (refer to 4378_164)          */
  __IOM uint32_t  ACQAHBCNF;                    /*!< (@ 0x00000A44) Data acquisition EasyDMA AHB configuration register
                                                                    (refer to 4378_164)                                        */
  __IM  uint32_t  RESERVED26[110];
  __IOM uint32_t  PCGC_PENALTY;                 /*!< (@ 0x00000C00) Power and clock                                            */
  __IM  uint32_t  RESERVED27[3];
  __IOM uint32_t  PCGC_OVERRIDE;                /*!< (@ 0x00000C10) Power and clock                                            */
  __IM  uint32_t  RESERVED28[3];
  __IOM uint32_t  PCGC_CLK_REQ;                 /*!< (@ 0x00000C20) Power and clock                                            */
  __IM  uint32_t  RESERVED29[55];
  __IOM uint32_t  PCGC_BACKDOOR;                /*!< (@ 0x00000D00) Power and clock                                            */
  __IOM uint32_t  PCGC_FORCEREG;                /*!< (@ 0x00000D04) Power and clock                                            */
  __IM  uint32_t  RESERVED30[189];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RADIO_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter (UART0)
  */

typedef struct {                                /*!< (@ 0x40002000) UART0 Structure                                            */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART                                               */
  __IM  uint32_t  RESERVED1[56];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD                                       */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED5[46];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source                                               */
  __IM  uint32_t  RESERVED8[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED9;
  __IOM UART_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __OM  uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED11[17];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
  __IM  uint32_t  RESERVED12[675];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_UART_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          UARTE0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA 0 (UARTE0)
  */

typedef struct {                                /*!< (@ 0x40002000) UARTE0 Structure                                           */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART transaction                                   */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume UART transaction                                    */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_FLUSHRX;                /*!< (@ 0x0000002C) Flush RX FIFO into RX buffer                               */
  __IM  uint32_t  RESERVED2[52];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) Receive buffer is filled up                                */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) Last TX byte transmitted                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED5[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) UART receiver has started                                  */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) UART transmitter has started                               */
  __IOM uint32_t  EVENTS_RTS;                   /*!< (@ 0x00000154) RX FIFO has only room for four more bytes before
                                                                    it overflows                                               */
  __IOM uint32_t  EVENTS_TXSTOPPED;             /*!< (@ 0x00000158) Transmitter stopped                                        */
  __IM  uint32_t  RESERVED7[41];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED9[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source Note : this register is read / write
                                                                    one to clear.                                              */
  __IM  uint32_t  RESERVED10[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED11;
  __IOM UARTE_PSEL_Type PSEL;                   /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED12[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED13[3];
  __IOM UARTE_RXD_Type RXD;                     /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED14;
  __IOM UARTE_TXD_Type TXD;                     /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED15[7];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
  __IM  uint32_t  RESERVED16[675];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_UARTE_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface 0 (SPI0)
  */

typedef struct {                                /*!< (@ 0x40003000) SPI0 Structure                                             */
  __IM  uint32_t  RESERVED[66];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000108) TXD byte sent and RXD byte received                        */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI                                                 */
  __IM  uint32_t  RESERVED3;
  __IOM SPI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED4;
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED7[681];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPIM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0)
  */

typedef struct {                                /*!< (@ 0x40003000) SPIM0 Structure                                            */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000010) Start SPI transaction                                      */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop SPI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend SPI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume SPI transaction                                     */
  __IM  uint32_t  RESERVED2[56];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) SPI transaction has stopped                                */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000118) End of RXD buffer and TXD buffer reached                   */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) End of TXD buffer reached                                  */
  __IM  uint32_t  RESERVED6[10];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x0000014C) Transaction started                                        */
  __IM  uint32_t  RESERVED7[44];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED9[61];
  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
                                                                    in this register is set to STALL by hardware
                                                                    whenever a stall occurres and can be cleared
                                                                    (set to NOSTALL) by the CPU.                               */
  __IM  uint32_t  RESERVED10[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPIM                                                */
  __IM  uint32_t  RESERVED11;
  __IOM SPIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RXDDATA;                      /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXDDATA;                      /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED13[3];
  __IOM SPIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM SPIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED14[2];
  __IOM SPIM_IFTIMING_Type IFTIMING;            /*!< (@ 0x00000560) Unspecified                                                */
  __IOM uint32_t  CSNPOL;                       /*!< (@ 0x00000568) Polarity of CSN output                                     */
  __IOM uint32_t  PSELDCX;                      /*!< (@ 0x0000056C) Pin select for DCX signal                                  */
  __IOM uint32_t  DCXCNT;                       /*!< (@ 0x00000570) DCX configuration                                          */
  __IM  uint32_t  RESERVED15[19];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
                                                                    been transmitted in the case when RXD.MAXCNT
                                                                    is greater than TXD.MAXCNT                                 */
  __IM  uint32_t  RESERVED16[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIM_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPIS0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 0 (SPIS0)
  */

typedef struct {                                /*!< (@ 0x40003000) SPIS0 Structure                                            */
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;                /*!< (@ 0x00000024) Acquire SPI semaphore                                      */
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[54];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) Granted transaction completed                              */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  EVENTS_ACQUIRED;              /*!< (@ 0x00000128) Semaphore acquired                                         */
  __IM  uint32_t  RESERVED4[53];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[61];
  __IM  uint32_t  SEMSTAT;                      /*!< (@ 0x00000400) Semaphore status register                                  */
  __IM  uint32_t  RESERVED7[15];
  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000440) Status from last transaction                               */
  __IM  uint32_t  RESERVED8[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI slave                                           */
  __IM  uint32_t  RESERVED9;
  __IOM SPIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED10[7];
  __IOM SPIS_RXD_Type RXD;                      /*!< (@ 0x00000534) Unspecified                                                */
  __IOM SPIS_TXD_Type TXD;                      /*!< (@ 0x00000544) Unspecified                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED12[24];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character                                        */
  __IM  uint32_t  RESERVED13[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIS_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Interface 0 (TWI0)
  */

typedef struct {                                /*!< (@ 0x40003000) TWI0 Structure                                             */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[56];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IOM uint32_t  EVENTS_RXDREADY;              /*!< (@ 0x00000108) TWI RXD byte received                                      */
  __IM  uint32_t  RESERVED4[4];
  __IOM uint32_t  EVENTS_TXDSENT;               /*!< (@ 0x0000011C) TWI TXD byte sent                                          */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) TWI entered the suspended state                            */
  __IM  uint32_t  RESERVED8[45];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED9[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED10[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED11[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWI                                                 */
  __IM  uint32_t  RESERVED12;
  __IOM TWI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED13[2];
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED15[24];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
  __IM  uint32_t  RESERVED16[668];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWIM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0)
  */

typedef struct {                                /*!< (@ 0x40003000) TWIM0 Structure                                            */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[56];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer access by EasyDMA                        */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) END of TXD buffer access by EasyDMA                        */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) Last byte has been sent out after the SUSPEND
                                                                    task has been issued, TWI traffic is now
                                                                    suspended.                                                 */
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  EVENTS_LASTRX;                /*!< (@ 0x0000015C) Byte boundary, starting to receive the last byte           */
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED9[39];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED10[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED11[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED12[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIM                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IOM TWIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED13[5];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED14[3];
  __IOM TWIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED15[13];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
  __IM  uint32_t  RESERVED16[668];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWIM_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWIS0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0)
  */

typedef struct {                                /*!< (@ 0x40003000) TWIS0 Structure                                            */
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;              /*!< (@ 0x00000030) Prepare the TWI slave to respond to a write command        */
  __OM  uint32_t  TASKS_PREPARETX;              /*!< (@ 0x00000034) Prepare the TWI slave to respond to a read command         */
  __IM  uint32_t  RESERVED3[51];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  EVENTS_NACKTX;                /*!< (@ 0x00000134) NACK on TX                                                 */
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED7[4];
  __IOM uint32_t  EVENTS_WRITE;                 /*!< (@ 0x00000164) Write command received                                     */
  __IOM uint32_t  EVENTS_READ;                  /*!< (@ 0x00000168) Read command received                                      */
  __IOM uint32_t  EVENTS_CSSTARTED;             /*!< (@ 0x0000016C) TWI started stretching the clock                           */
  __IOM uint32_t  EVENTS_CSSTOPPED;             /*!< (@ 0x00000170) TWI stopped stretching the clock                           */
  __IM  uint32_t  RESERVED8[35];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED9[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED10[113];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004D0) Error source                                               */
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  PINSTATUS;                    /*!< (@ 0x000004D8) Returns state of signals reflecting the SDA and
                                                                    SCL line status. All fields will return
                                                                    a '0' if DEBUGENABLE is not Enabled.                       */
  __IM  uint32_t  RESERVED11[9];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIS                                                */
  __IM  uint32_t  RESERVED12;
  __IOM TWIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED13[9];
  __IOM TWIS_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIS_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED14[13];
  __IOM uint32_t  ADDRESS[2];                   /*!< (@ 0x00000588) Description collection: TWI slave address n                */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED16[2];
  __IOM uint32_t  INPUTMODE;                    /*!< (@ 0x000005A0) Input mode                                                 */
  __IOM uint32_t  DEBUGENABLE;                  /*!< (@ 0x000005A4) Enable TWIS debug features (PINSTATUS register)            */
  __IM  uint32_t  RESERVED17[6];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
  __IM  uint32_t  RESERVED18[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWIS_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           NFCT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief NFC-A compatible radio (NFCT)
  */

typedef struct {                                /*!< (@ 0x40005000) NFCT Structure                                             */
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
                                                                    frames, change state to activated                          */
  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000004) Disable NFCT peripheral                                    */
  __OM  uint32_t  TASKS_SENSE;                  /*!< (@ 0x00000008) Enable NFC sense field mode, change state to
                                                                    sense mode                                                 */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
                                                                    state to transmit                                          */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x00000010) Stops an issued transmission of a frame                    */
  __OM  uint32_t  TASKS_START_ROSCCAL;          /*!< (@ 0x00000014) Starts calibration of ring oscillator                      */
  __OM  uint32_t  TASKS_FREQMEASURE;            /*!< (@ 0x00000018) Measures the 13.56 MHz clock frequency                     */
  __OM  uint32_t  TASKS_ENABLERXDATA;           /*!< (@ 0x0000001C) Initializes the EasyDMA for receive.                       */
  __OM  uint32_t  TASKS_DISABLERXDATA;          /*!< (@ 0x00000020) Ends current EasyDMA transfer and stops waiting
                                                                    for start of frame (SoF)                                   */
  __OM  uint32_t  TASKS_GOIDLE;                 /*!< (@ 0x00000024) Force state machine to IDLE state                          */
  __OM  uint32_t  TASKS_GOSLEEP;                /*!< (@ 0x00000028) Force state machine to SLEEP_A state                       */
  __IM  uint32_t  RESERVED[53];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
                                                                    frames                                                     */
  __IOM uint32_t  EVENTS_FIELDDETECTED;         /*!< (@ 0x00000104) Remote NFC field detected                                  */
  __IOM uint32_t  EVENTS_FIELDLOST;             /*!< (@ 0x00000108) Remote NFC field lost                                      */
  __IOM uint32_t  EVENTS_TXFRAMESTART;          /*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_TXFRAMEEND;            /*!< (@ 0x00000110) Marks the end of the last transmitted on-air
                                                                    symbol of a frame data bit on the last positive
                                                                    edge ckTxNfc with nfcTransmit = 1                          */
  __IOM uint32_t  EVENTS_RXFRAMESTART;          /*!< (@ 0x00000114) Marks the end of the first symbol of a received
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_RXFRAMEEND;            /*!< (@ 0x00000118) Received data has been checked (CRC, parity)
                                                                    and transferred to RAM, and EasyDMA has
                                                                    ended accessing the RX buffer                              */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
                                                                    contains details on the source of the error.               */
  __IOM uint32_t  EVENTS_FREQMEASUREDONE;       /*!< (@ 0x00000120) Done with one frequency measurement, result available
                                                                    in the MEASUREDFREQ register. This event
                                                                    will fire several times during calibration.                */
  __IOM uint32_t  EVENTS_CALCOMPLETE;           /*!< (@ 0x00000124) NFC ring oscillator calibration complete.                  */
  __IOM uint32_t  EVENTS_RXERROR;               /*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
                                                                    register contains details on the source
                                                                    of the error.                                              */
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
                                                                    in Data RAM full.                                          */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
                                                                    has ended accessing the TX buffer                          */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;     /*!< (@ 0x00000138) Auto collision resolution process has started
                                                                    Event generated when ALL_REQ or SENS_REQ
                                                                    has been received while in IDLE state                      */
  __IOM uint32_t  EVENTS_AUTOCOLRES1;           /*!< (@ 0x0000013C) Auto collision resolution cascade level 1 succeeded        */
  __IOM uint32_t  EVENTS_AUTOCOLRES2;           /*!< (@ 0x00000140) Auto collision resolution cascade level 2 succeeded        */
  __IOM uint32_t  EVENTS_AUTOCOLRES3;           /*!< (@ 0x00000144) Auto collision resolution cascade level 3 succeeded        */
  __IOM uint32_t  EVENTS_COLLISION;             /*!< (@ 0x00000148) NFC auto collision resolution error reported.
                                                                    The AUTOCOLRESSTATUS register contains details
                                                                    on the source of the error.                                */
  __IOM uint32_t  EVENTS_SELECTED;              /*!< (@ 0x0000014C) NFC auto collision resolution successfully completed       */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000150) EasyDMA is ready to receive or send frames.                */
  __IM  uint32_t  RESERVED2[43];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[61];
  __IM  uint32_t  PWRUPSENSE;                   /*!< (@ 0x00000400) Tells if the NFCT peripheral is in SENSE mode              */
  __IOM uint32_t  ERRORSTATUS;                  /*!< (@ 0x00000404) NFC Error Status register                                  */
  __IOM uint32_t  AUTOCOLRESSTATUS;             /*!< (@ 0x00000408) NFC Auto collision resolution Error Status register        */
  __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;      /*!< (@ 0x0000040C) Unspecified                                                */
  __IM  uint32_t  NFCTAGSTATE;                  /*!< (@ 0x00000410) NfcTag state register                                      */
  __IM  uint32_t  RESERVED5[3];
  __IM  uint32_t  SLEEPSTATE;                   /*!< (@ 0x00000420) Sleep state during automatic collision resolution          */
  __IM  uint32_t  BYTESWRITTENTORAM;            /*!< (@ 0x00000424) Number of bytes written to RAM                             */
  __IM  uint32_t  NFCFRAMINGCORESTATE;          /*!< (@ 0x00000428) NFC Framing Core State                                     */
  __IOM uint32_t  NFCANTICOLRESSTATE;           /*!< (@ 0x0000042C) Automatic collision resolution (anti-collision)
                                                                    state                                                      */
  __IM  uint32_t  RESERVED6;
  __IM  uint32_t  MEASUREDFREQ;                 /*!< (@ 0x00000434) The frequency measured on the 13.56 MHz NFC carrier
                                                                    signal                                                     */
  __IM  uint32_t  ROSCCALVALUE;                 /*!< (@ 0x00000438) The current value used by the ring oscillator              */
  __IM  uint32_t  FIELDPRESENT;                 /*!< (@ 0x0000043C) Indicates the presence or not of a valid field             */
  __IM  uint32_t  CURRENTPEAKDETECTREF;         /*!< (@ 0x00000440) Current peak detect reference                              */
  __IM  uint32_t  RESERVED7[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Register to enable NFC functionality                       */
  __IOM uint32_t  FRAMEDELAYMIN;                /*!< (@ 0x00000504) Minimum frame delay                                        */
  __IOM uint32_t  FRAMEDELAYMAX;                /*!< (@ 0x00000508) Maximum frame delay                                        */
  __IOM uint32_t  FRAMEDELAYMODE;               /*!< (@ 0x0000050C) Configuration register for the Frame Delay Timer           */
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
                                                                    Data RAM                                                   */
  __IOM uint32_t  MAXLEN;                       /*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
                                                                    data storage each                                          */
  __IOM NFCT_TXD_Type TXD;                      /*!< (@ 0x00000518) Unspecified                                                */
  __IOM NFCT_RXD_Type RXD;                      /*!< (@ 0x00000520) Unspecified                                                */
  __IOM uint32_t  FRAMEDELAYSHIFT;              /*!< (@ 0x00000528) Correction for the frame delay reference                   */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000530) CRC polynomial                                             */
  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x00000534) CRC initial value                                          */
  __IM  uint32_t  RESERVED9[22];
  __IOM uint32_t  NFCID1_LAST;                  /*!< (@ 0x00000590) Last NFCID1 part (4, 7 or 10 bytes ID)                     */
  __IOM uint32_t  NFCID1_2ND_LAST;              /*!< (@ 0x00000594) Second last NFCID1 part (7 or 10 bytes ID)                 */
  __IOM uint32_t  NFCID1_3RD_LAST;              /*!< (@ 0x00000598) Third last NFCID1 part (10 bytes ID)                       */
  __IOM uint32_t  AUTOCOLRESCONFIG;             /*!< (@ 0x0000059C) Controls the auto collision resolution function.
                                                                    This setting must be done before the NFCT
                                                                    peripheral is activated.                                   */
  __IOM uint32_t  SENSRES;                      /*!< (@ 0x000005A0) NFC-A SENS_RES auto-response settings                      */
  __IOM uint32_t  SELRES;                       /*!< (@ 0x000005A4) NFC-A SEL_RES auto-response settings                       */
  __IM  uint32_t  RESERVED10[29];
  __IOM uint32_t  DEMODCONFIG;                  /*!< (@ 0x0000061C) Configuration settings for demodulation                    */
  __IOM uint32_t  FIELDDETECTCONFIG;            /*!< (@ 0x00000620) Configuration for NFCT_FIELDDETECT_TSMC55N                 */
  __IOM uint32_t  ANALOGTESTBUSEN;              /*!< (@ 0x00000624) Analog Testbus Enable - ATB0 only                          */
  __IOM uint32_t  SYMBOLTOLLOWER;               /*!< (@ 0x00000628) Configuration register for the tolerance of the
                                                                    received NFC pulse width                                   */
  __IOM uint32_t  SYMBOLTOLUPPER;               /*!< (@ 0x0000062C) Configuration register for the tolerance of the
                                                                    received NFC pulse width                                   */
  __IOM uint32_t  CONTINUOUSSUBCARRIER;         /*!< (@ 0x00000630) Selects continuous sub-carrier transmission                */
  __IM  uint32_t  RESERVED11[2];
  __IOM uint32_t  CLOCKRECCONFIG;               /*!< (@ 0x0000063C) Configuration for NFCT_CLOCKREC_TSMC55N                    */
  __IOM uint32_t  CLOCKSOURCE;                  /*!< (@ 0x00000640) Deprecated register - Clock source                         */
  __IOM uint32_t  FRAMECONTENT1;                /*!< (@ 0x00000644) Deprecated register - Buffer for custom-frame
                                                                    autoresponse frame-content, when no DMA
                                                                    is available                                               */
  __IOM uint32_t  FRAMECONTENT2;                /*!< (@ 0x00000648) Deprecated register - Buffer for custom-frame
                                                                    autoresponse, when no DMA is available                     */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  OVERRIDEENABLE;               /*!< (@ 0x00000650) Enables override functionality.                            */
  __IM  uint32_t  RESERVED13[3];
  __IOM uint32_t  OVRVALPWRUPNFC;               /*!< (@ 0x00000660) Override value for pwrupNfc                                */
  __IOM uint32_t  OVRVALMODULATION;             /*!< (@ 0x00000664) Override value for modulation on/off                       */
  __IOM uint32_t  OVRVALLOADINACTIVE;           /*!< (@ 0x00000668) Override value for the load control when modulation
                                                                    is off                                                     */
  __IOM uint32_t  OVRVALLOADACTIVE;             /*!< (@ 0x0000066C) Override value for the load control when modulation
                                                                    is on                                                      */
  __IOM uint32_t  OVRVALPWRUPRES;               /*!< (@ 0x00000670) Override value for power up resistor in the analog
                                                                    pad                                                        */
  __IOM uint32_t  OVRVALROSCCALCODE;            /*!< (@ 0x00000674) Override value for the calibration word for the
                                                                    oscillator                                                 */
  __IOM uint32_t  OVRVALROSCCALEN;              /*!< (@ 0x00000678) Override value for the signal CALEN going to
                                                                    the oscillator                                             */
  __IOM uint32_t  OVRVALCLAMPEN2V2;             /*!< (@ 0x0000067C) Override value for the 2V2 clamp                           */
  __IOM uint32_t  OVRVALCLAMPEN3V6;             /*!< (@ 0x00000680) Override value for the 3V6 clamp                           */
  __IOM uint32_t  AUTOCAL;                      /*!< (@ 0x00000684) Controls auto-calibration at NFCT module enabling          */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  SHUNTREGCONFIG;               /*!< (@ 0x0000068C) Configuration for NFCT_SHUNTREG_TSMC55N                    */
  __IOM uint32_t  LOADMODCONFIG;                /*!< (@ 0x00000690) Configuration for load modulation                          */
  __IOM uint32_t  SHUNTNMOSADJUST;              /*!< (@ 0x00000694) Size adjustment for the shunt NMOS in shunt regulator      */
  __IOM uint32_t  RSHUNTCTRL;                   /*!< (@ 0x00000698) Adjust internal shunt resistance                           */
  __IOM uint32_t  OVRVALPEAKDETECTREF;          /*!< (@ 0x0000069C) Override value for the peak detect reference
                                                                    voltage                                                    */
  __IOM uint32_t  LOCKDETECTWINDOW;             /*!< (@ 0x000006A0) Adjust window size on falling edge of lock detect
                                                                    filter used for demodulation                               */
  __IM  uint32_t  RESERVED15[598];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_NFCT_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          GPIOTE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events (GPIOTE)
  */

typedef struct {                                /*!< (@ 0x40006000) GPIOTE Structure                                           */
  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IM  uint32_t  RESERVED2[32];
  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IM  uint32_t  RESERVED4[96];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[129];
  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n] and CLR[n] tasks and IN[n] event                    */
  __IM  uint32_t  RESERVED6[52];
  __IOM uint32_t  DEBOUNCE[8];                  /*!< (@ 0x00000600) Description collection: Debounce mode for GPIOTE
                                                                    channel n                                                  */
  __IM  uint32_t  RESERVED7[440];
  __OM  GPIOTE_TASKS_PCPPEN_Type TASKS_PCPPEN[5];/*!< (@ 0x00000D00) Peripheral tasks.                                         */
  __IM  uint32_t  RESERVED8[181];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_GPIOTE_Type;                              /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SAADC                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Successive approximation register (SAR) analog-to-digital converter (SAADC)
  */

typedef struct {                                /*!< (@ 0x40007000) SAADC Structure                                            */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts the SAADC and prepares the result buffer
                                                                    in RAM                                                     */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Takes one SAADC sample                                     */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stops the SAADC and terminates all on-going conversions    */
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;        /*!< (@ 0x0000000C) Starts offset auto-calibration                             */
  __OM  uint32_t  TASKS_CALIBRATEGAIN;          /*!< (@ 0x00000010) Starts gain auto-calibration                               */
  __IM  uint32_t  RESERVED[59];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) The SAADC has started                                      */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) The SAADC has filled up the result buffer                  */
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the configuration, multiple conversions
                                                                    might be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;            /*!< (@ 0x0000010C) Result ready for transfer to RAM Result is available
                                                                    in REGRESULT register                                      */
  __IOM uint32_t  EVENTS_CALIBRATEDONE;         /*!< (@ 0x00000110) Calibration is complete                                    */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000114) The SAADC has stopped                                      */
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];      /*!< (@ 0x00000118) Peripheral events.                                         */
  __IM  uint32_t  RESERVED1[42];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Status                                                     */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable or disable SAADC                                    */
  __IM  uint32_t  RESERVED5[3];
  __IOM SAADC_CH_Type CH[8];                    /*!< (@ 0x00000510) Unspecified                                                */
  __IM  uint32_t  RESERVED6[23];
  __IM  uint32_t  REGRESULT;                    /*!< (@ 0x000005EC) Last conversion result                                     */
  __IOM uint32_t  RESOLUTION;                   /*!< (@ 0x000005F0) Resolution configuration                                   */
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. The RESOLUTION is
                                                                    applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;                   /*!< (@ 0x000005F8) Controls normal or continuous sample rate                  */
  __IM  uint32_t  RESERVED7[12];
  __IOM SAADC_RESULT_Type RESULT;               /*!< (@ 0x0000062C) RESULT EasyDMA channel                                     */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  TESTCTRL;                     /*!< (@ 0x0000063C) Control signals used during test of SAADC                  */
  __IOM uint32_t  CALOFFSET;                    /*!< (@ 0x00000640) Calibration control for offset error                       */
  __IOM uint32_t  CALGAIN;                      /*!< (@ 0x00000644) Calibration control for gain error                         */
  __IOM uint32_t  CALVREF;                      /*!< (@ 0x00000648) Calibration control for reference voltage                  */
  __IM  uint32_t  RESERVED9[620];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SAADC_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          TIMER0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0)
  */

typedef struct {                                /*!< (@ 0x40008000) TIMER0 Structure                                           */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start Timer                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop Timer                                                 */
  __OM  uint32_t  TASKS_COUNT;                  /*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x0000000C) Clear time                                                 */
  __OM  uint32_t  TASKS_SHUTDOWN;               /*!< (@ 0x00000010) Deprecated register - Shut down timer                      */
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[58];
  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[42];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED3[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[126];
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Timer mode selection                                       */
  __IOM uint32_t  BITMODE;                      /*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000510) Timer prescaler register                                   */
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
  __IM  uint32_t  RESERVED7[681];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TIMER_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           RTC0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real time counter 0 (RTC0)
  */

typedef struct {                                /*!< (@ 0x4000B000) RTC0 Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start RTC COUNTER                                          */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop RTC COUNTER                                           */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x00000008) Clear RTC COUNTER                                          */
  __OM  uint32_t  TASKS_TRIGOVRFLW;             /*!< (@ 0x0000000C) Set COUNTER to 0xFFFFF0                                    */
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_TICK;                  /*!< (@ 0x00000100) Event on COUNTER increment                                 */
  __IOM uint32_t  EVENTS_OVRFLW;                /*!< (@ 0x00000104) Event on COUNTER overflow                                  */
  __IM  uint32_t  RESERVED1[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[108];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[13];
  __IOM uint32_t  EVTEN;                        /*!< (@ 0x00000340) Enable or disable event routing                            */
  __IOM uint32_t  EVTENSET;                     /*!< (@ 0x00000344) Enable event routing                                       */
  __IOM uint32_t  EVTENCLR;                     /*!< (@ 0x00000348) Disable event routing                                      */
  __IM  uint32_t  RESERVED4[45];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) RTC status                                                 */
  __IM  uint32_t  RESERVED5[64];
  __IM  uint32_t  COUNTER;                      /*!< (@ 0x00000504) Current COUNTER value                                      */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Mu
                                                                    t be written when RTC is stopped                           */
  __IM  uint32_t  RESERVED6[13];
  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection: Compare register n                 */
  __IM  uint32_t  RESERVED7[683];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RTC_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TEMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Temperature Sensor (TEMP)
  */

typedef struct {                                /*!< (@ 0x4000C000) TEMP Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start temperature measurement                              */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop temperature measurement                               */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_DATARDY;               /*!< (@ 0x00000100) Temperature measurement complete, data ready               */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[127];
  __IM  int32_t   TEMP;                         /*!< (@ 0x00000508) Temperature in degC (0.25deg steps)                        */
  __IM  uint32_t  RESERVED3;
  __IM  uint32_t  DATA;                         /*!< (@ 0x00000510) Data after dec and calib                                   */
  __IOM uint32_t  CALIB;                        /*!< (@ 0x00000514) Calibration value. Reset value is taken from
                                                                    FICR-&gt;CHIPCONF01 bit 31:22                              */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  A0;                           /*!< (@ 0x00000520) Slope of 1st piece wise linear function                    */
  __IOM uint32_t  A1;                           /*!< (@ 0x00000524) Slope of 2nd piece wise linear function                    */
  __IOM uint32_t  A2;                           /*!< (@ 0x00000528) Slope of 3rd piece wise linear function                    */
  __IOM uint32_t  A3;                           /*!< (@ 0x0000052C) Slope of 4th piece wise linear function                    */
  __IOM uint32_t  A4;                           /*!< (@ 0x00000530) Slope of 5th piece wise linear function                    */
  __IOM uint32_t  A5;                           /*!< (@ 0x00000534) Slope of 6th piece wise linear function                    */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  B0;                           /*!< (@ 0x00000540) y-intercept of 1st piece wise linear function              */
  __IOM uint32_t  B1;                           /*!< (@ 0x00000544) y-intercept of 2nd piece wise linear function              */
  __IOM uint32_t  B2;                           /*!< (@ 0x00000548) y-intercept of 3rd piece wise linear function              */
  __IOM uint32_t  B3;                           /*!< (@ 0x0000054C) y-intercept of 4th piece wise linear function              */
  __IOM uint32_t  B4;                           /*!< (@ 0x00000550) y-intercept of 5th piece wise linear function              */
  __IOM uint32_t  B5;                           /*!< (@ 0x00000554) y-intercept of 6th piece wise linear function              */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  T0;                           /*!< (@ 0x00000560) End point of 1st piece wise linear function                */
  __IOM uint32_t  T1;                           /*!< (@ 0x00000564) End point of 2nd piece wise linear function                */
  __IOM uint32_t  T2;                           /*!< (@ 0x00000568) End point of 3rd piece wise linear function                */
  __IOM uint32_t  T3;                           /*!< (@ 0x0000056C) End point of 4th piece wise linear function                */
  __IOM uint32_t  T4;                           /*!< (@ 0x00000570) End point of 5th piece wise linear function                */
  __IM  uint32_t  RESERVED7[674];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TEMP_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Random Number Generator (RNG)
  */

typedef struct {                                /*!< (@ 0x4000D000) RNG Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the random number generator                  */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the random number generator                  */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_VALRDY;                /*!< (@ 0x00000100) Event being generated for every new random number
                                                                    written to the VALUE register                              */
  __IM  uint32_t  RESERVED1[63];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[126];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IM  uint32_t  VALUE;                        /*!< (@ 0x00000508) Output random number                                       */
  __IM  uint32_t  RESERVED4[700];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RNG_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            ECB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES ECB Mode Encryption (ECB)
  */

typedef struct {                                /*!< (@ 0x4000E000) ECB Structure                                              */
  __OM  uint32_t  TASKS_STARTECB;               /*!< (@ 0x00000000) Start ECB block encrypt                                    */
  __OM  uint32_t  TASKS_STOPECB;                /*!< (@ 0x00000004) Abort a possible executing ECB operation                   */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_ENDECB;                /*!< (@ 0x00000100) ECB block encrypt complete                                 */
  __IOM uint32_t  EVENTS_ERRORECB;              /*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
                                                                    task or due to an error                                    */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[126];
  __IOM uint32_t  ECBDATAPTR;                   /*!< (@ 0x00000504) ECB block encrypt memory pointers                          */
  __IM  uint32_t  RESERVED3[701];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_ECB_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            AAR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Accelerated Address Resolver (AAR)
  */

typedef struct {                                /*!< (@ 0x4000F000) AAR Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
                                                                    in the IRK data structure                                  */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop resolving addresses                                   */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000100) Address resolution procedure complete                      */
  __IOM uint32_t  EVENTS_RESOLVED;              /*!< (@ 0x00000104) Address resolved                                           */
  __IOM uint32_t  EVENTS_NOTRESOLVED;           /*!< (@ 0x00000108) Address not resolved                                       */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Resolution status                                          */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable AAR                                                 */
  __IOM uint32_t  NIRK;                         /*!< (@ 0x00000504) Number of IRKs                                             */
  __IOM uint32_t  IRKPTR;                       /*!< (@ 0x00000508) Pointer to IRK data structure                              */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  ADDRPTR;                      /*!< (@ 0x00000510) Pointer to the resolvable address                          */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IM  uint32_t  RESERVED6[697];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_AAR_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            CCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES CCM Mode Encryption (CCM)
  */

typedef struct {                                /*!< (@ 0x4000F000) CCM Structure                                              */
  __OM  uint32_t  TASKS_KSGEN;                  /*!< (@ 0x00000000) Start generation of key-stream. This operation
                                                                    will stop by itself when completed.                        */
  __OM  uint32_t  TASKS_CRYPT;                  /*!< (@ 0x00000004) Start encryption/decryption. This operation will
                                                                    stop by itself when completed.                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop encryption/decryption                                 */
  __OM  uint32_t  TASKS_RATEOVERRIDE;           /*!< (@ 0x0000000C) Override DATARATE setting in MODE register with
                                                                    the contents of the RATEOVERRIDE register
                                                                    for any ongoing encryption/decryption                      */
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_ENDKSGEN;              /*!< (@ 0x00000100) Key-stream generation complete                             */
  __IOM uint32_t  EVENTS_ENDCRYPT;              /*!< (@ 0x00000104) Encrypt/decrypt complete                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000108) Deprecated register - CCM error event                      */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  MICSTATUS;                    /*!< (@ 0x00000400) MIC check result                                           */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable                                                     */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Operation mode                                             */
  __IOM uint32_t  CNFPTR;                       /*!< (@ 0x00000508) Pointer to data structure holding AES key and
                                                                    NONCE vector                                               */
  __IOM uint32_t  INPTR;                        /*!< (@ 0x0000050C) Input pointer                                              */
  __IOM uint32_t  OUTPTR;                       /*!< (@ 0x00000510) Output pointer                                             */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IOM uint32_t  MAXPACKETSIZE;                /*!< (@ 0x00000518) Length of key-stream generated when MODE.LENGTH
                                                                    = Extended.                                                */
  __IOM uint32_t  RATEOVERRIDE;                 /*!< (@ 0x0000051C) Data rate override setting.                                */
  __IM  uint32_t  RESERVED5[695];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_CCM_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer (WDT)
  */

typedef struct {                                /*!< (@ 0x40010000) WDT Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the watchdog                                         */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop the watchdog timer. Only available in timer
                                                                    mode.                                                      */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_TIMEOUT;               /*!< (@ 0x00000100) Watchdog timeout                                           */
  __IM  uint32_t  RESERVED1[128];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[61];
  __IM  uint32_t  RUNSTATUS;                    /*!< (@ 0x00000400) Run status                                                 */
  __IM  uint32_t  REQSTATUS;                    /*!< (@ 0x00000404) Request status                                             */
  __IOM uint32_t  RCNT;                         /*!< (@ 0x00000408) Reload count                                               */
  __IM  uint32_t  RESERVED3[62];
  __IOM uint32_t  CRV;                          /*!< (@ 0x00000504) Counter reload value                                       */
  __IOM uint32_t  RREN;                         /*!< (@ 0x00000508) Enable register for reload request registers               */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000050C) Configuration register                                     */
  __IM  uint32_t  RESERVED4[60];
  __OM  uint32_t  RR[8];                        /*!< (@ 0x00000600) Description collection: Reload request n                   */
  __IM  uint32_t  RESERVED5[631];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_WDT_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           QDEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder (QDEC)
  */

typedef struct {                                /*!< (@ 0x40012000) QDEC Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the quadrature decoder                       */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
  __OM  uint32_t  TASKS_READCLRACC;             /*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
  __OM  uint32_t  TASKS_RDCLRACC;               /*!< (@ 0x0000000C) Read and clear ACC                                         */
  __OM  uint32_t  TASKS_RDCLRDBL;               /*!< (@ 0x00000010) Read and clear ACCDBL                                      */
  __IM  uint32_t  RESERVED[59];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;             /*!< (@ 0x00000104) Non-null report ready                                      */
  __IOM uint32_t  EVENTS_ACCOF;                 /*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
  __IOM uint32_t  EVENTS_DBLRDY;                /*!< (@ 0x0000010C) Double displacement(s) detected                            */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000110) QDEC has been stopped                                      */
  __IM  uint32_t  RESERVED1[59];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable the quadrature decoder                              */
  __IOM uint32_t  LEDPOL;                       /*!< (@ 0x00000504) LED output pin polarity                                    */
  __IOM uint32_t  SAMPLEPER;                    /*!< (@ 0x00000508) Sample period                                              */
  __IM  int32_t   SAMPLE;                       /*!< (@ 0x0000050C) Motion sample value                                        */
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
                                                                    and DBLRDY events can be generated                         */
  __IM  int32_t   ACC;                          /*!< (@ 0x00000514) Register accumulating the valid transitions                */
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC or RDCLRACC task                                */
  __IOM QDEC_PSEL_Type PSEL;                    /*!< (@ 0x0000051C) Unspecified                                                */
  __IOM uint32_t  DBFEN;                        /*!< (@ 0x00000528) Enable input debounce filters                              */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  LEDPRE;                       /*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    or RDCLRDBL task                                           */
  __IM  uint32_t  RESERVED5[684];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_QDEC_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           COMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Comparator (COMP)
  */

typedef struct {                                /*!< (@ 0x40013000) COMP Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) COMP is ready and output is valid                          */
  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
  __IM  uint32_t  BGREADY;                      /*!< (@ 0x00000404) COMP module is ready                                       */
  __IM  uint32_t  RESERVED4[62];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) COMP enable                                                */
  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Pin select                                                 */
  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference source select for single-ended mode              */
  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
  __IM  uint32_t  RESERVED5[8];
  __IOM uint32_t  TH;                           /*!< (@ 0x00000530) Threshold configuration for hysteresis unit                */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000534) Mode configuration                                         */
  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
  __IOM uint32_t  ISOURCE;                      /*!< (@ 0x0000053C) Current source select on analog input                      */
  __IOM uint32_t  REFTRIM;                      /*!< (@ 0x00000540) Trim internal band gap reference, copied from
                                                                    FICR (COMPREFTRIM register) at reset                       */
  __IOM uint32_t  ATECOMP;                      /*!< (@ 0x00000544) Analog test bus control for comparator                     */
  __IM  uint32_t  RESERVED6[685];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_COMP_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          LPCOMP                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power comparator (LPCOMP)
  */

typedef struct {                                /*!< (@ 0x40013000) LPCOMP Structure                                           */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) LPCOMP is ready and output is valid                        */
  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable LPCOMP                                              */
  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Input pin select                                           */
  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference select                                           */
  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
  __IM  uint32_t  RESERVED5[4];
  __IOM uint32_t  ANADETECT;                    /*!< (@ 0x00000520) Analog detect configuration                                */
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
  __IM  uint32_t  RESERVED7[688];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_LPCOMP_Type;                              /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           EGU0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit 0 (EGU0)
  */

typedef struct {                                /*!< (@ 0x40014000) EGU0 Structure                                             */
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[48];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED1[112];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
} NRF_EGU_Type;                                 /*!< Size = 780 (0x30c)                                                        */



/* =========================================================================================================================== */
/* ================                                           SWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Software interrupt 0 (SWI0)
  */

typedef struct {                                /*!< (@ 0x40014000) SWI0 Structure                                             */
  __IM  uint32_t  UNUSED;                       /*!< (@ 0x00000000) Unused.                                                    */
} NRF_SWI_Type;                                 /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           PWM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse width modulation unit 0 (PWM0)
  */

typedef struct {                                /*!< (@ 0x4001C000) PWM0 Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts PWM pulse generation with the last loaded
                                                                    values                                                     */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
                                                                    the end of current PWM period, and stops
                                                                    sequence playback                                          */
  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
                                                                    on all enabled channels from sequence n,
                                                                    and starts playing that sequence at the
                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
                                                                    Causes PWM generation to start if not running.
                                                                    Triggering a SEQSTART[n] task while a sequence
                                                                    is already playing back will gracefully
                                                                    (i.e. glitch-free) abort that sequence at
                                                                    the earliest opportunity and start sequence
                                                                    n.                                                         */
  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
                                                                    all enabled channels if DECODER.MODE=NextStep.
                                                                    Does not cause PWM generation to start if
                                                                    not running.                                               */
  __OM  uint32_t  TASKS_SEQABORT;               /*!< (@ 0x00000014) (Gracefully) aborts the playback of the current
                                                                    sequence or the current end delay                          */
  __IM  uint32_t  RESERVED[58];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) Response to START task, emitted when the PWM
                                                                    pulse generation starts                                    */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
                                                                    are no longer generated                                    */
  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
                                                                    on sequence n                                              */
  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
                                                                    sequence n, when last value from RAM has
                                                                    been applied to wave counter                               */
  __IOM uint32_t  EVENTS_PWMPERIODEND;          /*!< (@ 0x00000118) Emitted at the end of each PWM period                      */
  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
                                                                    of times defined in LOOP.CNT                               */
  __IOM uint32_t  EVENTS_RAMUNDERFLOW;          /*!< (@ 0x00000120) Emitted when retrieving from RAM does not complete
                                                                    in time for the PWM module                                 */
  __IOM uint32_t  EVENTS_DMAREADY[2];           /*!< (@ 0x00000124) Description collection: Emitted when EasyDMA
                                                                    has retrieved the .PTR and .CNT registers
                                                                    for sequence n (they can be prepared for
                                                                    the next sequence)                                         */
  __IOM uint32_t  EVENTS_DMAEND[2];             /*!< (@ 0x0000012C) Description collection: Emitted when EasyDMA
                                                                    has completed retrieving the values of sequence
                                                                    n from RAM buffer                                          */
  __IM  uint32_t  RESERVED1[51];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PWM module enable register                                 */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Selects operating mode of the wave counter                 */
  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
                                                                    counts                                                     */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x0000050C) Configuration for PWM_CLK                                  */
  __IOM uint32_t  DECODER;                      /*!< (@ 0x00000510) Configuration of the decoder                               */
  __IOM uint32_t  LOOP;                         /*!< (@ 0x00000514) Number of playbacks of a loop                              */
  __IM  uint32_t  RESERVED4[2];
  __IOM PWM_SEQ_Type SEQ[2];                    /*!< (@ 0x00000520) Unspecified                                                */
  __IOM PWM_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
} NRF_PWM_Type;                                 /*!< Size = 1392 (0x570)                                                       */



/* =========================================================================================================================== */
/* ================                                            PDM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Density Modulation (Digital Microphone) Interface (PDM)
  */

typedef struct {                                /*!< (@ 0x4001D000) PDM Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous PDM transfer                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PDM transfer                                         */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) PDM transfer has started                                   */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) PDM transfer has finished                                  */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
                                                                    by SAMPLE.MAXCNT (or the last sample after
                                                                    a STOP task has been received) to Data RAM                 */
  __IOM uint32_t  EVENTS_OVERRUN;               /*!< (@ 0x0000010C) PDM samples lost due to DMA destination not available      */
  __IM  uint32_t  RESERVED1[124];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PDM module enable register                                 */
  __IOM uint32_t  PDMCLKCTRL;                   /*!< (@ 0x00000504) PDM clock generator control                                */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
                                                                    signals                                                    */
  __IOM uint32_t  FDBYPASS;                     /*!< (@ 0x0000050C) Bypass the frequency doubler in the PDM clock
                                                                    generation                                                 */
  __IM  uint32_t  RXDLDATA;                     /*!< (@ 0x00000510) Left sample from filter output                             */
  __IM  uint32_t  RXDRDATA;                     /*!< (@ 0x00000514) Right sample from filter output                            */
  __IOM uint32_t  GAINL;                        /*!< (@ 0x00000518) Left output gain adjustment                                */
  __IOM uint32_t  GAINR;                        /*!< (@ 0x0000051C) Right output gain adjustment                               */
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
  __IM  uint32_t  RESERVED3;
  __IOM PDM_FILTER_Type FILTER;                 /*!< (@ 0x00000528) Unspecified                                                */
  __IOM uint32_t  PHASE;                        /*!< (@ 0x0000053C) Selection of delay on the clock line (to avoid
                                                                    potential setup&amp;hold timing violation
                                                                    on input data)                                             */
  __IOM PDM_PSEL_Type PSEL;                     /*!< (@ 0x00000540) Unspecified                                                */
  __IOM uint32_t  TSEL;                         /*!< (@ 0x00000548) Trim value for ramTSEL[1:0] on the RamBist interface       */
  __IM  uint32_t  RESERVED4[5];
  __IOM PDM_SAMPLE_Type SAMPLE;                 /*!< (@ 0x00000560) Unspecified                                                */
} NRF_PDM_Type;                                 /*!< Size = 1388 (0x56c)                                                       */



/* =========================================================================================================================== */
/* ================                                            ACL                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Access control lists (ACL)
  */

typedef struct {                                /*!< (@ 0x4001E000) ACL Structure                                              */
  __IM  uint32_t  RESERVED[512];
  __IOM ACL_ACL_Type ACL[8];                    /*!< (@ 0x00000800) Unspecified                                                */
} NRF_ACL_Type;                                 /*!< Size = 2176 (0x880)                                                       */



/* =========================================================================================================================== */
/* ================                                           NVMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Non Volatile Memory Controller (NVMC)
  */

typedef struct {                                /*!< (@ 0x4001E000) NVMC Structure                                             */
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;                        /*!< (@ 0x00000400) Ready flag                                                 */
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;                    /*!< (@ 0x00000408) Ready flag                                                 */
  __IM  uint32_t  RESERVED2[62];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  
  union {
    __OM  uint32_t ERASEPAGE;                   /*!< (@ 0x00000508) Register for erasing a page in code area                   */
    __OM  uint32_t ERASEPCR1;                   /*!< (@ 0x00000508) Deprecated register - Register for erasing a
                                                                    page in code area, equivalent to ERASEPAGE                 */
  };
  __OM  uint32_t  ERASEALL;                     /*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
  __OM  uint32_t  ERASEPCR0;                    /*!< (@ 0x00000510) Deprecated register - Register for erasing a
                                                                    page in code area, equivalent to ERASEPAGE                 */
  __OM  uint32_t  ERASEUICR;                    /*!< (@ 0x00000514) Register for erasing user information configuration
                                                                    registers                                                  */
  __OM  uint32_t  ERASEPAGEPARTIAL;             /*!< (@ 0x00000518) Register for partial erase of a page in code
                                                                    area                                                       */
  __IOM uint32_t  ERASEPAGEPARTIALCFG;          /*!< (@ 0x0000051C) Register for partial erase configuration                   */
  __IM  uint32_t  RESERVED3[8];
  __IOM uint32_t  ICACHECNF;                    /*!< (@ 0x00000540) I-code cache configuration register                        */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  IHIT;                         /*!< (@ 0x00000548) I-code cache hit counter                                   */
  __IOM uint32_t  IMISS;                        /*!< (@ 0x0000054C) I-code cache miss counter                                  */
  __IM  uint32_t  RESERVED5[44];
  __IOM uint32_t  TESTMODE;                     /*!< (@ 0x00000600) Register for entering test mode. Refer to the
                                                                    flash IP test documentation for more details.              */
  __IOM uint32_t  LVEN;                         /*!< (@ 0x00000604) Low voltage read mode                                      */
  __IM  uint32_t  RESERVED6[2];
  __OM  uint32_t  TESTMASSERASE;                /*!< (@ 0x00000610) Self-timed mass-erase operation                            */
  __OM  uint32_t  TESTERASEREFCELL;             /*!< (@ 0x00000614) Self-timed erase reference cell operation                  */
  __IM  uint32_t  TESTTC;                       /*!< (@ 0x00000618) Observe the TC output from the flash macro                 */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  TESTDATA128[4];               /*!< (@ 0x00000620) Description collection: Direct flash test data
                                                                    word n                                                     */
  __IM  uint32_t  TESTDATA128INC[4];            /*!< (@ 0x00000630) Description collection: Direct flash test data
                                                                    word n. Post-increments TESTCONTROLADDR                    */
  __IM  uint32_t  TESTCMPINC;                   /*!< (@ 0x00000640) Reads and compares last flash row to TESTDATA128
                                                                    content. Post-increments TESTCONTROLADDR.                  */
  __IM  uint32_t  TESTNCMPINC;                  /*!< (@ 0x00000644) Reads and compares last flash row to complement
                                                                    of TESTDATA128 content. Post-increments
                                                                    TESTCONTROLADDR.                                           */
  __IOM uint32_t  TESTCONTROLLINES;             /*!< (@ 0x00000648) Direct flash test, control lines. Refer to the
                                                                    flash IP test documentation for more details.              */
  __IOM uint32_t  TESTCONTROLADDR;              /*!< (@ 0x0000064C) Direct flash test control, address lines                   */
  __IOM uint32_t  TESTCOUNTERRELOAD;            /*!< (@ 0x00000650) Counter reload value, used when counting from
                                                                    SE or YE rising edge to latching of data                   */
  __IM  uint32_t  TESTCOUNTERRUNNING;           /*!< (@ 0x00000654) Returns the state (counting or not) of the counter         */
  __IOM uint32_t  TESTCONFIG;                   /*!< (@ 0x00000658) Mode of operation of the counter                           */
  __IOM uint32_t  TESTTMVPPANAEN;               /*!< (@ 0x0000065C) Controls analog signals for flash measurements             */
  __IM  uint32_t  RESERVED8[40];
  __IOM uint32_t  FORCEONNVM;                   /*!< (@ 0x00000700) Force on NVM supply                                        */
  __IM  uint32_t  RESERVED9[9];
  __IOM uint32_t  FORCEOFFNVM;                  /*!< (@ 0x00000728) Force off NVM supply                                       */
} NRF_NVMC_Type;                                /*!< Size = 1836 (0x72c)                                                       */



/* =========================================================================================================================== */
/* ================                                            PPI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable Peripheral Interconnect (PPI)
  */

typedef struct {                                /*!< (@ 0x4001F000) PPI Structure                                              */
  __OM  PPI_TASKS_CHG_Type TASKS_CHG[6];        /*!< (@ 0x00000000) Channel group tasks                                        */
  __IM  uint32_t  RESERVED[308];
  __IOM uint32_t  CHEN;                         /*!< (@ 0x00000500) Channel enable register                                    */
  __IOM uint32_t  CHENSET;                      /*!< (@ 0x00000504) Channel enable set register                                */
  __IOM uint32_t  CHENCLR;                      /*!< (@ 0x00000508) Channel enable clear register                              */
  __IM  uint32_t  RESERVED1;
  __IOM PPI_CH_Type CH[20];                     /*!< (@ 0x00000510) PPI Channel                                                */
  __IM  uint32_t  RESERVED2[148];
  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n                    */
  __IM  uint32_t  RESERVED3[62];
  __IOM PPI_FORK_Type FORK[32];                 /*!< (@ 0x00000910) Fork                                                       */
} NRF_PPI_Type;                                 /*!< Size = 2448 (0x990)                                                       */



/* =========================================================================================================================== */
/* ================                                            MWU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Memory Watch Unit (MWU)
  */

typedef struct {                                /*!< (@ 0x40020000) MWU Structure                                              */
  __IM  uint32_t  RESERVED[64];
  __IOM MWU_EVENTS_REGION_Type EVENTS_REGION[4];/*!< (@ 0x00000100) Peripheral events.                                         */
  __IM  uint32_t  RESERVED1[16];
  __IOM MWU_EVENTS_PREGION_Type EVENTS_PREGION[2];/*!< (@ 0x00000160) Peripheral events.                                       */
  __IM  uint32_t  RESERVED2[100];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  NMIEN;                        /*!< (@ 0x00000320) Enable or disable interrupt                                */
  __IOM uint32_t  NMIENSET;                     /*!< (@ 0x00000324) Enable interrupt                                           */
  __IOM uint32_t  NMIENCLR;                     /*!< (@ 0x00000328) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[53];
  __IOM MWU_PERREGION_Type PERREGION[2];        /*!< (@ 0x00000400) Unspecified                                                */
  __IM  uint32_t  RESERVED5[64];
  __IOM uint32_t  REGIONEN;                     /*!< (@ 0x00000510) Enable/disable regions watch                               */
  __IOM uint32_t  REGIONENSET;                  /*!< (@ 0x00000514) Enable regions watch                                       */
  __IOM uint32_t  REGIONENCLR;                  /*!< (@ 0x00000518) Disable regions watch                                      */
  __IM  uint32_t  RESERVED6[57];
  __IOM MWU_REGION_Type REGION[4];              /*!< (@ 0x00000600) Unspecified                                                */
  __IM  uint32_t  RESERVED7[32];
  __IOM MWU_PREGION_Type PREGION[2];            /*!< (@ 0x000006C0) Unspecified                                                */
} NRF_MWU_Type;                                 /*!< Size = 1760 (0x6e0)                                                       */



/* =========================================================================================================================== */
/* ================                                            I2S                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter-IC Sound (I2S)
  */

typedef struct {                                /*!< (@ 0x40025000) I2S Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
                                                                    generator when this is enabled.                            */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer. Also stops MCK generator.
                                                                    Triggering this task will cause the STOPPED
                                                                    event to be generated.                                     */
  __IM  uint32_t  RESERVED[10];
  __OM  uint32_t  TASKS_DMA_START_TX;           /*!< (@ 0x00000030) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_START_TX. */
  __OM  uint32_t  TASKS_DMA_START_RX;           /*!< (@ 0x00000034) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_START_RX. */
  __OM  uint32_t  TASKS_DMA_STOP_TX;            /*!< (@ 0x00000038) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_STOP_TX. */
  __OM  uint32_t  TASKS_DMA_STOP_RX;            /*!< (@ 0x0000003C) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_STOP_RX. */
  __IM  uint32_t  RESERVED1[48];
  __IOM uint32_t  EVENTS_DMA_END_TX;            /*!< (@ 0x00000100) Equivalent to eventDmaEndTx                                */
  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and RX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are received
                                                                    on the SDIN pin. Equivalent to eventDmaReadyRx.            */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000108) I2S transfer stopped. There are no requirements
                                                                    to how graceful the I2S module shall be
                                                                    stopped. The reason for this is that we
                                                                    are talking about streaming audio data here,
                                                                    and thus loosing some data is not critical.
                                                                    Graceful stopping of stream can easily be
                                                                    done in FW. Equivalent to eventStopped                     */
  __IOM uint32_t  EVENTS_ERROR_TX;              /*!< (@ 0x0000010C) DMA read from memory failed. Equivalent to eventUnderflowTx */
  __IOM uint32_t  EVENTS_ERROR_RX;              /*!< (@ 0x00000110) DMA write to memory failed. Equivalent to eventOverflowRx  */
  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and TX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are sent
                                                                    on the SDOUT pin. Equivalent to eventDmaReadyTx.           */
  __IOM uint32_t  EVENTS_DMA_END_RX;            /*!< (@ 0x00000118) DMA write to memory failed. Equivalent to eventDmaEndRx    */
  __IM  uint32_t  RESERVED2[121];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable I2S module.                                         */
  __IOM I2S_CONFIG_Type CONFIG;                 /*!< (@ 0x00000504) Unspecified                                                */
  __IM  uint32_t  RESERVED4[3];
  __IOM I2S_RXD_Type RXD;                       /*!< (@ 0x00000538) Unspecified                                                */
  __IM  uint32_t  RESERVED5;
  __IOM I2S_TXD_Type TXD;                       /*!< (@ 0x00000540) Unspecified                                                */
  __IM  uint32_t  RESERVED6[3];
  __IOM I2S_RXTXD_Type RXTXD;                   /*!< (@ 0x00000550) Unspecified                                                */
  __IM  uint32_t  RESERVED7[2];
  __IOM I2S_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
  __IM  uint32_t  RESERVED8[99];
  __IOM uint32_t  DMA_ENABLE_RX;                /*!< (@ 0x00000700) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_ENABLE_RX.         */
  __IOM uint32_t  DMA_ENABLE_TX;                /*!< (@ 0x00000704) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_ENABLE_TX.         */
} NRF_I2S_Type;                                 /*!< Size = 1800 (0x708)                                                       */



/* =========================================================================================================================== */
/* ================                                            FPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FPU (FPU)
  */

typedef struct {                                /*!< (@ 0x40026000) FPU Structure                                              */
  __IM  uint32_t  UNUSED;                       /*!< (@ 0x00000000) Unused.                                                    */
} NRF_FPU_Type;                                 /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           USBD                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal serial bus device (USBD)
  */

typedef struct {                                /*!< (@ 0x40027000) USBD Structure                                             */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTEPIN[8];           /*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
                                                                    and EPIN[n].MAXCNT registers values, and
                                                                    enables endpoint IN n to respond to traffic
                                                                    from host EPIN[n].CONFIG is also captured                  */
  __OM  uint32_t  TASKS_STARTISOIN;             /*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
                                                                    values, and enables sending data on ISO
                                                                    endpoint ISOIN.CONFIG is also captured                     */
  __OM  uint32_t  TASKS_STARTEPOUT[8];          /*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
                                                                    and EPOUT[n].MAXCNT registers values, and
                                                                    enables endpoint n to respond to traffic
                                                                    from host EPOUT[n].CONFIG is also captured                 */
  __OM  uint32_t  TASKS_STARTISOOUT;            /*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
                                                                    values, and enables receiving of data on
                                                                    ISO endpoint ISOOUT.CONFIG is also captured                */
  __OM  uint32_t  TASKS_EP0RCVOUT;              /*!< (@ 0x0000004C) Allows OUT data stage on control endpoint 0                */
  __OM  uint32_t  TASKS_EP0STATUS;              /*!< (@ 0x00000050) Allows status stage on control endpoint 0                  */
  __OM  uint32_t  TASKS_EP0STALL;               /*!< (@ 0x00000054) Stalls data and status stage on control endpoint
                                                                    0                                                          */
  __OM  uint32_t  TASKS_DPDMDRIVE;              /*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
                                                                    in the DPDMVALUE register                                  */
  __OM  uint32_t  TASKS_DPDMNODRIVE;            /*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
                                                                    (USB engine takes control)                                 */
  __IM  uint32_t  RESERVED1[40];
  __IOM uint32_t  EVENTS_USBRESET;              /*!< (@ 0x00000100) Signals that a USB reset condition has been detected
                                                                    on USB lines                                               */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
                                                                    or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
                                                                    have been captured on all endpoints reported
                                                                    in the EPSTATUS register EPIN[n].CONFIG
                                                                    is also confirmed captured                                 */
  __IOM uint32_t  EVENTS_ENDEPIN[8];            /*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_EP0DATADONE;           /*!< (@ 0x00000128) An acknowledged data transfer has taken place
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_ENDISOIN;              /*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_ENDEPOUT[8];           /*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_ENDISOOUT;             /*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_SOF;                   /*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
                                                                    has been detected on USB lines                             */
  __IOM uint32_t  EVENTS_USBEVENT;              /*!< (@ 0x00000158) An event or an error not covered by specific
                                                                    events has occurred. Check EVENTCAUSE register
                                                                    to find the cause.                                         */
  __IOM uint32_t  EVENTS_EP0SETUP;              /*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_EPDATA;                /*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
                                                                    indicated by the EPDATASTATUS register                     */
  __IOM uint32_t  EVENTS_ACCESSFAULT;           /*!< (@ 0x00000164) Access to an unavailable USB register has been
                                                                    attempted (software or EasyDMA). This event
                                                                    can be generated even when USBD is not enabled.            */
  __IM  uint32_t  RESERVED2[38];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[61];
  __IOM uint32_t  EVENTCAUSE;                   /*!< (@ 0x00000400) Details on what caused the USBEVENT event                  */
  __IM  uint32_t  BUSSTATE;                     /*!< (@ 0x00000404) Provides the logic state of D+ and D- lines                */
  __IM  uint32_t  RESERVED5[6];
  __IOM USBD_HALTED_Type HALTED;                /*!< (@ 0x00000420) Unspecified                                                */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EPSTATUS;                     /*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
                                                                    registers have been captured                               */
  __IOM uint32_t  EPDATASTATUS;                 /*!< (@ 0x0000046C) Provides information on which endpoint(s) an
                                                                    acknowledged data transfer has occurred
                                                                    (EPDATA event)                                             */
  __IM  uint32_t  USBADDR;                      /*!< (@ 0x00000470) Device USB address                                         */
  __IM  uint32_t  DMASTATE;                     /*!< (@ 0x00000474) Indicates activity state of the DMA                        */
  __IM  uint32_t  RESERVED7[2];
  __IM  uint32_t  BMREQUESTTYPE;                /*!< (@ 0x00000480) SETUP data, byte 0, bmRequestType                          */
  __IM  uint32_t  BREQUEST;                     /*!< (@ 0x00000484) SETUP data, byte 1, bRequest                               */
  __IM  uint32_t  WVALUEL;                      /*!< (@ 0x00000488) SETUP data, byte 2, LSB of wValue                          */
  __IM  uint32_t  WVALUEH;                      /*!< (@ 0x0000048C) SETUP data, byte 3, MSB of wValue                          */
  __IM  uint32_t  WINDEXL;                      /*!< (@ 0x00000490) SETUP data, byte 4, LSB of wIndex                          */
  __IM  uint32_t  WINDEXH;                      /*!< (@ 0x00000494) SETUP data, byte 5, MSB of wIndex                          */
  __IM  uint32_t  WLENGTHL;                     /*!< (@ 0x00000498) SETUP data, byte 6, LSB of wLength                         */
  __IM  uint32_t  WLENGTHH;                     /*!< (@ 0x0000049C) SETUP data, byte 7, MSB of wLength                         */
  __IOM USBD_SIZE_Type SIZE;                    /*!< (@ 0x000004A0) Unspecified                                                */
  __IM  uint32_t  RESERVED8[15];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable USB                                                 */
  __IOM uint32_t  USBPULLUP;                    /*!< (@ 0x00000504) Control of the USB pull-up                                 */
  __IOM uint32_t  DPDMVALUE;                    /*!< (@ 0x00000508) State D+ and D- lines will be forced into by
                                                                    the DPDMDRIVE task. The DPDMNODRIVE task
                                                                    reverts the control of the lines to MAC
                                                                    IP (no forcing).                                           */
  __IOM uint32_t  DTOGGLE;                      /*!< (@ 0x0000050C) Data toggle control and status                             */
  __IOM uint32_t  EPINEN;                       /*!< (@ 0x00000510) Endpoint IN enable                                         */
  __IOM uint32_t  EPOUTEN;                      /*!< (@ 0x00000514) Endpoint OUT enable                                        */
  __OM  uint32_t  EPSTALL;                      /*!< (@ 0x00000518) STALL endpoints                                            */
  __IOM uint32_t  ISOSPLIT;                     /*!< (@ 0x0000051C) Controls the split of ISO buffers                          */
  __IM  uint32_t  FRAMECNTR;                    /*!< (@ 0x00000520) Returns the current value of the start of frame
                                                                    counter                                                    */
  __IOM uint32_t  TESTUSBPULLUP;                /*!< (@ 0x00000524) Control of the USB pull-up value, for test purposes        */
  __IOM uint32_t  TSEL;                         /*!< (@ 0x00000528) Trim value for ramTSEL[1:0] on the RamBist interface       */
  __IOM uint32_t  LOWPOWER;                     /*!< (@ 0x0000052C) Controls USBD peripheral low power mode during
                                                                    USB suspend                                                */
  __IOM uint32_t  ISOINCONFIG;                  /*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
                                                                    to an IN token when no data is ready to
                                                                    be sent                                                    */
  __IM  uint32_t  RESERVED9[51];
  __IOM USBD_EPIN_Type EPIN[8];                 /*!< (@ 0x00000600) Unspecified                                                */
  __IOM USBD_ISOIN_Type ISOIN;                  /*!< (@ 0x000006A0) Unspecified                                                */
  __IM  uint32_t  RESERVED10[20];
  __IOM USBD_EPOUT_Type EPOUT[8];               /*!< (@ 0x00000700) Unspecified                                                */
  __IOM USBD_ISOOUT_Type ISOOUT;                /*!< (@ 0x000007A0) Unspecified                                                */
  __IM  uint32_t  RESERVED11[20];
  __IOM uint32_t  RAWADDR;                      /*!< (@ 0x00000800) Address to be used for accessing the MAC IP4000            */
  __IOM uint32_t  RAWDATA;                      /*!< (@ 0x00000804) Actual read or write access to the raw IP, using
                                                                    RAWADDR address                                            */
  __IM  uint32_t  RESERVED12[509];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_USBD_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           QSPI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief External flash interface (QSPI)
  */

typedef struct {                                /*!< (@ 0x40029000) QSPI Structure                                             */
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate QSPI interface                                    */
  __OM  uint32_t  TASKS_READSTART;              /*!< (@ 0x00000004) Start transfer from external flash memory to
                                                                    internal RAM                                               */
  __OM  uint32_t  TASKS_WRITESTART;             /*!< (@ 0x00000008) Start transfer from internal RAM to external
                                                                    flash memory                                               */
  __OM  uint32_t  TASKS_ERASESTART;             /*!< (@ 0x0000000C) Start external flash memory erase operation                */
  __OM  uint32_t  TASKS_DEACTIVATE;             /*!< (@ 0x00000010) Deactivate QSPI interface                                  */
  __IM  uint32_t  RESERVED[59];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) QSPI peripheral is ready. This event will be
                                                                    generated as a response to any QSPI task.                  */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable QSPI peripheral and acquire the pins selected
                                                                    in PSELn registers                                         */
  __IOM QSPI_READ_Type READ;                    /*!< (@ 0x00000504) Unspecified                                                */
  __IOM QSPI_WRITE_Type WRITE;                  /*!< (@ 0x00000510) Unspecified                                                */
  __IOM QSPI_ERASE_Type ERASE;                  /*!< (@ 0x0000051C) Unspecified                                                */
  __IOM QSPI_PSEL_Type PSEL;                    /*!< (@ 0x00000524) Unspecified                                                */
  __IOM uint32_t  XIPOFFSET;                    /*!< (@ 0x00000540) Address offset into the external memory for Execute
                                                                    in Place operation.                                        */
  __IOM uint32_t  IFCONFIG0;                    /*!< (@ 0x00000544) Interface configuration. SPI MEM CTRL Default
                                                                    Memory reg.                                                */
  __IOM uint32_t  FIFOTH;                       /*!< (@ 0x00000548) When writing to the IFCONFIG1 register the values
                                                                    for the FIFO thresholds are taken from this
                                                                    register. The DISABLE field can be set to
                                                                    ignore this register.                                      */
  __IM  uint32_t  RESERVED3[45];
  __IOM uint32_t  IFCONFIG1;                    /*!< (@ 0x00000600) Interface configuration. SPI MEM CTRL Control
                                                                    reg.                                                       */
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000604) Status register. SPI MEM CTRL Status reg.                  */
  __IOM uint32_t  ACCESSREQ0;                   /*!< (@ 0x00000608) Access request, word 0. SPI MEM CTRL Access Request
                                                                    reg. 0.                                                    */
  __IOM uint32_t  ACCESSREQ1;                   /*!< (@ 0x0000060C) Access request, word 1. SPI MEM CTRL Access Request
                                                                    reg. 1.                                                    */
  __IOM uint32_t  ACCESSREQ2;                   /*!< (@ 0x00000610) Access request, word 2. SPI MEM CTRL Access Request
                                                                    reg. 2.                                                    */
  __IOM uint32_t  DPMDUR;                       /*!< (@ 0x00000614) Set the duration required to enter/exit deep
                                                                    power-down mode (DPM). SPI MEM CTRL Duration
                                                                    DPM reg.                                                   */
  __IOM uint32_t  DATARW;                       /*!< (@ 0x00000618) Read data when read, write data when written.
                                                                    SPI MEM CTRL Read/Write Data reg.                          */
  __IM  uint32_t  FIFOSTAT;                     /*!< (@ 0x0000061C) The number of items in Read and Write FIFOs.
                                                                    SPI MEM CTRL FIFOs Status reg.                             */
  __IOM uint32_t  DEFMEM;                       /*!< (@ 0x00000620) Default memory register. SPI MEM Default memory
                                                                    register. Fields and content equivalent
                                                                    to IFCONFIG0.                                              */
  __IOM uint32_t  ADDRCONF;                     /*!< (@ 0x00000624) Extended address configuration. SPI MEM CTRL
                                                                    Extended Addressing Mode reg.                              */
  __IOM uint32_t  MEMSPEC;                      /*!< (@ 0x00000628) Byte specification: 1 byte manufacture ID, 1
                                                                    byte memory type, 1 byte density. SPI MEM
                                                                    CTRL Memory Specification reg.                             */
  __IOM uint32_t  IRQMSK;                       /*!< (@ 0x0000062C) Interrupts enable disable mask. SPI MEM CTRL
                                                                    Interrupt Mask reg.                                        */
  __IOM uint32_t  IRQREQ;                       /*!< (@ 0x00000630) Interrupt request register (reason for triggering
                                                                    interrupt signal). SPI MEM CTRL Interrupt
                                                                    Request reg.                                               */
  __IOM uint32_t  CINSTRCONF;                   /*!< (@ 0x00000634) Custom instruction configuration register. SPI
                                                                    MEM CTRL Custom Instruction Setup reg.                     */
  __IOM uint32_t  CINSTRDAT0;                   /*!< (@ 0x00000638) Custom instruction data register 0. SPI MEM CTRL
                                                                    Custom Instruction Data reg. 0.                            */
  __IOM uint32_t  CINSTRDAT1;                   /*!< (@ 0x0000063C) Custom instruction data register 1. SPI MEM CTRL
                                                                    Custom Instruction Data reg. 1.                            */
  __IOM uint32_t  IFTIMING;                     /*!< (@ 0x00000640) SPI interface timing. SPI MEM CTRL Read Dummy
                                                                    Cycles reg.                                                */
} NRF_QSPI_Type;                                /*!< Size = 1604 (0x644)                                                       */



/* =========================================================================================================================== */
/* ================                                          CC_AES                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AES engine (CC_AES)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_AES Structure                                           */
  __IM  uint32_t  RESERVED[1280];
  __OM  uint32_t  AES_KEY_0_0;                  /*!< (@ 0x00001400) Bits 31:0 of AES_KEY_0 key in non-tunneling operations,
                                                                    and as the first tunnel stage key in tunneling
                                                                    operations.                                                */
  __OM  uint32_t  AES_KEY_0_1;                  /*!< (@ 0x00001404) Bits 63:32 of AES_KEY_0 key in non-tunneling
                                                                    operations, and as the first tunnel stage
                                                                    key in tunneling operations.                               */
  __OM  uint32_t  AES_KEY_0_2;                  /*!< (@ 0x00001408) Bits 95:64 of AES_KEY_0 key in non-tunneling
                                                                    operations, and as the first tunnel stage
                                                                    key in tunneling operations.                               */
  __OM  uint32_t  AES_KEY_0_3;                  /*!< (@ 0x0000140C) Bits 127:96 of AES_KEY_0 key in non-tunneling
                                                                    operations, and as the first tunnel stage
                                                                    key in tunneling operations.                               */
  __IM  uint32_t  RESERVED1[12];
  __IOM uint32_t  AES_IV_0_0;                   /*!< (@ 0x00001440) Bits 31:0 of AES_IV_0 Initialization Value (IV)
                                                                    register in non-tunneling operations, and
                                                                    as the first tunnel stage IV register in
                                                                    tunneling operations.                                      */
  __IOM uint32_t  AES_IV_0_1;                   /*!< (@ 0x00001444) Bits 63:32 of AES_IV_0 Initialization Value (IV)
                                                                    register in non-tunneling operations, and
                                                                    as the first tunnel stage IV register in
                                                                    tunneling operations.                                      */
  __IOM uint32_t  AES_IV_0_2;                   /*!< (@ 0x00001448) Bits 95:64 of AES_IV_0 Initialization Value (IV)
                                                                    register in non-tunneling operations, and
                                                                    as the first tunnel stage IV register in
                                                                    tunneling operations.                                      */
  __IOM uint32_t  AES_IV_0_3;                   /*!< (@ 0x0000144C) Bits 127:96 of AES_IV_0 Initialization Value
                                                                    (IV) register in non-tunneling operations,
                                                                    and as the first tunnel stage IV register
                                                                    in tunneling operations.                                   */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  AES_CTR_0_0;                  /*!< (@ 0x00001460) Bits 31:0 of AES_CTR_0 AES counter (CTR) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage CTR register in tunneling
                                                                    operations.                                                */
  __IOM uint32_t  AES_CTR_0_1;                  /*!< (@ 0x00001464) Bits 63:32 of AES_CTR_0 AES counter (CTR) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage CTR register in tunneling
                                                                    operations.                                                */
  __IOM uint32_t  AES_CTR_0_2;                  /*!< (@ 0x00001468) Bits 95:64 of AES_CTR_0 AES counter (CTR) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage CTR register in tunneling
                                                                    operations.                                                */
  __IOM uint32_t  AES_CTR_0_3;                  /*!< (@ 0x0000146C) Bits 127:96 of AES_CTR_0 AES counter (CTR) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage CTR register in tunneling
                                                                    operations.                                                */
  __IM  uint32_t  AES_BUSY;                     /*!< (@ 0x00001470) This register is set when the AES core is active           */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  AES_SK;                       /*!< (@ 0x00001478) Writing to this address trigger sampling of the
                                                                    HW key to the AES_KEY_0 register                           */
  __OM  uint32_t  AES_CMAC_INIT;                /*!< (@ 0x0000147C) Writing to this address triggers the AES engine
                                                                    generating of K1 and K2 for AES-CMAC operations.           */
  __IM  uint32_t  RESERVED4[15];
  __IOM uint32_t  AES_REMAINING_BYTES;          /*!< (@ 0x000014BC) This register should be set with the amount of
                                                                    remaining bytes until the end of the current
                                                                    AES operation.                                             */
  __IOM uint32_t  AES_CONTROL;                  /*!< (@ 0x000014C0) This register holds the configuration of the
                                                                    AES engine                                                 */
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  AES_HW_FLAGS;                 /*!< (@ 0x000014C8) This register holds the pre-synthesis HW flag
                                                                    configuration of the AES engine                            */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  AES_RBG_SEED;                 /*!< (@ 0x000014D0) The random 8 bits from the TRNG should be written
                                                                    to this address. It operates as the seed
                                                                    to the AES RBG's operation.                                */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  AES_CTR_NO_INCREMENT;         /*!< (@ 0x000014D8) This register enables the AES CTR 'no increment'
                                                                    mode, in which the counter mode is not incremented
                                                                    between 2 blocks.                                          */
  __IM  uint32_t  RESERVED8[5];
  __IOM uint32_t  AES_DFA_IS_ON;                /*!< (@ 0x000014F0) Turn the Differential Fault Analysis (DFA) counter-measures
                                                                    on.                                                        */
  __OM  uint32_t  AES_SW_RESET;                 /*!< (@ 0x000014F4) Request reset of AES engine from software.                 */
  __IM  uint32_t  AES_DFA_ERROR_STATUS;         /*!< (@ 0x000014F8) After a DFA violation has occured this register
                                                                    is set and the AES block is disabled until
                                                                    the next reset.                                            */
  __IM  uint32_t  AES_RBG_SEEDING_RDY;          /*!< (@ 0x000014FC) The AES RBG seeding should be performed only
                                                                    if this register is set to 1.                              */
  __IM  uint32_t  RESERVED9[9];
  __OM  uint32_t  AES_CMAC_SIZE0_KICK;          /*!< (@ 0x00001524) Writing to this address triggers the AES engine
                                                                    to perform a CMAC operation with size 0.
                                                                    The CMAC result can be read from the AES_IV_0
                                                                    register.                                                  */
  __IM  uint32_t  RESERVED10[7];
  __IOM uint32_t  AES_DUMMY_ROUNDS_ENABLE;      /*!< (@ 0x00001544) This fields determines whether the DUMMY ROUNDS
                                                                    countermeasures mechanism is supported                     */
} NRF_CC_AES_Type;                              /*!< Size = 5448 (0x1548)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_AHB                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AHB interface (CC_AHB)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_AHB Structure                                           */
  __IM  uint32_t  RESERVED[1728];
  __IOM uint32_t  AHBM_SINGLES;                 /*!< (@ 0x00001B00) This register forces the AHB master transactions
                                                                    to always be singles.                                      */
  __IOM uint32_t  AHBM_HPROT;                   /*!< (@ 0x00001B04) This register holds the AHB prot value                     */
  __IOM uint32_t  AHBM_HMASTLOCK;               /*!< (@ 0x00001B08) This register holds AHB hmastlock value                    */
} NRF_CC_AHB_Type;                              /*!< Size = 6924 (0x1b0c)                                                      */



/* =========================================================================================================================== */
/* ================                                         CC_CHACHA                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CHACHA engine (CC_CHACHA)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_CHACHA Structure                                        */
  __IM  uint32_t  RESERVED[1248];
  __IOM uint32_t  CHACHA_CONTROL_REG;           /*!< (@ 0x00001380) CHACHA/SALSA general configuration.                        */
  __IM  uint32_t  CHACHA_VERSION;               /*!< (@ 0x00001384) CHACHA/SALSA Version                                       */
  __OM  uint32_t  CHACHA_KEY0;                  /*!< (@ 0x00001388) Bits 31:0 of the CHACHA_KEY                                */
  __OM  uint32_t  CHACHA_KEY1;                  /*!< (@ 0x0000138C) Bits 63:32 of the CHACHA_KEY                               */
  __OM  uint32_t  CHACHA_KEY2;                  /*!< (@ 0x00001390) Bits 95:64 of the CHACHA_KEY                               */
  __OM  uint32_t  CHACHA_KEY3;                  /*!< (@ 0x00001394) Bits 127:96 of the CHACHA_KEY                              */
  __OM  uint32_t  CHACHA_KEY4;                  /*!< (@ 0x00001398) Bits 159:128 of the CHACHA_KEY                             */
  __OM  uint32_t  CHACHA_KEY5;                  /*!< (@ 0x0000139C) Bits 191:160 of the CHACHA_KEY                             */
  __OM  uint32_t  CHACHA_KEY6;                  /*!< (@ 0x000013A0) Bits 223:192 of the CHACHA_KEY                             */
  __OM  uint32_t  CHACHA_KEY7;                  /*!< (@ 0x000013A4) Bits 255:224 of the CHACHA_KEY                             */
  __IOM uint32_t  CHACHA_IV_0;                  /*!< (@ 0x000013A8) ChaCha Initialization Value (IV) register                  */
  __IOM uint32_t  CHACHA_IV_1;                  /*!< (@ 0x000013AC) ChaCha Initialization Value (IV) register                  */
  __IM  uint32_t  CHACHA_BUSY;                  /*!< (@ 0x000013B0) This register is set when the CHACHA/SALSA core
                                                                    is active                                                  */
  __IM  uint32_t  CHACHA_HW_FLAGS;              /*!< (@ 0x000013B4) Synthesis HW flag configuration of the core engine         */
  __IOM uint32_t  CHACHA_BLOCK_CNT_LSB;         /*!< (@ 0x000013B8) Store the LSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __IOM uint32_t  CHACHA_BLOCK_CNT_MSB;         /*!< (@ 0x000013BC) Store the MSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __OM  uint32_t  CHACHA_SW_RESET;              /*!< (@ 0x000013C0) Resets CHACHA/SALSA engine.                                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY0;         /*!< (@ 0x000013C4) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY1;         /*!< (@ 0x000013C8) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY2;         /*!< (@ 0x000013CC) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY3;         /*!< (@ 0x000013D0) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY4;         /*!< (@ 0x000013D4) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY5;         /*!< (@ 0x000013D8) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY6;         /*!< (@ 0x000013DC) Auto-generated key for use in Poly1305 MAC.                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY7;         /*!< (@ 0x000013E0) Auto-generated key for use in Poly1305 MAC.                */
  __IOM uint32_t  CHACHA_BYTE_WORD_ORDER_CNTL_REG;/*!< (@ 0x000013E4) CHACHA/SALSA DATA ORDER configuration.                   */
  __IM  uint32_t  CHACHA_DEBUG_REG;             /*!< (@ 0x000013E8) Debug register for Chacha                                  */
} NRF_CC_CHACHA_Type;                           /*!< Size = 5100 (0x13ec)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_CTL                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CTL interface (CC_CTL)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_CTL Structure                                           */
  __IM  uint32_t  RESERVED[1600];
  __OM  uint32_t  CRYPTO_CTL;                   /*!< (@ 0x00001900) Defines the cryptographic flow                             */
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CRYPTO_BUSY;                  /*!< (@ 0x00001910) This register is set when the cryptographic core
                                                                    is busy.                                                   */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  HASH_BUSY;                    /*!< (@ 0x0000191C) This register is set when the Hash engine is
                                                                    busy                                                       */
  __IM  uint32_t  RESERVED3[2];
  __IM  uint32_t  VERSION;                      /*!< (@ 0x00001928) This register holds the current HW version                 */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  CONTEXT_ID;                   /*!< (@ 0x00001930) A general-purpose read/write register used by
                                                                    firmware for controlling cryptographic context             */
  __IM  uint32_t  RESERVED5[3];
  __IM  uint32_t  HASH_COMPARE_ERR_ID_FIFO0;    /*!< (@ 0x00001940) This register holds the flow ID of the descriptor
                                                                    that caused that last error                                */
  __IM  uint32_t  HASH_COMPARE_ERR_ID_FIFO1;    /*!< (@ 0x00001944) This register holds the flow ID of the descriptor
                                                                    that caused the one-before-last error                      */
  __IM  uint32_t  HASH_COMPARE_ERR_ID_FIFO2;    /*!< (@ 0x00001948) This register holds the flow ID of the descriptor
                                                                    that caused the two-before-last error                      */
  __IM  uint32_t  HASH_COMPARE_ERR_ID_FIFO3;    /*!< (@ 0x0000194C) This register holds the flow ID of the descriptor
                                                                    that caused the three-before-last error                    */
} NRF_CC_CTL_Type;                              /*!< Size = 6480 (0x1950)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_DIN                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data IN interface (CC_DIN)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_DIN Structure                                           */
  __IM  uint32_t  RESERVED[1792];
  __OM  uint32_t  DIN_BUFFER;                   /*!< (@ 0x00001C00) Can be used by the CPU to write data directly
                                                                    to the DIN buffer to be sent to engines                    */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DIN_MEM_DMA_BUSY;             /*!< (@ 0x00001C20) Indicates whether memory source DMA (DIN) is
                                                                    busy                                                       */
  __IOM uint32_t  SRC_LLI_SRAM_ADDR;            /*!< (@ 0x00001C24) Location of LLI table located in the SRAM. In
                                                                    SINGLE/MULTI_LLI mode writing to this register
                                                                    triggers the DMA                                           */
  __OM  uint32_t  SRC_LLI_WORD0;                /*!< (@ 0x00001C28) This register is used in direct LLI mode and
                                                                    holds the location of the data source in
                                                                    the memory.                                                */
  __OM  uint32_t  SRC_LLI_WORD1;                /*!< (@ 0x00001C2C) This register is used in direct LLI mode and
                                                                    holds the number of bytes to be read from
                                                                    the memory. Writing to this register triggers
                                                                    the DMA.                                                   */
  __IOM uint32_t  SRAM_SRC_ADDR;                /*!< (@ 0x00001C30) Location of start address for data to be read
                                                                    from SRAM.                                                 */
  __OM  uint32_t  DIN_SRAM_BYTES_LEN;           /*!< (@ 0x00001C34) This register holds the size of the data in bytes
                                                                    to be read from the SRAM.                                  */
  __IM  uint32_t  DIN_SRAM_DMA_BUSY;            /*!< (@ 0x00001C38) This register holds the status of the SRAM DMA
                                                                    DIN                                                        */
  __IOM uint32_t  DIN_SRAM_ENDIANNESS;          /*!< (@ 0x00001C3C) This register defines the endianness of the DIN
                                                                    interface to SRAM.                                         */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  DIN_SW_RESET;                 /*!< (@ 0x00001C44) Perform a DIN reset from software.                         */
  __OM  uint32_t  DIN_CPU_DATA_SIZE;            /*!< (@ 0x00001C48) Data path to DIN is OTF                                    */
  __OM  uint32_t  WRITE_ALIGN_LAST;             /*!< (@ 0x00001C4C) Indication that the next write from the CPU is
                                                                    the last one. This is needed only when the
                                                                    data size is NOT modulo 4 (e.g. HASH padding).             */
  __IM  uint32_t  DIN_FIFO_EMPTY;               /*!< (@ 0x00001C50) DIN FIFO empty indication                                  */
  __IOM uint32_t  DISABLE_OUTSTD_REQ;           /*!< (@ 0x00001C54) Disable outstanding DIN request                            */
  __OM  uint32_t  DIN_FIFO_RST_PNTR;            /*!< (@ 0x00001C58) Write to this register to reset the DIN_FIFO
                                                                    pointers.                                                  */
} NRF_CC_DIN_Type;                              /*!< Size = 7260 (0x1c5c)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_DOUT                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data OUT interface (CC_DOUT)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_DOUT Structure                                          */
  __IM  uint32_t  RESERVED[1792];
  __IM  uint32_t  DOUT_BUFFER;                  /*!< (@ 0x00001C00) Cryptographic results directly accessible by
                                                                    the CPU.                                                   */
  __IM  uint32_t  RESERVED1[71];
  __IM  uint32_t  DOUT_MEM_DMA_BUSY;            /*!< (@ 0x00001D20) Indicates whether memory destination DMA (DOUT)
                                                                    is busy                                                    */
  __IOM uint32_t  DST_LLI_SRAM_ADDR;            /*!< (@ 0x00001D24) Destination LLI table address in SRAM.                     */
  __OM  uint32_t  DST_LLI_WORD0;                /*!< (@ 0x00001D28) This register is used in direct LLI mode and
                                                                    holds the location of the data destination
                                                                    in the memory.                                             */
  __OM  uint32_t  DST_LLI_WORD1;                /*!< (@ 0x00001D2C) This register is used in direct LLI mode and
                                                                    holds the number of bytes to be written
                                                                    to the memory.                                             */
  __IOM uint32_t  SRAM_DEST_ADDR;               /*!< (@ 0x00001D30) Location of result to be sent to in SRAM.                  */
  __OM  uint32_t  DOUT_SRAM_BYTES_LEN;          /*!< (@ 0x00001D34) This register holds the size of the data (in
                                                                    bytes) to be written to the SRAM.                          */
  __IM  uint32_t  DOUT_SRAM_DMA_BUSY;           /*!< (@ 0x00001D38) This register holds the status of the SRAM DMA
                                                                    DOUT.                                                      */
  __IOM uint32_t  DOUT_SRAM_ENDIANNESS;         /*!< (@ 0x00001D3C) This register defines the endianness of the DOUT
                                                                    interface from SRAM.                                       */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  READ_ALIGN_LAST;              /*!< (@ 0x00001D44) Indication that the next read from the CPU is
                                                                    the last one. This is needed only when the
                                                                    data size is NOT modulo 4, e.g. for HASH
                                                                    padding.                                                   */
  __IM  uint32_t  RESERVED3[2];
  __IM  uint32_t  DOUT_FIFO_EMPTY;              /*!< (@ 0x00001D50) DOUT FIFO empty indication                                 */
  __IM  uint32_t  RESERVED4;
  __OM  uint32_t  DOUT_SW_RESET;                /*!< (@ 0x00001D58) Perform a DOUT reset from software.                        */
} NRF_CC_DOUT_Type;                             /*!< Size = 7516 (0x1d5c)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_HASH                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HASH engine (CC_HASH)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_HASH Structure                                          */
  __IM  uint32_t  RESERVED[1424];
  __IOM uint32_t  HASH_H0;                      /*!< (@ 0x00001640) H0 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256                     */
  __OM  uint32_t  HASH_H1;                      /*!< (@ 0x00001644) H1 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256                     */
  __IM  uint32_t  HASH_H2;                      /*!< (@ 0x00001648) H2 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256                     */
  __IOM uint32_t  HASH_H3;                      /*!< (@ 0x0000164C) H3 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256                     */
  __IOM uint32_t  HASH_H4;                      /*!< (@ 0x00001650) H4 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256                     */
  __IOM uint32_t  HASH_H5;                      /*!< (@ 0x00001654) H5 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256                          */
  __IOM uint32_t  HASH_H6;                      /*!< (@ 0x00001658) H6 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256                          */
  __IOM uint32_t  HASH_H7;                      /*!< (@ 0x0000165C) H7 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256                          */
  __IM  uint32_t  RESERVED1[9];
  __OM  uint32_t  AUTO_HW_PADDING;              /*!< (@ 0x00001684) HW padding automatically activated by engine.              */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  LOAD_INIT_STATE;              /*!< (@ 0x00001694) Indication to HASH that the following data is
                                                                    to be loaded into initial value registers
                                                                    in HASH(H0:H15) or IV to AES MAC                           */
  __IM  uint32_t  RESERVED3[70];
  __IM  uint32_t  HASH_VERSION;                 /*!< (@ 0x000017B0) HASH VERSION Register                                      */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  HASH_CONTROL;                 /*!< (@ 0x000017C0) HASH_CONTROL register for selecting HASH mode
                                                                    to run                                                     */
  __IOM uint32_t  HASH_PAD_EN;                  /*!< (@ 0x000017C4) Enable automatic padding by HW pad block                   */
  __IOM uint32_t  HASH_PAD_CFG;                 /*!< (@ 0x000017C8) HASH_PAD_CFG Register.                                     */
  __IOM uint32_t  HASH_CUR_LEN_0;               /*!< (@ 0x000017CC) Bits 31:0 of current hash length                           */
  __IOM uint32_t  HASH_CUR_LEN_1;               /*!< (@ 0x000017D0) Bits 63:32 of current hash length                          */
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  HASH_PARAM;                   /*!< (@ 0x000017DC) HASH parameters enabled in the design                      */
  __IM  uint32_t  RESERVED6;
  __OM  uint32_t  HASH_AES_SW_RESET;            /*!< (@ 0x000017E4) Register for resetting HASH engine from software
                                                                    during AES operations                                      */
  __IOM uint32_t  HASH_ENDIANESS;               /*!< (@ 0x000017E8) The default value is little-endian. The data
                                                                    and generation of padding can be swapped
                                                                    to be big-endian.                                          */
} NRF_CC_HASH_Type;                             /*!< Size = 6124 (0x17ec)                                                      */



/* =========================================================================================================================== */
/* ================                                        CC_HOST_RGF                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HOST_RGF interface (CC_HOST_RGF)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_HOST_RGF Structure                                      */
  __IM  uint32_t  RESERVED[1664];
  __IM  uint32_t  HOST_RGF_IRR;                 /*!< (@ 0x00001A00) Interrupt request register. Each bit of this
                                                                    register holds the interrupt status of a
                                                                    single interrupt source. If corresponding
                                                                    HOST_RGF_IMR bit is unmasked, an interrupt
                                                                    is generated.                                              */
  __IOM uint32_t  HOST_RGF_IMR;                 /*!< (@ 0x00001A04) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __OM  uint32_t  HOST_RGF_ICR;                 /*!< (@ 0x00001A08) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in HOST_RGF_IRR.                         */
  __IOM uint32_t  HOST_RGF_ENDIAN;              /*!< (@ 0x00001A0C) This register defines the endianness of the Host-accessible
                                                                    registers, and can only be written once.                   */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  HOST_RGF_CC_SW_RST;           /*!< (@ 0x00001A20) Writing to this register generates a general
                                                                    reset to CRYPTOCELL. This reset takes about
                                                                    4 core clock cycles.                                       */
  __IM  uint32_t  HOST_RGF_SIGNATURE;           /*!< (@ 0x00001A24) This register holds the CRYPTOCELL product signature.      */
  __IM  uint32_t  HOST_BOOT;                    /*!< (@ 0x00001A28) This register holds the values of the CRYPTOCELL
                                                                    pre-synthesis flags.                                       */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  HOST_CRYPTOKEY_SEL;           /*!< (@ 0x00001A38) AES hardware key select                                    */
  __IM  uint32_t  RESERVED3[2];
  __IM  uint32_t  HOST_HOST_CRY_ACCESS_EN;      /*!< (@ 0x00001A44) This register defines whether the Host has access
                                                                    to the cry_kernel registers directly (compatibility
                                                                    mode) and not only through the descriptors.
                                                                    The default value is 0 - no access.                        */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  HOST_IOT_KPRTL_LOCK;          /*!< (@ 0x00001A4C) This write-once register is the K_PRTL lock register.
                                                                    When this register is set, K_PRTL can not
                                                                    be used and a zeroed key will be used instead.
                                                                    The value of this register is saved in the
                                                                    CRYPTOCELL AO power domain.                                */
  __IOM uint32_t  HOST_IOT_KDR0;                /*!< (@ 0x00001A50) This register holds bits 31:0 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain. Reading from this address
                                                                    returns the K_DR valid status indicating
                                                                    if K_DR is successfully retained.                          */
  __OM  uint32_t  HOST_IOT_KDR1;                /*!< (@ 0x00001A54) This register holds bits 63:32 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR2;                /*!< (@ 0x00001A58) This register holds bits 95:64 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR3;                /*!< (@ 0x00001A5C) This register holds bits 127:96 of K_DR. The
                                                                    value of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __IOM uint32_t  HOST_IOT_LCS;                 /*!< (@ 0x00001A60) Controls lifecycle state (LCS) for CRYPTOCELL
                                                                    subsystem                                                  */
} NRF_CC_HOST_RGF_Type;                         /*!< Size = 6756 (0x1a64)                                                      */



/* =========================================================================================================================== */
/* ================                                       CC_HOST_SRAM                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HOST_SRAM interface (CC_HOST_SRAM)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_HOST_SRAM Structure                                     */
  __IM  uint32_t  RESERVED[1984];
  __IOM uint32_t  SRAM_DATA;                    /*!< (@ 0x00001F00) Read/Write data from SRAM                                  */
  __OM  uint32_t  SRAM_ADDR;                    /*!< (@ 0x00001F04) First address given to SRAM DMA for read/write
                                                                    transactions from/to SRAM                                  */
  __IM  uint32_t  SRAM_DATA_READY;              /*!< (@ 0x00001F08) SRAM status register                                       */
} NRF_CC_HOST_SRAM_Type;                        /*!< Size = 7948 (0x1f0c)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_MISC                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL MISC interface (CC_MISC)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_MISC Structure                                          */
  __IM  uint32_t  RESERVED[1540];
  __OM  uint32_t  AES_CLK_ENABLE;               /*!< (@ 0x00001810) The AES clock enable register.                             */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  HASH_CLK_ENABLE;              /*!< (@ 0x00001818) The HASH clock enable register.                            */
  __OM  uint32_t  PKA_CLK_ENABLE;               /*!< (@ 0x0000181C) The PKA clock enable register.                             */
  __OM  uint32_t  DMA_CLK_ENABLE;               /*!< (@ 0x00001820) DMA_CLK enable register.                                   */
  __IM  uint32_t  CLK_STATUS;                   /*!< (@ 0x00001824) ARM TrustZone CryptoCell clocks status register.           */
  __IM  uint32_t  RESERVED2[12];
  __OM  uint32_t  CHACHA_CLK_ENABLE;            /*!< (@ 0x00001858) CHACHA/SALSA clock enable register.                        */
} NRF_CC_MISC_Type;                             /*!< Size = 6236 (0x185c)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_PKA                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL PKA engine (CC_PKA)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_PKA Structure                                           */
  __IM  uint32_t  RESERVED[1024];
  __IOM uint32_t  MEMORY_MAP0;                  /*!< (@ 0x00001000) This register maps the virtual register R0 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP1;                  /*!< (@ 0x00001004) This register maps the virtual register R1 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP2;                  /*!< (@ 0x00001008) This register maps the virtual register R2 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP3;                  /*!< (@ 0x0000100C) This register maps the virtual register R3 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP4;                  /*!< (@ 0x00001010) This register maps the virtual register R4 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP5;                  /*!< (@ 0x00001014) This register maps the virtual register R5 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP6;                  /*!< (@ 0x00001018) This register maps the virtual register R6 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP7;                  /*!< (@ 0x0000101C) This register maps the virtual register R7 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP8;                  /*!< (@ 0x00001020) This register maps the virtual register R8 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP9;                  /*!< (@ 0x00001024) This register maps the virtual register R9 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP10;                 /*!< (@ 0x00001028) This register maps the virtual register R10 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP11;                 /*!< (@ 0x0000102C) This register maps the virtual register R11 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP12;                 /*!< (@ 0x00001030) This register maps the virtual register R12 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP13;                 /*!< (@ 0x00001034) This register maps the virtual register R13 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP14;                 /*!< (@ 0x00001038) This register maps the virtual register R14 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP15;                 /*!< (@ 0x0000103C) This register maps the virtual register R15 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP16;                 /*!< (@ 0x00001040) This register maps the virtual register R16 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP17;                 /*!< (@ 0x00001044) This register maps the virtual register R17 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP18;                 /*!< (@ 0x00001048) This register maps the virtual register R18 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP19;                 /*!< (@ 0x0000104C) This register maps the virtual register R19 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP20;                 /*!< (@ 0x00001050) This register maps the virtual register R20 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP21;                 /*!< (@ 0x00001054) This register maps the virtual register R21 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP22;                 /*!< (@ 0x00001058) This register maps the virtual register R22 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP23;                 /*!< (@ 0x0000105C) This register maps the virtual register R23 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP24;                 /*!< (@ 0x00001060) This register maps the virtual register R24 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP25;                 /*!< (@ 0x00001064) This register maps the virtual register R25 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP26;                 /*!< (@ 0x00001068) This register maps the virtual register R26 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP27;                 /*!< (@ 0x0000106C) This register maps the virtual register R27 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP28;                 /*!< (@ 0x00001070) This register maps the virtual register R28 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP29;                 /*!< (@ 0x00001074) This register maps the virtual register R29 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP30;                 /*!< (@ 0x00001078) This register maps the virtual register R30 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP31;                 /*!< (@ 0x0000107C) This register maps the virtual register R31 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  OPCODE;                       /*!< (@ 0x00001080) This register holds the PKA's OPCODE.                      */
  __IOM uint32_t  N_NP_T0_T1_ADDR;              /*!< (@ 0x00001084) This register maps N_NP_T0_T1 to a virtual address.        */
  __IM  uint32_t  PKA_STATUS;                   /*!< (@ 0x00001088) This register holds the PKA pipe status.                   */
  __OM  uint32_t  PKA_SW_RESET;                 /*!< (@ 0x0000108C) Writing to this register triggers a software
                                                                    reset of the PKA.                                          */
  __IOM uint32_t  PKA_L0;                       /*!< (@ 0x00001090) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L1;                       /*!< (@ 0x00001094) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L2;                       /*!< (@ 0x00001098) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L3;                       /*!< (@ 0x0000109C) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L4;                       /*!< (@ 0x000010A0) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L5;                       /*!< (@ 0x000010A4) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L6;                       /*!< (@ 0x000010A8) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L7;                       /*!< (@ 0x000010AC) This register holds the size of the operation.             */
  __IM  uint32_t  PKA_PIPE_RDY;                 /*!< (@ 0x000010B0) This register indicates whether the PKA pipe
                                                                    is ready to receive a new OPCODE.                          */
  __IM  uint32_t  PKA_DONE;                     /*!< (@ 0x000010B4) This register indicates whether PKA operation
                                                                    is completed.                                              */
  __IOM uint32_t  PKA_MON_SELECT;               /*!< (@ 0x000010B8) This register defines which PKA FSM monitor is
                                                                    being output.                                              */
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  PKA_SEP_MONITOR;              /*!< (@ 0x000010C0) This register holds the sep monitor register.              */
  __IM  uint32_t  PKA_VERSION;                  /*!< (@ 0x000010C4) This register holds the PKA version                        */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  PKA_MSB_ADDR;                 /*!< (@ 0x000010CC) This register holds the PKA SRAM address offset.           */
  __IM  uint32_t  PKA_MON_READ;                 /*!< (@ 0x000010D0) PKA monitor bus register output                            */
  __OM  uint32_t  PKA_SRAM_ADDR;                /*!< (@ 0x000010D4) First address given to PKA SRAM for write transactions.    */
  __OM  uint32_t  PKA_SRAM_WDATA;               /*!< (@ 0x000010D8) Write data to PKA SRAM                                     */
  __IM  uint32_t  PKA_SRAM_RDATA;               /*!< (@ 0x000010DC) Read data from PKA SRAM                                    */
  __OM  uint32_t  PKA_SRAM_WR_CLR;              /*!< (@ 0x000010E0) Register for clearing SRAM write buffer                    */
  __OM  uint32_t  PKA_SRAM_RADDR;               /*!< (@ 0x000010E4) first address given to PKA SRAM for read transactions.     */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  PKA_CM_ENABLE;                /*!< (@ 0x000010EC) This register enables/disables the PKA multiplier
                                                                    countermeasure.                                            */
  __IOM uint32_t  PKA_WORD_ACCESS;              /*!< (@ 0x000010F0) This register hold to data write or read from
                                                                    PKA when using special read or write word
                                                                    operation.                                                 */
  __IOM uint32_t  PKA_SEED_WRITE;               /*!< (@ 0x000010F4) This register gives the HOST interface for loading
                                                                    the PKA RBG seed data.                                     */
  __OM  uint32_t  PKA_BUFF_ADDR;                /*!< (@ 0x000010F8) This register maps the virtual buffer registers
                                                                    to a physical address in memory.                           */
} NRF_CC_PKA_Type;                              /*!< Size = 4348 (0x10fc)                                                      */



/* =========================================================================================================================== */
/* ================                                          CC_RNG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG engine (CC_RNG)
  */

typedef struct {                                /*!< (@ 0x5002A000) CC_RNG Structure                                           */
  __IM  uint32_t  RESERVED[1088];
  __IOM uint32_t  RNG_IMR;                      /*!< (@ 0x00001100) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __IM  uint32_t  RNG_ISR;                      /*!< (@ 0x00001104) Interrupt status register. Each bit of this register
                                                                    holds the interrupt status of a single interrupt
                                                                    source. If corresponding RNG_IMR bit is
                                                                    unmasked, an interrupt is generated.                       */
  __OM  uint32_t  RNG_ICR;                      /*!< (@ 0x00001108) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in RNG_ISR.                              */
  __IOM uint32_t  TRNG_CONFIG;                  /*!< (@ 0x0000110C) This register handles TRNG configuration                   */
  __IM  uint32_t  TRNG_VALID;                   /*!< (@ 0x00001110) This register indicates that the TRNG data is
                                                                    valid.                                                     */
  __IM  uint32_t  EHR_DATA_0;                   /*!< (@ 0x00001114) This register contains bits [31:0] of the data
                                                                    collected by the TRNG block.                               */
  __IM  uint32_t  EHR_DATA_1;                   /*!< (@ 0x00001118) This register contains bits [63:32] of the data
                                                                    collected by the TRNG block.                               */
  __IM  uint32_t  EHR_DATA_2;                   /*!< (@ 0x0000111C) This register contains bits [95:64] of the data
                                                                    collected by the TRNG block.                               */
  __IM  uint32_t  EHR_DATA_3;                   /*!< (@ 0x00001120) This register contains bits [127:96] of the data
                                                                    collected by the TRNG block.                               */
  __IM  uint32_t  EHR_DATA_4;                   /*!< (@ 0x00001124) This register contains bits [159:128] of the
                                                                    data collected by the TRNG block.                          */
  __IM  uint32_t  EHR_DATA_5;                   /*!< (@ 0x00001128) This register contains bits [191:160] of the
                                                                    data collected by the TRNG block.                          */
  __IOM uint32_t  RND_SOURCE_ENABLE;            /*!< (@ 0x0000112C) This register holds the enable signal for the
                                                                    random source.                                             */
  __IOM uint32_t  SAMPLE_CNT1;                  /*!< (@ 0x00001130) Counts clocks between sampling of random bit.              */
  __IOM uint32_t  AUTOCORR_STATISTIC;           /*!< (@ 0x00001134) Statistics about autocorrelation test activations.         */
  __IOM uint32_t  TRNG_DEBUG_CONTROL;           /*!< (@ 0x00001138) Debug register for the TRNG engine                         */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  RNG_SW_RESET;                 /*!< (@ 0x00001140) Generate SW reset solely to RNG block.                     */
  __IM  uint32_t  RESERVED2[28];
  __IM  uint32_t  RNG_DEBUG_EN_INPUT;           /*!< (@ 0x000011B4) Defines the RNG in debug                                   */
  __IM  uint32_t  RNG_BUSY;                     /*!< (@ 0x000011B8) RNG busy indication                                        */
  __OM  uint32_t  RST_BITS_COUNTER;             /*!< (@ 0x000011BC) Resets the counter of collected bits in the TRNG           */
  __IM  uint32_t  RNG_VERSION;                  /*!< (@ 0x000011C0) This register holds the RNG version                        */
  __OM  uint32_t  RNG_CLK_ENABLE;               /*!< (@ 0x000011C4) Writing to this register enables/disables the
                                                                    RNG clock.                                                 */
  __IOM uint32_t  RNG_DMA_ENABLE;               /*!< (@ 0x000011C8) Writing to this register enables/disables the
                                                                    RNG DMA                                                    */
  __IOM uint32_t  RNG_DMA_SRC_MASK;             /*!< (@ 0x000011CC) This register defines which ring-oscillator length
                                                                    should be used when using the RNG DMA.                     */
  __IOM uint32_t  RNG_DMA_SRAM_ADDR;            /*!< (@ 0x000011D0) This register defines the start address of the
                                                                    DMA for the TRNG data.                                     */
  __IOM uint32_t  RNG_DMA_SAMPLES_NUM;          /*!< (@ 0x000011D4) This register defines the number of 192-bits
                                                                    samples that the DMA collects per RNG configuration.       */
  __IOM uint32_t  RNG_WATCHDOG_VAL;             /*!< (@ 0x000011D8) This register defines the maximum number of clock
                                                                    cycles per TRNG collection of 192-bits samples.
                                                                    If the number of cycles for a collection
                                                                    exceeds this threshold, TRNG signals an
                                                                    interrupt.                                                 */
  __IM  uint32_t  RNG_DMA_STATUS;               /*!< (@ 0x000011DC) This register holds the RNG DMA status.                    */
} NRF_CC_RNG_Type;                              /*!< Size = 4576 (0x11e0)                                                      */



/* =========================================================================================================================== */
/* ================                                        CRYPTOCELL                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief ARM TrustZone CryptoCell register interface (CRYPTOCELL)
  */

typedef struct {                                /*!< (@ 0x5002A000) CRYPTOCELL Structure                                       */
  __IM  uint32_t  RESERVED[26];
  __OM  uint32_t  TASKZEROPENALTY2;             /*!< (@ 0x00000068) CRYPTOCELL PcgcSlave: Set the penalty to zero
                                                                    for power/clock pair 2                                     */
  __OM  uint32_t  TASKFULLPENALTY2;             /*!< (@ 0x0000006C) CRYPTOCELL PcgcSlave: Set the penalty to full
                                                                    for power/clock pair 2                                     */
  __OM  uint32_t  TASKZEROPENALTY1;             /*!< (@ 0x00000070) CRYPTOCELL PcgcSlave: Set the penalty to zero
                                                                    for power/clock pair 1                                     */
  __OM  uint32_t  TASKFULLPENALTY1;             /*!< (@ 0x00000074) CRYPTOCELL PcgcSlave: Set the penalty to full
                                                                    for power/clock pair 1                                     */
  __IM  uint32_t  RESERVED1[290];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable CRYPTOCELL subsystem                                */
  __IOM uint32_t  RESET;                        /*!< (@ 0x00000504) Perform an external reset of the CRYPTOCELL subsystem.     */
  __IM  uint32_t  IRQ_STATUS;                   /*!< (@ 0x00000508) Holds the interrupt status from the CRYPTOCELL
                                                                    subsystems.                                                */
  __IOM uint32_t  TSEL;                         /*!< (@ 0x0000050C) Timing select (TSEL) settings for CRYPTOCELL
                                                                    dedicated PKA and RNG SRAM blocks.                         */
  __IM  uint32_t  RESERVED2[445];
  __IOM uint32_t  PENALTYRG1;                   /*!< (@ 0x00000C04) CRYPTOCELL PcgcSlave: Penalty reg power/clock
                                                                    pair 1                                                     */
  __IOM uint32_t  PENALTYRG2;                   /*!< (@ 0x00000C08) CRYPTOCELL PcgcSlave: Penalty reg power/clock
                                                                    pair 2                                                     */
  __IM  uint32_t  RESERVED3[29];
  __IOM uint32_t  FORCEOVERRIDE0;               /*!< (@ 0x00000C80) CRYPTOCELL (and CC310KmuInterface, if present)
                                                                    PcgcSlave: Override power/clock pair 0                     */
  __IOM uint32_t  FORCEOVERRIDE1;               /*!< (@ 0x00000C84) CRYPTOCELL PcgcSlave: Override power/clock pair
                                                                    1                                                          */
  __IOM uint32_t  FORCEOVERRIDE2;               /*!< (@ 0x00000C88) CRYPTOCELL PcgcSlave: Override power/clock pair
                                                                    2                                                          */
} NRF_CRYPTOCELL_Type;                          /*!< Size = 3212 (0xc8c)                                                       */



/* =========================================================================================================================== */
/* ================                                        RAMBISTHUB                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief RAM built in self test hub (RAMBISTHUB)
  */

typedef struct {                                /*!< (@ 0x4006C000) RAMBISTHUB Structure                                       */
  __OM  uint32_t  TASKS_RUN;                    /*!< (@ 0x00000000) Task trigger. Readable if the parameter SELECT_TASK_REGISTERS
                                                                    is 1. Cleared when the MCU writes a 0 to
                                                                    it.                                                        */
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_SLEEP;                 /*!< (@ 0x00000100) Set when eventBistSleep is high, or when the
                                                                    MCU writes 1 to this address and SELECT_EVENT_TRIGGERS
                                                                    is 1.                                                      */
  __IOM uint32_t  EVENTS_FINISHED;              /*!< (@ 0x00000104) Set when eventBistFinished is high, or when the
                                                                    MCU writes 1 to this address and SELECT_EVENT_TRIGGERS
                                                                    is 1.                                                      */
  __IM  uint32_t  RESERVED1[126];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable                                                     */
  __IOM uint32_t  SELECT;                       /*!< (@ 0x00000504) Select which BIST(s) to be RUN task is triggered.          */
  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000508) Status register.                                           */
  __IOM uint32_t  TESTTYPE;                     /*!< (@ 0x0000050C) Test type.                                                 */
  __IOM uint32_t  RETFORCE;                     /*!< (@ 0x00000510) Shadow register to force RAMs on when testing
                                                                    retention.                                                 */
} NRF_RAMBISTHUB_Type;                          /*!< Size = 1300 (0x514)                                                       */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_FICR_BASE               0x10000000UL
#define NRF_UICR_BASE               0x10001000UL
#define NRF_AMLI_BASE               0x40000000UL
#define NRF_APPROTECT_BASE          0x40000000UL
#define NRF_CLOCK_BASE              0x40000000UL
#define NRF_POWER_BASE              0x40000000UL
#define NRF_P0_BASE                 0x50000000UL
#define NRF_P1_BASE                 0x50000300UL
#define NRF_RADIO_BASE              0x40001000UL
#define NRF_UART0_BASE              0x40002000UL
#define NRF_UARTE0_BASE             0x40002000UL
#define NRF_SPI0_BASE               0x40003000UL
#define NRF_SPIM0_BASE              0x40003000UL
#define NRF_SPIS0_BASE              0x40003000UL
#define NRF_TWI0_BASE               0x40003000UL
#define NRF_TWIM0_BASE              0x40003000UL
#define NRF_TWIS0_BASE              0x40003000UL
#define NRF_SPI1_BASE               0x40004000UL
#define NRF_SPIM1_BASE              0x40004000UL
#define NRF_SPIS1_BASE              0x40004000UL
#define NRF_TWI1_BASE               0x40004000UL
#define NRF_TWIM1_BASE              0x40004000UL
#define NRF_TWIS1_BASE              0x40004000UL
#define NRF_NFCT_BASE               0x40005000UL
#define NRF_GPIOTE_BASE             0x40006000UL
#define NRF_SAADC_BASE              0x40007000UL
#define NRF_TIMER0_BASE             0x40008000UL
#define NRF_TIMER1_BASE             0x40009000UL
#define NRF_TIMER2_BASE             0x4000A000UL
#define NRF_RTC0_BASE               0x4000B000UL
#define NRF_TEMP_BASE               0x4000C000UL
#define NRF_RNG_BASE                0x4000D000UL
#define NRF_ECB_BASE                0x4000E000UL
#define NRF_AAR_BASE                0x4000F000UL
#define NRF_CCM_BASE                0x4000F000UL
#define NRF_WDT_BASE                0x40010000UL
#define NRF_RTC1_BASE               0x40011000UL
#define NRF_QDEC_BASE               0x40012000UL
#define NRF_COMP_BASE               0x40013000UL
#define NRF_LPCOMP_BASE             0x40013000UL
#define NRF_EGU0_BASE               0x40014000UL
#define NRF_SWI0_BASE               0x40014000UL
#define NRF_EGU1_BASE               0x40015000UL
#define NRF_SWI1_BASE               0x40015000UL
#define NRF_EGU2_BASE               0x40016000UL
#define NRF_SWI2_BASE               0x40016000UL
#define NRF_EGU3_BASE               0x40017000UL
#define NRF_SWI3_BASE               0x40017000UL
#define NRF_EGU4_BASE               0x40018000UL
#define NRF_SWI4_BASE               0x40018000UL
#define NRF_EGU5_BASE               0x40019000UL
#define NRF_SWI5_BASE               0x40019000UL
#define NRF_TIMER3_BASE             0x4001A000UL
#define NRF_TIMER4_BASE             0x4001B000UL
#define NRF_PWM0_BASE               0x4001C000UL
#define NRF_PDM_BASE                0x4001D000UL
#define NRF_ACL_BASE                0x4001E000UL
#define NRF_NVMC_BASE               0x4001E000UL
#define NRF_PPI_BASE                0x4001F000UL
#define NRF_MWU_BASE                0x40020000UL
#define NRF_PWM1_BASE               0x40021000UL
#define NRF_PWM2_BASE               0x40022000UL
#define NRF_SPI2_BASE               0x40023000UL
#define NRF_SPIM2_BASE              0x40023000UL
#define NRF_SPIS2_BASE              0x40023000UL
#define NRF_RTC2_BASE               0x40024000UL
#define NRF_I2S_BASE                0x40025000UL
#define NRF_FPU_BASE                0x40026000UL
#define NRF_USBD_BASE               0x40027000UL
#define NRF_UARTE1_BASE             0x40028000UL
#define NRF_QSPI_BASE               0x40029000UL
#define NRF_CC_AES_BASE             0x5002A000UL
#define NRF_CC_AHB_BASE             0x5002A000UL
#define NRF_CC_CHACHA_BASE          0x5002A000UL
#define NRF_CC_CTL_BASE             0x5002A000UL
#define NRF_CC_DIN_BASE             0x5002A000UL
#define NRF_CC_DOUT_BASE            0x5002A000UL
#define NRF_CC_HASH_BASE            0x5002A000UL
#define NRF_CC_HOST_RGF_BASE        0x5002A000UL
#define NRF_CC_HOST_SRAM_BASE       0x5002A000UL
#define NRF_CC_MISC_BASE            0x5002A000UL
#define NRF_CC_PKA_BASE             0x5002A000UL
#define NRF_CC_RNG_BASE             0x5002A000UL
#define NRF_CRYPTOCELL_BASE         0x5002A000UL
#define NRF_PWM3_BASE               0x4002D000UL
#define NRF_SPIM3_BASE              0x4002F000UL
#define NRF_RAMBISTHUB_BASE         0x4006C000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
#define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
#define NRF_AMLI                    ((NRF_AMLI_Type*)          NRF_AMLI_BASE)
#define NRF_APPROTECT               ((NRF_APPROTECT_Type*)     NRF_APPROTECT_BASE)
#define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
#define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
#define NRF_P0                      ((NRF_GPIO_Type*)          NRF_P0_BASE)
#define NRF_P1                      ((NRF_GPIO_Type*)          NRF_P1_BASE)
#define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
#define NRF_UART0                   ((NRF_UART_Type*)          NRF_UART0_BASE)
#define NRF_UARTE0                  ((NRF_UARTE_Type*)         NRF_UARTE0_BASE)
#define NRF_SPI0                    ((NRF_SPI_Type*)           NRF_SPI0_BASE)
#define NRF_SPIM0                   ((NRF_SPIM_Type*)          NRF_SPIM0_BASE)
#define NRF_SPIS0                   ((NRF_SPIS_Type*)          NRF_SPIS0_BASE)
#define NRF_TWI0                    ((NRF_TWI_Type*)           NRF_TWI0_BASE)
#define NRF_TWIM0                   ((NRF_TWIM_Type*)          NRF_TWIM0_BASE)
#define NRF_TWIS0                   ((NRF_TWIS_Type*)          NRF_TWIS0_BASE)
#define NRF_SPI1                    ((NRF_SPI_Type*)           NRF_SPI1_BASE)
#define NRF_SPIM1                   ((NRF_SPIM_Type*)          NRF_SPIM1_BASE)
#define NRF_SPIS1                   ((NRF_SPIS_Type*)          NRF_SPIS1_BASE)
#define NRF_TWI1                    ((NRF_TWI_Type*)           NRF_TWI1_BASE)
#define NRF_TWIM1                   ((NRF_TWIM_Type*)          NRF_TWIM1_BASE)
#define NRF_TWIS1                   ((NRF_TWIS_Type*)          NRF_TWIS1_BASE)
#define NRF_NFCT                    ((NRF_NFCT_Type*)          NRF_NFCT_BASE)
#define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
#define NRF_SAADC                   ((NRF_SAADC_Type*)         NRF_SAADC_BASE)
#define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
#define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
#define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
#define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
#define NRF_TEMP                    ((NRF_TEMP_Type*)          NRF_TEMP_BASE)
#define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
#define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
#define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
#define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
#define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
#define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
#define NRF_QDEC                    ((NRF_QDEC_Type*)          NRF_QDEC_BASE)
#define NRF_COMP                    ((NRF_COMP_Type*)          NRF_COMP_BASE)
#define NRF_LPCOMP                  ((NRF_LPCOMP_Type*)        NRF_LPCOMP_BASE)
#define NRF_EGU0                    ((NRF_EGU_Type*)           NRF_EGU0_BASE)
#define NRF_SWI0                    ((NRF_SWI_Type*)           NRF_SWI0_BASE)
#define NRF_EGU1                    ((NRF_EGU_Type*)           NRF_EGU1_BASE)
#define NRF_SWI1                    ((NRF_SWI_Type*)           NRF_SWI1_BASE)
#define NRF_EGU2                    ((NRF_EGU_Type*)           NRF_EGU2_BASE)
#define NRF_SWI2                    ((NRF_SWI_Type*)           NRF_SWI2_BASE)
#define NRF_EGU3                    ((NRF_EGU_Type*)           NRF_EGU3_BASE)
#define NRF_SWI3                    ((NRF_SWI_Type*)           NRF_SWI3_BASE)
#define NRF_EGU4                    ((NRF_EGU_Type*)           NRF_EGU4_BASE)
#define NRF_SWI4                    ((NRF_SWI_Type*)           NRF_SWI4_BASE)
#define NRF_EGU5                    ((NRF_EGU_Type*)           NRF_EGU5_BASE)
#define NRF_SWI5                    ((NRF_SWI_Type*)           NRF_SWI5_BASE)
#define NRF_TIMER3                  ((NRF_TIMER_Type*)         NRF_TIMER3_BASE)
#define NRF_TIMER4                  ((NRF_TIMER_Type*)         NRF_TIMER4_BASE)
#define NRF_PWM0                    ((NRF_PWM_Type*)           NRF_PWM0_BASE)
#define NRF_PDM                     ((NRF_PDM_Type*)           NRF_PDM_BASE)
#define NRF_ACL                     ((NRF_ACL_Type*)           NRF_ACL_BASE)
#define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
#define NRF_PPI                     ((NRF_PPI_Type*)           NRF_PPI_BASE)
#define NRF_MWU                     ((NRF_MWU_Type*)           NRF_MWU_BASE)
#define NRF_PWM1                    ((NRF_PWM_Type*)           NRF_PWM1_BASE)
#define NRF_PWM2                    ((NRF_PWM_Type*)           NRF_PWM2_BASE)
#define NRF_SPI2                    ((NRF_SPI_Type*)           NRF_SPI2_BASE)
#define NRF_SPIM2                   ((NRF_SPIM_Type*)          NRF_SPIM2_BASE)
#define NRF_SPIS2                   ((NRF_SPIS_Type*)          NRF_SPIS2_BASE)
#define NRF_RTC2                    ((NRF_RTC_Type*)           NRF_RTC2_BASE)
#define NRF_I2S                     ((NRF_I2S_Type*)           NRF_I2S_BASE)
#define NRF_FPU                     ((NRF_FPU_Type*)           NRF_FPU_BASE)
#define NRF_USBD                    ((NRF_USBD_Type*)          NRF_USBD_BASE)
#define NRF_UARTE1                  ((NRF_UARTE_Type*)         NRF_UARTE1_BASE)
#define NRF_QSPI                    ((NRF_QSPI_Type*)          NRF_QSPI_BASE)
#define NRF_CC_AES                  ((NRF_CC_AES_Type*)        NRF_CC_AES_BASE)
#define NRF_CC_AHB                  ((NRF_CC_AHB_Type*)        NRF_CC_AHB_BASE)
#define NRF_CC_CHACHA               ((NRF_CC_CHACHA_Type*)     NRF_CC_CHACHA_BASE)
#define NRF_CC_CTL                  ((NRF_CC_CTL_Type*)        NRF_CC_CTL_BASE)
#define NRF_CC_DIN                  ((NRF_CC_DIN_Type*)        NRF_CC_DIN_BASE)
#define NRF_CC_DOUT                 ((NRF_CC_DOUT_Type*)       NRF_CC_DOUT_BASE)
#define NRF_CC_HASH                 ((NRF_CC_HASH_Type*)       NRF_CC_HASH_BASE)
#define NRF_CC_HOST_RGF             ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_BASE)
#define NRF_CC_HOST_SRAM            ((NRF_CC_HOST_SRAM_Type*)  NRF_CC_HOST_SRAM_BASE)
#define NRF_CC_MISC                 ((NRF_CC_MISC_Type*)       NRF_CC_MISC_BASE)
#define NRF_CC_PKA                  ((NRF_CC_PKA_Type*)        NRF_CC_PKA_BASE)
#define NRF_CC_RNG                  ((NRF_CC_RNG_Type*)        NRF_CC_RNG_BASE)
#define NRF_CRYPTOCELL              ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_BASE)
#define NRF_PWM3                    ((NRF_PWM_Type*)           NRF_PWM3_BASE)
#define NRF_SPIM3                   ((NRF_SPIM_Type*)          NRF_SPIM3_BASE)
#define NRF_RAMBISTHUB              ((NRF_RAMBISTHUB_Type*)    NRF_RAMBISTHUB_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* NRF52840_H */


/** @} */ /* End of group nrf52840 */

/** @} */ /* End of group Nordic Semiconductor */
