/*
 * Copyright (c) 2010 - 2020, Nordic Semiconductor ASA
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form, except as embedded into a Nordic
 * Semiconductor ASA integrated circuit in a product or a software update for
 * such product, must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * 
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * 
 * 4. This software, with or without modification, must only be used with a
 * Nordic Semiconductor ASA integrated circuit.
 * 
 * 5. Any software provided in binary form under this license must not be reverse
 * engineered, decompiled, modified and/or disassembled.
 * 
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf51.h
 * @brief    CMSIS HeaderFile
 * @version  522
 * @date     01. October 2020
 * @note     Generated by SVDConv V3.3.35 on Thursday, 01.10.2020 15:17:34
 *           from File 'nrf51.svd',
 *           last modified on Thursday, 01.10.2020 13:17:16
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf51
  * @{
  */


#ifndef NRF51_H
#define NRF51_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ===========================================  nrf51 Specific Interrupt Numbers  ============================================ */
  POWER_CLOCK_IRQn          =   0,              /*!< 0  POWER_CLOCK                                                            */
  RADIO_IRQn                =   1,              /*!< 1  RADIO                                                                  */
  UART0_IRQn                =   2,              /*!< 2  UART0                                                                  */
  SPI0_TWI0_IRQn            =   3,              /*!< 3  SPI0_TWI0                                                              */
  SPI1_TWI1_IRQn            =   4,              /*!< 4  SPI1_TWI1                                                              */
  GPIOTE_IRQn               =   6,              /*!< 6  GPIOTE                                                                 */
  ADC_IRQn                  =   7,              /*!< 7  ADC                                                                    */
  TIMER0_IRQn               =   8,              /*!< 8  TIMER0                                                                 */
  TIMER1_IRQn               =   9,              /*!< 9  TIMER1                                                                 */
  TIMER2_IRQn               =  10,              /*!< 10 TIMER2                                                                 */
  RTC0_IRQn                 =  11,              /*!< 11 RTC0                                                                   */
  TEMP_IRQn                 =  12,              /*!< 12 TEMP                                                                   */
  RNG_IRQn                  =  13,              /*!< 13 RNG                                                                    */
  ECB_IRQn                  =  14,              /*!< 14 ECB                                                                    */
  CCM_AAR_IRQn              =  15,              /*!< 15 CCM_AAR                                                                */
  WDT_IRQn                  =  16,              /*!< 16 WDT                                                                    */
  RTC1_IRQn                 =  17,              /*!< 17 RTC1                                                                   */
  QDEC_IRQn                 =  18,              /*!< 18 QDEC                                                                   */
  LPCOMP_IRQn               =  19,              /*!< 19 LPCOMP                                                                 */
  SWI0_IRQn                 =  20,              /*!< 20 SWI0                                                                   */
  SWI1_IRQn                 =  21,              /*!< 21 SWI1                                                                   */
  SWI2_IRQn                 =  22,              /*!< 22 SWI2                                                                   */
  SWI3_IRQn                 =  23,              /*!< 23 SWI3                                                                   */
  SWI4_IRQn                 =  24,              /*!< 24 SWI4                                                                   */
  SWI5_IRQn                 =  25               /*!< 25 SWI5                                                                   */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M0 Processor and Core Peripherals  =========================== */
#define __CM0_REV                 0x0301U       /*!< CM0 Core Revision                                                         */
#define __DSP_PRESENT                  0        /*!< DSP present or not                                                        */
#define __VTOR_PRESENT                 0        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  0        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm0.h"                           /*!< ARM Cortex-M0 processor and core peripherals                              */
#include "system_nrf51.h"                       /*!< nrf51 System                                                              */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief CLOCK_GATE [GATE] (Clock gating control)
  */
typedef struct {
  __IOM uint32_t  CPU;                          /*!< (@ 0x00000000) CPU clock gating                                           */
} CLOCK_GATE_Type;                              /*!< Size = 4 (0x4)                                                            */


/**
  * @brief AMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  CPU0;                         /*!< (@ 0x00000000) AHB bus master priority register for CPU0                  */
  __IOM uint32_t  SPIS1;                        /*!< (@ 0x00000004) AHB bus master priority register for SPIM1, SPIS1,
                                                                    TWIM1 and TWIS1                                            */
  __IOM uint32_t  RADIO;                        /*!< (@ 0x00000008) AHB bus master priority register for RADIO                 */
  __IOM uint32_t  ECB;                          /*!< (@ 0x0000000C) AHB bus master priority register for ECB                   */
  __IOM uint32_t  CCM;                          /*!< (@ 0x00000010) AHB bus master priority register for CCM                   */
  __IOM uint32_t  AAR;                          /*!< (@ 0x00000014) AHB bus master priority register for AAR                   */
} AMLI_RAMPRI_Type;                             /*!< Size = 24 (0x18)                                                          */


/**
  * @brief RADIO_ACQDMA [ACQDMA] (EasyDMA channel for data acquisition (refer to 4378_164))
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) EasyDMA pointer for Data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 32-bit words to transfer (refer
                                                                    to 4378_164)                                               */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 32-bit words transferred in the last
                                                                    transaction (refer to 4378_164)                            */
} RADIO_ACQDMA_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPIM1_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
} SPIM1_PSEL_Type;                              /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPIM1_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} SPIM1_RXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPIM1_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} SPIM1_TXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief PPI_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster[0]: Enable channel group
                                                                    0                                                          */
  __OM  uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster[0]: Disable channel group
                                                                    0                                                          */
} PPI_TASKS_CHG_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PPI_CH [CH] (PPI Channel)
  */
typedef struct {
  __IOM uint32_t  EEP;                          /*!< (@ 0x00000000) Description cluster[0]: Channel 0 event end-point          */
  __IOM uint32_t  TEP;                          /*!< (@ 0x00000004) Description cluster[0]: Channel 0 task end-point           */
} PPI_CH_Type;                                  /*!< Size = 8 (0x8)                                                            */


/**
  * @brief GPIO_PIN [PIN] (Pin 0 direct access)
  */
typedef struct {
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000000) Description cluster[0]: Pin 0 direct access output
                                                                    register                                                   */
  __IOM uint32_t  IN;                           /*!< (@ 0x00000004) Description cluster[0]: Pin 0 direct access input
                                                                    register                                                   */
} GPIO_PIN_Type;                                /*!< Size = 8 (0x8)                                                            */


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           FICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory Information Configuration Registers (FICR)
  */

typedef struct {                                /*!< (@ 0x10000000) FICR Structure                                             */
  __IM  uint32_t  CPTEST0;                      /*!< (@ 0x00000000) Result from Circuit Probe test                             */
  __IM  uint32_t  RESERVED[3];
  __IM  uint32_t  CODEPAGESIZE;                 /*!< (@ 0x00000010) Code memory page size                                      */
  __IM  uint32_t  CODESIZE;                     /*!< (@ 0x00000014) Code memory size                                           */
  __IM  uint32_t  RBD;                          /*!< (@ 0x00000018) Royalty bearing device                                     */
  __IM  uint32_t  TESTSTATUS;                   /*!< (@ 0x0000001C) Code memory test status. Will be set during production
                                                                    test.                                                      */
  __IOM uint32_t  UNUSED0;                      /*!< (@ 0x00000020) Unspecified                                                */
  __IM  uint32_t  ADC_ADJUST;                   /*!< (@ 0x00000024) ADC result adjustment parameters                           */
  __IM  uint32_t  CLENR0;                       /*!< (@ 0x00000028) Deprecated register - Length of Code region 0
                                                                    in bytes                                                   */
  __IM  uint32_t  PPFC;                         /*!< (@ 0x0000002C) Deprecated register - Pre-programmed factory
                                                                    Code present                                               */
  __IM  uint32_t  MPUEN;                        /*!< (@ 0x00000030) Deprecated register - Enable Memory Protection
                                                                    Unit (MPU). Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  NUMRAMBLOCK;                  /*!< (@ 0x00000034) Number of individually controllable RAM blocks             */
  
  union {
    __IM  uint32_t SIZERAMBLOCKS;               /*!< (@ 0x00000038) RAM block size, in bytes                                   */
    __IM  uint32_t SIZERAMBLOCK[4];             /*!< (@ 0x00000038) Description collection[0]: Deprecated register
                                                                    - Size of RAM block 0, in bytes                            */
  };
  __IM  uint32_t  CHIPCONF0;                    /*!< (@ 0x00000048) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF1;                    /*!< (@ 0x0000004C) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF2;                    /*!< (@ 0x00000050) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IOM uint32_t  UNUSED1;                      /*!< (@ 0x00000054) Unspecified                                                */
  __IM  uint32_t  DEVICETYPE;                   /*!< (@ 0x00000058) Device type                                                */
  __IM  uint32_t  CONFIGID;                     /*!< (@ 0x0000005C) Configuration identifier                                   */
  __IM  uint32_t  DEVICEID[2];                  /*!< (@ 0x00000060) Description collection[0]: Device identifier               */
  __IOM uint32_t  UNUSED2;                      /*!< (@ 0x00000068) Unspecified                                                */
  __IOM uint32_t  UNUSED3;                      /*!< (@ 0x0000006C) Unspecified                                                */
  __IM  uint32_t  CPTEST1;                      /*!< (@ 0x00000070) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST2;                      /*!< (@ 0x00000074) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST3;                      /*!< (@ 0x00000078) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST4;                      /*!< (@ 0x0000007C) Result from Circuit Probe test                             */
  __IM  uint32_t  ER[4];                        /*!< (@ 0x00000080) Description collection[0]: Encryption Root, word
                                                                    0                                                          */
  __IM  uint32_t  IR[4];                        /*!< (@ 0x00000090) Description collection[0]: Identity Root, word
                                                                    0                                                          */
  __IM  uint32_t  DEVICEADDRTYPE;               /*!< (@ 0x000000A0) Device address type                                        */
  __IM  uint32_t  DEVICEADDR[2];                /*!< (@ 0x000000A4) Description collection[0]: Device address 0                */
  __IM  uint32_t  OVERRIDEEN;                   /*!< (@ 0x000000AC) Override enable                                            */
  __IM  uint32_t  NRF_1MBIT[5];                 /*!< (@ 0x000000B0) Description collection[0]: Override value for
                                                                    NRF_1MBIT mode                                             */
  __IM  uint32_t  NRF_2MBIT[5];                 /*!< (@ 0x000000C4) Description collection[0]: Override value for
                                                                    NRF_2MBIT mode                                             */
  __IM  uint32_t  NRF_250KBIT[5];               /*!< (@ 0x000000D8) Description collection[0]: Override value for
                                                                    NRF_250KBIT mode                                           */
  __IM  uint32_t  BLE_1MBIT[5];                 /*!< (@ 0x000000EC) Description collection[0]: Override value for
                                                                    BLE_1MBIT mode                                             */
  __IM  uint32_t  RESERVED1[8];
  __IM  uint32_t  OTP[2];                       /*!< (@ 0x00000120) Description collection[0]: One Time Programmable
                                                                    Register 0                                                 */
  __IM  uint32_t  RESERVED2[54];
  __IM  uint32_t  CPTEST5;                      /*!< (@ 0x00000200) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST6;                      /*!< (@ 0x00000204) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST7;                      /*!< (@ 0x00000208) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST8;                      /*!< (@ 0x0000020C) Result from Circuit Probe test, flash repair
                                                                    information                                                */
} NRF_FICR_Type;                                /*!< Size = 528 (0x210)                                                        */



/* =========================================================================================================================== */
/* ================                                           UICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief User Information Configuration Registers (UICR)
  */

typedef struct {                                /*!< (@ 0x10001000) UICR Structure                                             */
  __IOM uint32_t  CLENR0;                       /*!< (@ 0x00000000) Length of code region 0                                    */
  __IOM uint32_t  RBPCONF;                      /*!< (@ 0x00000004) Read back protection configuration                         */
  __IOM uint32_t  XTALFREQ;                     /*!< (@ 0x00000008) Reset value for XTALFREQ in CLOCK, see CLOCK
                                                                    chapter                                                    */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  FWID;                         /*!< (@ 0x00000010) Firmware ID                                                */
  
  union {
    __IOM uint32_t BOOTLOADERADDR;              /*!< (@ 0x00000014) Bootloader address                                         */
    __IOM uint32_t NRFFW[15];                   /*!< (@ 0x00000014) Description collection[0]: Reserved for Nordic
                                                                    firmware design                                            */
  };
  __IOM uint32_t  NRFHW[12];                    /*!< (@ 0x00000050) Description collection[0]: Reserved for Nordic
                                                                    hardware design                                            */
  __IOM uint32_t  CUSTOMER[32];                 /*!< (@ 0x00000080) Description collection[0]: Reserved for customer           */
} NRF_UICR_Type;                                /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                            MPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Memory Protection Unit (MPU)
  */

typedef struct {                                /*!< (@ 0x40000000) MPU Structure                                              */
  __IM  uint32_t  RESERVED[330];
  __IOM uint32_t  PERR0;                        /*!< (@ 0x00000528) Definition of peripherals in memory region 0               */
  __IOM uint32_t  RLENR0;                       /*!< (@ 0x0000052C) Length of RAM region 0                                     */
  __IM  uint32_t  RESERVED1[52];
  __IOM uint32_t  PROTENSET0;                   /*!< (@ 0x00000600) Protection bit enable set register                         */
  __IOM uint32_t  PROTENSET1;                   /*!< (@ 0x00000604) Protection bit enable set register                         */
  __IOM uint32_t  DISABLEINDEBUG;               /*!< (@ 0x00000608) Disable protection mechanism in debug mode                 */
  __IOM uint32_t  PROTBLOCKSIZE;                /*!< (@ 0x0000060C) Protection block size                                      */
  __IM  uint32_t  RESERVED2[255];
  __IOM uint32_t  ENRBDREG;                     /*!< (@ 0x00000A0C) Enable RBD register in FICR                                */
} NRF_MPU_Type;                                 /*!< Size = 2576 (0xa10)                                                       */



/* =========================================================================================================================== */
/* ================                                           POWER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control (POWER)
  */

typedef struct {                                /*!< (@ 0x40000000) POWER Structure                                            */
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;               /*!< (@ 0x00000078) Enable constant latency mode                               */
  __OM  uint32_t  TASKS_LOWPWR;                 /*!< (@ 0x0000007C) Enable low power mode (variable latency)                   */
  __IM  uint32_t  RESERVED1[34];
  __IOM uint32_t  EVENTS_POFWARN;               /*!< (@ 0x00000108) Power failure warning                                      */
  __IM  uint32_t  RESERVED2[126];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IOM uint32_t  RESETREAS;                    /*!< (@ 0x00000400) Reset reason                                               */
  __IM  uint32_t  PERRDY;                       /*!< (@ 0x00000404) Peripheral on/off status                                   */
  __IM  uint32_t  RESERVED4[8];
  __IM  uint32_t  RAMSTATUS;                    /*!< (@ 0x00000428) RAM status register                                        */
  __IM  uint32_t  RESERVED5[53];
  __OM  uint32_t  SYSTEMOFF;                    /*!< (@ 0x00000500) System OFF register                                        */
  __IOM uint32_t  PERPOWER;                     /*!< (@ 0x00000504) Peripheral power configuration                             */
  __IOM uint32_t  FORCEON1V2;                   /*!< (@ 0x00000508) Force on 1.2 V regulator                                   */
  __IOM uint32_t  FORCEONNVM;                   /*!< (@ 0x0000050C) Force on NVM. See also the internal section in
                                                                    the NVMC chapter.                                          */
  __IOM uint32_t  POFCON;                       /*!< (@ 0x00000510) Power failure comparator configuration                     */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  GPREGRET;                     /*!< (@ 0x0000051C) General purpose retention register                         */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  RAMON;                        /*!< (@ 0x00000524) RAM on/off register (this register is retained)            */
  __IM  uint32_t  RESERVED8[7];
  __IOM uint32_t  RESET;                        /*!< (@ 0x00000544) Reset configuration register                               */
  __IOM uint32_t  FORCEOFF1V7;                  /*!< (@ 0x00000548) Force off 1.7 V regulator when the device is
                                                                    operating in low voltage mode. See also
                                                                    the internal section in the NVMC chapter.                  */
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  RAMONB;                       /*!< (@ 0x00000554) RAM on/off register (this register is retained)            */
  __IM  uint32_t  RESERVED10[8];
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000578) DC/DC enable register                                      */
  __IM  uint32_t  RESERVED11[291];
  __IOM uint32_t  DCDCFORCE;                    /*!< (@ 0x00000A08) Force DC/DC power-up                                       */
  __IOM uint32_t  ENRBDREG;                     /*!< (@ 0x00000A0C) Enable RBD register in FICR                                */
  __IM  uint32_t  RESERVED12[4];
  __OM  uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x00000A20) Set threshold value of power regulator                     */
  __OM  uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000A24) Enable forcing of power mode in power regulator            */
  __OM  uint32_t  IGNOREDAPCPWRREGMODE;         /*!< (@ 0x00000A28) Ignore DAPCP power mode                                    */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000A2C) Current mode in the power regulator                        */
} NRF_POWER_Type;                               /*!< Size = 2608 (0xa30)                                                       */



/* =========================================================================================================================== */
/* ================                                           CLOCK                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock control (CLOCK)
  */

typedef struct {                                /*!< (@ 0x40000000) CLOCK Structure                                            */
  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFCLK crystal oscillator                             */
  __OM  uint32_t  TASKS_HFCLKSTOP;              /*!< (@ 0x00000004) Stop HFCLK crystal oscillator                              */
  __OM  uint32_t  TASKS_LFCLKSTART;             /*!< (@ 0x00000008) Start LFCLK source                                         */
  __OM  uint32_t  TASKS_LFCLKSTOP;              /*!< (@ 0x0000000C) Stop LFCLK source                                          */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000010) Start calibration of LFRC oscillator                       */
  __OM  uint32_t  TASKS_CTSTART;                /*!< (@ 0x00000014) Start calibration timer                                    */
  __OM  uint32_t  TASKS_CTSTOP;                 /*!< (@ 0x00000018) Stop calibration timer                                     */
  __IM  uint32_t  RESERVED[57];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;          /*!< (@ 0x00000100) HFCLK oscillator started                                   */
  __IOM uint32_t  EVENTS_LFCLKSTARTED;          /*!< (@ 0x00000104) LFCLK started                                              */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x0000010C) Calibration of LFCLK RC oscillator complete event          */
  __IOM uint32_t  EVENTS_CTTO;                  /*!< (@ 0x00000110) Calibration timer timeout                                  */
  __IM  uint32_t  RESERVED2[124];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[63];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) HFCLK status                                               */
  __IM  uint32_t  HFCLKSRCCOPY;                 /*!< (@ 0x00000410) Copy of HFCLKSRC register, set when HFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) LFCLK status                                               */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RCOSC32KIFINE;                /*!< (@ 0x00000420) Fine calibration read value for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IM  uint32_t  RCOSC32KICOARSE;              /*!< (@ 0x00000424) Coarse calibration read value for 32.768 kHz
                                                                    RC oscillator                                              */
  __IM  uint32_t  RESERVED4[59];
  __IOM uint32_t  HFCLKSRC;                     /*!< (@ 0x00000514) Clock source for the HFCLK crystal oscillator.
                                                                    This register shall only be written while
                                                                    no oscillation is present on XC1. Failing
                                                                    to do so may cause unexpected behaviour.                   */
  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for the LFCLK                                 */
  __IM  uint32_t  RESERVED5[6];
  __IOM uint32_t  RCOSC32KICALTEST;             /*!< (@ 0x00000534) 32.768 kHz RC oscillator calibration debug register        */
  __IOM uint32_t  CTIV;                         /*!< (@ 0x00000538) Calibration timer interval                                 */
  __IOM uint32_t  RCOSC32KICALLENGTH;           /*!< (@ 0x0000053C) 32kHz RC oscillator calibration length (retained
                                                                    register, same reset behaviour as RESETREAS)               */
  __IOM uint32_t  RCOSC32KICOARSEIN;            /*!< (@ 0x00000540) RCOSC coarse calibration input                             */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  RCOSC32KICIRC;                /*!< (@ 0x0000054C) Rotating current source for for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IOM uint32_t  XTALFREQ;                     /*!< (@ 0x00000550) Crystal frequency                                          */
  __IM  uint32_t  RESERVED7[3];
  __IOM CLOCK_GATE_Type GATE;                   /*!< (@ 0x00000560) Clock gating control                                       */
} NRF_CLOCK_Type;                               /*!< Size = 1380 (0x564)                                                       */



/* =========================================================================================================================== */
/* ================                                           AMLI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AHB Multi-Layer Interface (AMLI)
  */

typedef struct {                                /*!< (@ 0x40000000) AMLI Structure                                             */
  __IM  uint32_t  RESERVED[896];
  __IOM AMLI_RAMPRI_Type RAMPRI;                /*!< (@ 0x00000E00) RAM configurable priority configuration structure          */
} NRF_AMLI_Type;                                /*!< Size = 3608 (0xe18)                                                       */



/* =========================================================================================================================== */
/* ================                                           RADIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief 2.4 GHz Radio (RADIO)
  */

typedef struct {                                /*!< (@ 0x40001000) RADIO Structure                                            */
  __OM  uint32_t  TASKS_TXEN;                   /*!< (@ 0x00000000) Enable RADIO in TX mode                                    */
  __OM  uint32_t  TASKS_RXEN;                   /*!< (@ 0x00000004) Enable RADIO in RX mode                                    */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000008) Start RADIO                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x0000000C) Stop RADIO                                                 */
  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000010) Disable RADIO                                              */
  __OM  uint32_t  TASKS_RSSISTART;              /*!< (@ 0x00000014) Start the RSSI and take one single sample of
                                                                    the receive signal strength.                               */
  __OM  uint32_t  TASKS_RSSISTOP;               /*!< (@ 0x00000018) Stop the RSSI measurement                                  */
  __OM  uint32_t  TASKS_BCSTART;                /*!< (@ 0x0000001C) Start the bit counter                                      */
  __OM  uint32_t  TASKS_BCSTOP;                 /*!< (@ 0x00000020) Stop the bit counter                                       */
  __IM  uint32_t  RESERVED[21];
  __OM  uint32_t  TASKS_PCGC_ZERO;              /*!< (@ 0x00000078) Zero penalty                                               */
  __OM  uint32_t  TASKS_PCGC_FULL;              /*!< (@ 0x0000007C) Full penalty                                               */
  __IM  uint32_t  RESERVED1[32];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) RADIO has ramped up and is ready to be started             */
  __IOM uint32_t  EVENTS_ADDRESS;               /*!< (@ 0x00000104) Address sent or received                                   */
  __IOM uint32_t  EVENTS_PAYLOAD;               /*!< (@ 0x00000108) Packet payload sent or received                            */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x0000010C) Packet sent or received                                    */
  __IOM uint32_t  EVENTS_DISABLED;              /*!< (@ 0x00000110) RADIO has been disabled                                    */
  __IOM uint32_t  EVENTS_DEVMATCH;              /*!< (@ 0x00000114) A device address match occurred on the last received
                                                                    packet                                                     */
  __IOM uint32_t  EVENTS_DEVMISS;               /*!< (@ 0x00000118) No device address match occurred on the last
                                                                    received packet                                            */
  __IOM uint32_t  EVENTS_RSSIEND;               /*!< (@ 0x0000011C) Sampling of receive signal strength complete.              */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_BCMATCH;               /*!< (@ 0x00000128) Bit counter reached bit count value.                       */
  __IM  uint32_t  RESERVED3[53];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED4[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  CRCSTATUS;                    /*!< (@ 0x00000400) CRC status                                                 */
  __IM  uint32_t  CD;                           /*!< (@ 0x00000404) Carrier detect                                             */
  __IM  uint32_t  RXMATCH;                      /*!< (@ 0x00000408) Received address                                           */
  __IM  uint32_t  RXCRC;                        /*!< (@ 0x0000040C) CRC field of previously received packet                    */
  __IM  uint32_t  DAI;                          /*!< (@ 0x00000410) Device address match index                                 */
  __IM  uint32_t  PDU_STAT;                     /*!< (@ 0x00000414) Payload status                                             */
  __IM  uint32_t  DMA_STAT;                     /*!< (@ 0x00000418) DMA byte count                                             */
  __IM  uint32_t  CALIF_CAPSW;                  /*!< (@ 0x0000041C) IF calibration related to AAFRCCAL                         */
  __IM  uint32_t  PLL_CAL_VCO;                  /*!< (@ 0x00000420) PLL Calibration                                            */
  __IM  uint32_t  LNB_OUT_SPI;                  /*!< (@ 0x00000424) Gain calibration                                           */
  __IM  uint32_t  RESERVED6[9];
  __IM  uint32_t  DFESTATUS;                    /*!< (@ 0x0000044C) DFE status of packet received.                             */
  __IM  uint32_t  RESERVED7[45];
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000504) Packet pointer                                             */
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000508) Frequency                                                  */
  __IOM uint32_t  TXPOWER;                      /*!< (@ 0x0000050C) Output power                                               */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000510) Data rate and modulation                                   */
  __IOM uint32_t  PCNF0;                        /*!< (@ 0x00000514) Packet configuration register 0                            */
  __IOM uint32_t  PCNF1;                        /*!< (@ 0x00000518) Packet configuration register 1                            */
  __IOM uint32_t  BASE0;                        /*!< (@ 0x0000051C) Base address 0                                             */
  __IOM uint32_t  BASE1;                        /*!< (@ 0x00000520) Base address 1                                             */
  __IOM uint32_t  PREFIX0;                      /*!< (@ 0x00000524) Prefixes bytes for logical addresses 0-3                   */
  __IOM uint32_t  PREFIX1;                      /*!< (@ 0x00000528) Prefixes bytes for logical addresses 4-7                   */
  __IOM uint32_t  TXADDRESS;                    /*!< (@ 0x0000052C) Transmit address select                                    */
  __IOM uint32_t  RXADDRESSES;                  /*!< (@ 0x00000530) Receive address select                                     */
  __IOM uint32_t  CRCCNF;                       /*!< (@ 0x00000534) CRC configuration                                          */
  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000538) CRC polynomial                                             */
  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x0000053C) CRC initial value                                          */
  __IOM uint32_t  TEST;                         /*!< (@ 0x00000540) Test features enable register.                             */
  __IOM uint32_t  TIFS;                         /*!< (@ 0x00000544) Inter Frame Spacing in us                                  */
  __IM  uint32_t  RSSISAMPLE;                   /*!< (@ 0x00000548) RSSI sample                                                */
  __IOM uint32_t  RSSI_CONFIG;                  /*!< (@ 0x0000054C) RSSI resolution                                            */
  __IM  uint32_t  STATE;                        /*!< (@ 0x00000550) Current radio state                                        */
  __IOM uint32_t  DATAWHITEIV;                  /*!< (@ 0x00000554) Data whitening initial value                               */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  DMA_MAXLEN;                   /*!< (@ 0x0000055C) DMA max length                                             */
  __IOM uint32_t  BCC;                          /*!< (@ 0x00000560) Bit counter compare                                        */
  __IM  uint32_t  RESERVED9[39];
  __IOM uint32_t  DAB[8];                       /*!< (@ 0x00000600) Description collection[0]: Device address base
                                                                    segment 0                                                  */
  __IOM uint32_t  DAP[8];                       /*!< (@ 0x00000620) Description collection[0]: Device address prefix
                                                                    0                                                          */
  __IOM uint32_t  DACNF;                        /*!< (@ 0x00000640) Device address match configuration                         */
  __IM  uint32_t  RESERVED10[7];
  __IOM uint32_t  AUTO1V7;                      /*!< (@ 0x00000660) Automatically switch on 1V7 when RADIO is active           */
  __IM  uint32_t  RESERVED11[39];
  __IOM uint32_t  PWRUP_CD;                     /*!< (@ 0x00000700) Power up carried detect                                    */
  __IOM uint32_t  AGC_TOGGLE;                   /*!< (@ 0x00000704) Constant AGC Gain switching, Debug                         */
  __IOM uint32_t  AGC_EN;                       /*!< (@ 0x00000708) AGC enable                                                 */
  __IOM uint32_t  AGC_OVERRIDE;                 /*!< (@ 0x0000070C) Gain setting                                               */
  __IOM uint32_t  CALIF_OVERRIDE;               /*!< (@ 0x00000710) IF RC calibration override                                 */
  __IOM uint32_t  CALIF_SET_CAPSW;              /*!< (@ 0x00000714) IF RC calibration                                          */
  __IOM uint32_t  PLL_CAPCNF;                   /*!< (@ 0x00000718) PLL calibration                                            */
  __IOM uint32_t  VCO_SHUTDOWN;                 /*!< (@ 0x0000071C) VCO control                                                */
  __IOM uint32_t  PLL_OUT_CLOCK;                /*!< (@ 0x00000720) PLL calibration                                            */
  
  union {
    __IOM uint32_t OVERRIDE0;                   /*!< (@ 0x00000724) Trim value override register 0                             */
    __IOM uint32_t LOVERRIDE0;                  /*!< (@ 0x00000724) Trim value override register 0 for Loderunner              */
  };
  
  union {
    __IOM uint32_t OVERRIDE1;                   /*!< (@ 0x00000728) Trim value override register 1                             */
    __IOM uint32_t LOVERRIDE1;                  /*!< (@ 0x00000728) Trim value override register 1 for Loderunner              */
  };
  
  union {
    __IOM uint32_t OVERRIDE2;                   /*!< (@ 0x0000072C) Trim value override register 2                             */
    __IOM uint32_t LOVERRIDE2;                  /*!< (@ 0x0000072C) Trim value override register 2 for Loderunner              */
  };
  
  union {
    __IOM uint32_t OVERRIDE3;                   /*!< (@ 0x00000730) Trim value override register 3                             */
    __IOM uint32_t LOVERRIDE3;                  /*!< (@ 0x00000730) Trim value override register 3 for Loderunner              */
  };
  
  union {
    __IOM uint32_t OVERRIDE4;                   /*!< (@ 0x00000734) Trim value override register 4                             */
    __IOM uint32_t LOVERRIDE4;                  /*!< (@ 0x00000734) Trim value override register 4 for Loderunner              */
  };
  __IM  uint32_t  RESERVED12[190];
  __IOM uint32_t  ACQENABLE;                    /*!< (@ 0x00000A30) Enable or disable data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM RADIO_ACQDMA_Type ACQDMA;               /*!< (@ 0x00000A34) EasyDMA channel for data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  ACQMODE;                      /*!< (@ 0x00000A40) Data acquisition capture mode (refer to 4378_164)          */
  __IOM uint32_t  ACQAHBCNF;                    /*!< (@ 0x00000A44) Data acquisition EasyDMA AHB configuration register
                                                                    (refer to 4378_164)                                        */
  __IM  uint32_t  RESERVED13[110];
  __IOM uint32_t  PCGC_PENALTY;                 /*!< (@ 0x00000C00) Power and clock                                            */
  __IM  uint32_t  RESERVED14[3];
  __IOM uint32_t  PCGC_OVERRIDE;                /*!< (@ 0x00000C10) Power and clock                                            */
  __IM  uint32_t  RESERVED15[3];
  __IOM uint32_t  PCGC_CLK_REQ;                 /*!< (@ 0x00000C20) Power and clock                                            */
  __IM  uint32_t  RESERVED16[55];
  __IOM uint32_t  PCGC_BACKDOOR;                /*!< (@ 0x00000D00) Power and clock                                            */
  __IOM uint32_t  PCGC_FORCEREG;                /*!< (@ 0x00000D04) Power and clock                                            */
  __IM  uint32_t  RESERVED17[189];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RADIO_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter (UART0)
  */

typedef struct {                                /*!< (@ 0x40002000) UART0 Structure                                            */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART                                               */
  __IM  uint32_t  RESERVED1[56];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD                                       */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED5[46];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source                                               */
  __IM  uint32_t  RESERVED8[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  PSELRTS;                      /*!< (@ 0x00000508) Pin select for RTS                                         */
  __IOM uint32_t  PSELTXD;                      /*!< (@ 0x0000050C) Pin select for TXD                                         */
  __IOM uint32_t  PSELCTS;                      /*!< (@ 0x00000510) Pin select for CTS                                         */
  __IOM uint32_t  PSELRXD;                      /*!< (@ 0x00000514) Pin select for RXD                                         */
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __OM  uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate                                                  */
  __IM  uint32_t  RESERVED11[17];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
  __IM  uint32_t  RESERVED12[675];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_UART_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface 0 (SPI0)
  */

typedef struct {                                /*!< (@ 0x40003000) SPI0 Structure                                             */
  __IM  uint32_t  RESERVED[66];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000108) TXD byte sent and RXD byte received                        */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI                                                 */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  PSELSCK;                      /*!< (@ 0x00000508) Pin select for SCK                                         */
  __IOM uint32_t  PSELMOSI;                     /*!< (@ 0x0000050C) Pin select for MOSI                                        */
  __IOM uint32_t  PSELMISO;                     /*!< (@ 0x00000510) Pin select for MISO                                        */
  __IM  uint32_t  RESERVED4;
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency                                              */
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED7[681];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Interface 0 (TWI0)
  */

typedef struct {                                /*!< (@ 0x40003000) TWI0 Structure                                             */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[56];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IOM uint32_t  EVENTS_RXDREADY;              /*!< (@ 0x00000108) TWI RXD byte received                                      */
  __IM  uint32_t  RESERVED4[4];
  __IOM uint32_t  EVENTS_TXDSENT;               /*!< (@ 0x0000011C) TWI TXD byte sent                                          */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) TWI entered the suspended state                            */
  __IM  uint32_t  RESERVED8[45];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED9[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED10[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED11[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWI                                                 */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PSELSCL;                      /*!< (@ 0x00000508) Pin select for SCL                                         */
  __IOM uint32_t  PSELSDA;                      /*!< (@ 0x0000050C) Pin select for SDA                                         */
  __IM  uint32_t  RESERVED13[2];
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency                                              */
  __IM  uint32_t  RESERVED15[24];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
  __IM  uint32_t  RESERVED16[668];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPIM1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 1 (SPIM1)
  */

typedef struct {                                /*!< (@ 0x40004000) SPIM1 Structure                                            */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000010) Start SPI transaction                                      */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop SPI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend SPI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume SPI transaction                                     */
  __IM  uint32_t  RESERVED2[56];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) SPI transaction has stopped                                */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) End of TXD buffer reached                                  */
  __IM  uint32_t  RESERVED5[10];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x0000014C) Transaction started                                        */
  __IM  uint32_t  RESERVED6[108];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPIM                                                */
  __IM  uint32_t  RESERVED8;
  __IOM SPIM1_PSEL_Type PSEL;                   /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED9;
  __IM  uint32_t  RXDDATA;                      /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXDDATA;                      /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency                                              */
  __IM  uint32_t  RESERVED11[3];
  __IOM SPIM1_RXD_Type RXD;                     /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED12;
  __IOM SPIM1_TXD_Type TXD;                     /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED14[26];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character clocked out in
                                                                    case and over-read of the TXD buffer.                      */
  __IM  uint32_t  RESERVED15[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIM_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPIS1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 1 (SPIS1)
  */

typedef struct {                                /*!< (@ 0x40004000) SPIS1 Structure                                            */
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;                /*!< (@ 0x00000024) Acquire SPI semaphore                                      */
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[54];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) Granted transaction completed                              */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  EVENTS_ACQUIRED;              /*!< (@ 0x00000128) Semaphore acquired                                         */
  __IM  uint32_t  RESERVED4[53];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[61];
  __IM  uint32_t  SEMSTAT;                      /*!< (@ 0x00000400) Semaphore status register                                  */
  __IM  uint32_t  RESERVED7[15];
  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000440) Status from last transaction                               */
  __IM  uint32_t  RESERVED8[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI slave                                           */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  PSELSCK;                      /*!< (@ 0x00000508) Pin select for SCK                                         */
  __IOM uint32_t  PSELMISO;                     /*!< (@ 0x0000050C) Pin select for MISO                                        */
  __IOM uint32_t  PSELMOSI;                     /*!< (@ 0x00000510) Pin select for MOSI                                        */
  __IOM uint32_t  PSELCSN;                      /*!< (@ 0x00000514) Pin select for CSN                                         */
  __IM  uint32_t  RESERVED10[7];
  __IOM uint32_t  RXDPTR;                       /*!< (@ 0x00000534) RXD data pointer                                           */
  __IOM uint32_t  MAXRX;                        /*!< (@ 0x00000538) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNTRX;                     /*!< (@ 0x0000053C) Number of bytes received in last granted transaction       */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  TXDPTR;                       /*!< (@ 0x00000544) TXD data pointer                                           */
  __IOM uint32_t  MAXTX;                        /*!< (@ 0x00000548) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNTTX;                     /*!< (@ 0x0000054C) Number of bytes transmitted in last granted transaction    */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED14[24];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character                                        */
  __IM  uint32_t  RESERVED15[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIS_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          GPIOTE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events (GPIOTE)
  */

typedef struct {                                /*!< (@ 0x40006000) GPIOTE Structure                                           */
  __OM  uint32_t  TASKS_OUT[4];                 /*!< (@ 0x00000000) Description collection[0]: Task for writing to
                                                                    pin specified in CONFIG[0].PSEL. Action
                                                                    on pin is configured in CONFIG[0].POLARITY.                */
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_IN[4];                 /*!< (@ 0x00000100) Description collection[0]: Event generated from
                                                                    pin specified in CONFIG[0].PSEL                            */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IM  uint32_t  RESERVED2[96];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[129];
  __IOM uint32_t  CONFIG[4];                    /*!< (@ 0x00000510) Description collection[0]: Configuration for
                                                                    OUT[n] task and IN[n] event                                */
  __IM  uint32_t  RESERVED4[695];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_GPIOTE_Type;                              /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter (ADC)
  */

typedef struct {                                /*!< (@ 0x40007000) ADC Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start a new ADC conversion                                 */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop ADC                                                   */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000100) An ADC conversion is completed                             */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[61];
  __IM  uint32_t  BUSY;                         /*!< (@ 0x00000400) ADC busy (conversion in progress)                          */
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable ADC. When enabled, the ADC will acquire
                                                                    access to the analog input pins specified
                                                                    in the CONFIG register.                                    */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) ADC configuration                                          */
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000508) Result of the previous ADC conversion                      */
  __IM  uint32_t  RESERVED4[700];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_ADC_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          TIMER0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0)
  */

typedef struct {                                /*!< (@ 0x40008000) TIMER0 Structure                                           */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start Timer                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop Timer                                                 */
  __OM  uint32_t  TASKS_COUNT;                  /*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x0000000C) Clear time                                                 */
  __OM  uint32_t  TASKS_SHUTDOWN;               /*!< (@ 0x00000010) Shut down timer                                            */
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[4];             /*!< (@ 0x00000040) Description collection[0]: Capture Timer value
                                                                    to CC[0] register                                          */
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection[0]: Compare event on CC[0]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[44];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED3[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[126];
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Timer mode selection                                       */
  __IOM uint32_t  BITMODE;                      /*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000510) Timer prescaler register                                   */
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection[0]: Capture/Compare register
                                                                    0                                                          */
  __IM  uint32_t  RESERVED7[431];
  __IOM uint32_t  FORCE1V2;                     /*!< (@ 0x00000C0C) Backdoor to force 1V2 supply to this peripheral            */
  __IM  uint32_t  RESERVED8[251];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TIMER_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           RTC0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real time counter 0 (RTC0)
  */

typedef struct {                                /*!< (@ 0x4000B000) RTC0 Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start RTC COUNTER                                          */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop RTC COUNTER                                           */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x00000008) Clear RTC COUNTER                                          */
  __OM  uint32_t  TASKS_TRIGOVRFLW;             /*!< (@ 0x0000000C) Set COUNTER to 0xFFFFF0                                    */
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_TICK;                  /*!< (@ 0x00000100) Event on COUNTER increment                                 */
  __IOM uint32_t  EVENTS_OVRFLW;                /*!< (@ 0x00000104) Event on COUNTER overflow                                  */
  __IM  uint32_t  RESERVED1[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection[0]: Compare event on CC[0]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[108];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[13];
  __IOM uint32_t  EVTEN;                        /*!< (@ 0x00000340) Enable or disable event routing                            */
  __IOM uint32_t  EVTENSET;                     /*!< (@ 0x00000344) Enable event routing                                       */
  __IOM uint32_t  EVTENCLR;                     /*!< (@ 0x00000348) Disable event routing                                      */
  __IM  uint32_t  RESERVED4[110];
  __IM  uint32_t  COUNTER;                      /*!< (@ 0x00000504) Current COUNTER value                                      */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Mu
                                                                    t be written when RTC is stopped                           */
  __IM  uint32_t  RESERVED5[13];
  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection[0]: Compare register 0              */
  __IM  uint32_t  RESERVED6[683];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RTC_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TEMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Temperature Sensor (TEMP)
  */

typedef struct {                                /*!< (@ 0x4000C000) TEMP Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start temperature measurement                              */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop temperature measurement                               */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_DATARDY;               /*!< (@ 0x00000100) Temperature measurement complete, data ready               */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[127];
  __IM  int32_t   TEMP;                         /*!< (@ 0x00000508) Temperature in degC (0.25deg steps)                        */
  __IOM uint32_t  RAW;                          /*!< (@ 0x0000050C) Raw data from temperature sensor                           */
  __IM  uint32_t  RESERVED3[699];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TEMP_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Random Number Generator (RNG)
  */

typedef struct {                                /*!< (@ 0x4000D000) RNG Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the random number generator                  */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the random number generator                  */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_VALRDY;                /*!< (@ 0x00000100) Event being generated for every new random number
                                                                    written to the VALUE register                              */
  __IM  uint32_t  RESERVED1[63];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[126];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IM  uint32_t  VALUE;                        /*!< (@ 0x00000508) Output random number                                       */
  __IM  uint32_t  RESERVED4[700];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RNG_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            ECB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES ECB Mode Encryption (ECB)
  */

typedef struct {                                /*!< (@ 0x4000E000) ECB Structure                                              */
  __OM  uint32_t  TASKS_STARTECB;               /*!< (@ 0x00000000) Start ECB block encrypt                                    */
  __OM  uint32_t  TASKS_STOPECB;                /*!< (@ 0x00000004) Abort a possible executing ECB operation                   */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_ENDECB;                /*!< (@ 0x00000100) ECB block encrypt complete                                 */
  __IOM uint32_t  EVENTS_ERRORECB;              /*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
                                                                    task or due to an error                                    */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[126];
  __IOM uint32_t  ECBDATAPTR;                   /*!< (@ 0x00000504) ECB block encrypt memory pointers                          */
  __IM  uint32_t  RESERVED3[701];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_ECB_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            CCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES CCM Mode Encryption (CCM)
  */

typedef struct {                                /*!< (@ 0x4000F000) CCM Structure                                              */
  __OM  uint32_t  TASKS_KSGEN;                  /*!< (@ 0x00000000) Start generation of key-stream. This operation
                                                                    will stop by itself when completed.                        */
  __OM  uint32_t  TASKS_CRYPT;                  /*!< (@ 0x00000004) Start encryption/decryption. This operation will
                                                                    stop by itself when completed.                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop encryption/decryption                                 */
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_ENDKSGEN;              /*!< (@ 0x00000100) Key-stream generation complete                             */
  __IOM uint32_t  EVENTS_ENDCRYPT;              /*!< (@ 0x00000104) Encrypt/decrypt complete                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000108) CCM error event                                            */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  MICSTATUS;                    /*!< (@ 0x00000400) MIC check result                                           */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable                                                     */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Operation mode                                             */
  __IOM uint32_t  CNFPTR;                       /*!< (@ 0x00000508) Pointer to data structure holding AES key and
                                                                    NONCE vector                                               */
  __IOM uint32_t  INPTR;                        /*!< (@ 0x0000050C) Input pointer                                              */
  __IOM uint32_t  OUTPTR;                       /*!< (@ 0x00000510) Output pointer                                             */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IM  uint32_t  RESERVED5[697];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_CCM_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            AAR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Accelerated Address Resolver (AAR)
  */

typedef struct {                                /*!< (@ 0x4000F000) AAR Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
                                                                    in the IRK data structure                                  */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop resolving addresses                                   */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000100) Address resolution procedure complete                      */
  __IOM uint32_t  EVENTS_RESOLVED;              /*!< (@ 0x00000104) Address resolved                                           */
  __IOM uint32_t  EVENTS_NOTRESOLVED;           /*!< (@ 0x00000108) Address not resolved                                       */
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Resolution status                                          */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable AAR                                                 */
  __IOM uint32_t  NIRK;                         /*!< (@ 0x00000504) Number of IRKs                                             */
  __IOM uint32_t  IRKPTR;                       /*!< (@ 0x00000508) Pointer to IRK data structure                              */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  ADDRPTR;                      /*!< (@ 0x00000510) Pointer to the resolvable address                          */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IM  uint32_t  RESERVED6[697];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_AAR_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer (WDT)
  */

typedef struct {                                /*!< (@ 0x40010000) WDT Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the watchdog                                         */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop the watchdog timer. Only available in timer
                                                                    mode.                                                      */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_TIMEOUT;               /*!< (@ 0x00000100) Watchdog timeout                                           */
  __IM  uint32_t  RESERVED1[128];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED2[61];
  __IM  uint32_t  RUNSTATUS;                    /*!< (@ 0x00000400) Run status                                                 */
  __IM  uint32_t  REQSTATUS;                    /*!< (@ 0x00000404) Request status                                             */
  __IOM uint32_t  RCNT;                         /*!< (@ 0x00000408) Reload count                                               */
  __IM  uint32_t  RESERVED3[62];
  __IOM uint32_t  CRV;                          /*!< (@ 0x00000504) Counter reload value                                       */
  __IOM uint32_t  RREN;                         /*!< (@ 0x00000508) Enable register for reload request registers               */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000050C) Configuration register                                     */
  __IM  uint32_t  RESERVED4[60];
  __OM  uint32_t  RR[8];                        /*!< (@ 0x00000600) Description collection[0]: Reload request 0                */
  __IM  uint32_t  RESERVED5[631];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_WDT_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           QDEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder (QDEC)
  */

typedef struct {                                /*!< (@ 0x40012000) QDEC Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the quadrature decoder                       */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
  __OM  uint32_t  TASKS_READCLRACC;             /*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;             /*!< (@ 0x00000104) Non-null report ready                                      */
  __IOM uint32_t  EVENTS_ACCOF;                 /*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable the quadrature decoder                              */
  __IOM uint32_t  LEDPOL;                       /*!< (@ 0x00000504) LED output pin polarity                                    */
  __IOM uint32_t  SAMPLEPER;                    /*!< (@ 0x00000508) Sample period                                              */
  __IM  int32_t   SAMPLE;                       /*!< (@ 0x0000050C) Motion sample value                                        */
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before a REPORTRDY
                                                                    event can be generated                                     */
  __IM  int32_t   ACC;                          /*!< (@ 0x00000514) Register accumulating the valid transitions                */
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC task                                            */
  __IOM uint32_t  PSELLED;                      /*!< (@ 0x0000051C) GPIO pin number to be used as LED output                   */
  __IOM uint32_t  PSELA;                        /*!< (@ 0x00000520) GPIO pin number to be used as Phase A input                */
  __IOM uint32_t  PSELB;                        /*!< (@ 0x00000524) GPIO pin number to be used as Phase B input                */
  __IOM uint32_t  DBFEN;                        /*!< (@ 0x00000528) Enable input debounce filters                              */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  LEDPRE;                       /*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    task                                                       */
  __IM  uint32_t  RESERVED5[684];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_QDEC_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          LPCOMP                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low Power Comparator (LPCOMP)
  */

typedef struct {                                /*!< (@ 0x40013000) LPCOMP Structure                                           */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) LPCOMP is ready and output is valid                        */
  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcut register                                          */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable LPCOMP                                              */
  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Input pin select                                           */
  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference select                                           */
  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
  __IM  uint32_t  RESERVED5[4];
  __IOM uint32_t  ANADETECT;                    /*!< (@ 0x00000520) Analog detect configuration                                */
  __IM  uint32_t  RESERVED6[694];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_LPCOMP_Type;                              /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Software interrupt 0 (SWI0)
  */

typedef struct {                                /*!< (@ 0x40014000) SWI0 Structure                                             */
  __IM  uint32_t  UNUSED;                       /*!< (@ 0x00000000) Unused.                                                    */
} NRF_SWI_Type;                                 /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           NVMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Non Volatile Memory Controller (NVMC)
  */

typedef struct {                                /*!< (@ 0x4001E000) NVMC Structure                                             */
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;                        /*!< (@ 0x00000400) Ready flag                                                 */
  __IM  uint32_t  RESERVED1[64];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  
  union {
    __IOM uint32_t ERASEPAGE;                   /*!< (@ 0x00000508) Register for erasing a page in Code area                   */
    __IOM uint32_t ERASEPCR1;                   /*!< (@ 0x00000508) Register for erasing a page in Code region 1.
                                                                    Equivalent to ERASEPAGE.                                   */
  };
  __IOM uint32_t  ERASEALL;                     /*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
  __IOM uint32_t  ERASEPCR0;                    /*!< (@ 0x00000510) Register for erasing a page in Code region 0               */
  __IOM uint32_t  ERASEUICR;                    /*!< (@ 0x00000514) Register for erasing User Information Configuration
                                                                    Registers                                                  */
  __IM  uint32_t  RESERVED2[58];
  __IOM uint32_t  TESTMODE;                     /*!< (@ 0x00000600) Register for entering test mode. Refer to the
                                                                    flash IP test documentation for more details.              */
  __IOM uint32_t  TESTCONTROL;                  /*!< (@ 0x00000604) Direct flash test, control lines. Not used for
                                                                    XLR3LC (uses TESTCTRLLINES and TESTCTRLADDR
                                                                    instead)                                                   */
  __IOM uint32_t  TESTDATA;                     /*!< (@ 0x00000608) Direct flash test data                                     */
  __IOM uint32_t  UNUSED0;                      /*!< (@ 0x0000060C) Unspecified                                                */
  __OM  uint32_t  TESTMASSERASE;                /*!< (@ 0x00000610) Self-timed mass-erase operation                            */
  __OM  uint32_t  TESTERASEREFCELL;             /*!< (@ 0x00000614) Self-timed erase reference cell operation. Not
                                                                    used in XLR3LC.                                            */
  __IM  uint32_t  RESERVED3[10];
  __IM  uint32_t  TESTCMPINC;                   /*!< (@ 0x00000640) XLR3LC only: Reads and compares last flash data
                                                                    to TESTDATA content. Post-increments TESTCONTROLADDR.      */
  __IM  uint32_t  TESTNCMPINC;                  /*!< (@ 0x00000644) XLR3LC only: Reads and compares last flash data
                                                                    to complement of TESTDATA content. Post-increments
                                                                    TESTCONTROLADDR.                                           */
  __IOM uint32_t  TESTCTRLLINESESF1;            /*!< (@ 0x00000648) XLR3LC with ESF1 flash IP only. Direct flash
                                                                    test, control lines. Refer to the flash
                                                                    IP test documentation (4402_042) for more
                                                                    details.                                                   */
  __IOM uint32_t  TESTCTRLADDRESF1;             /*!< (@ 0x0000064C) XLR3LC with ESF1 flash IP only. Direct flash
                                                                    test control, address lines                                */
} NRF_NVMC_Type;                                /*!< Size = 1616 (0x650)                                                       */



/* =========================================================================================================================== */
/* ================                                            PPI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable Peripheral Interconnect (PPI)
  */

typedef struct {                                /*!< (@ 0x4001F000) PPI Structure                                              */
  __IOM PPI_TASKS_CHG_Type TASKS_CHG[4];        /*!< (@ 0x00000000) Channel group tasks                                        */
  __IM  uint32_t  RESERVED[312];
  __IOM uint32_t  CHEN;                         /*!< (@ 0x00000500) Channel enable register                                    */
  __IOM uint32_t  CHENSET;                      /*!< (@ 0x00000504) Channel enable set register                                */
  __IOM uint32_t  CHENCLR;                      /*!< (@ 0x00000508) Channel enable clear register                              */
  __IM  uint32_t  RESERVED1;
  __IOM PPI_CH_Type CH[16];                     /*!< (@ 0x00000510) PPI Channel                                                */
  __IM  uint32_t  RESERVED2[156];
  __IOM uint32_t  CHG[4];                       /*!< (@ 0x00000800) Description collection[0]: Channel group 0                 */
} NRF_PPI_Type;                                 /*!< Size = 2064 (0x810)                                                       */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (GPIO)
  */

typedef struct {                                /*!< (@ 0x50000000) GPIO Structure                                             */
  __IM  uint32_t  RESERVED[321];
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000504) Write GPIO port                                            */
  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000508) Set individual bits in GPIO port                           */
  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */
  __IM  uint32_t  IN;                           /*!< (@ 0x00000510) Read GPIO port                                             */
  __IOM uint32_t  DIR;                          /*!< (@ 0x00000514) Direction of GPIO pins                                     */
  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000518) DIR set register                                           */
  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000051C) DIR clear register                                         */
  __IM  uint32_t  RESERVED1[56];
  __IOM GPIO_PIN_Type PIN[32];                  /*!< (@ 0x00000600) Pin 0 direct access                                        */
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection[0]: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;                                /*!< Size = 1920 (0x780)                                                       */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_FICR_BASE               0x10000000UL
#define NRF_UICR_BASE               0x10001000UL
#define NRF_MPU_BASE                0x40000000UL
#define NRF_POWER_BASE              0x40000000UL
#define NRF_CLOCK_BASE              0x40000000UL
#define NRF_AMLI_BASE               0x40000000UL
#define NRF_RADIO_BASE              0x40001000UL
#define NRF_UART0_BASE              0x40002000UL
#define NRF_SPI0_BASE               0x40003000UL
#define NRF_TWI0_BASE               0x40003000UL
#define NRF_SPI1_BASE               0x40004000UL
#define NRF_SPIM1_BASE              0x40004000UL
#define NRF_SPIS1_BASE              0x40004000UL
#define NRF_TWI1_BASE               0x40004000UL
#define NRF_GPIOTE_BASE             0x40006000UL
#define NRF_ADC_BASE                0x40007000UL
#define NRF_TIMER0_BASE             0x40008000UL
#define NRF_TIMER1_BASE             0x40009000UL
#define NRF_TIMER2_BASE             0x4000A000UL
#define NRF_RTC0_BASE               0x4000B000UL
#define NRF_TEMP_BASE               0x4000C000UL
#define NRF_RNG_BASE                0x4000D000UL
#define NRF_ECB_BASE                0x4000E000UL
#define NRF_CCM_BASE                0x4000F000UL
#define NRF_AAR_BASE                0x4000F000UL
#define NRF_WDT_BASE                0x40010000UL
#define NRF_RTC1_BASE               0x40011000UL
#define NRF_QDEC_BASE               0x40012000UL
#define NRF_LPCOMP_BASE             0x40013000UL
#define NRF_SWI0_BASE               0x40014000UL
#define NRF_SWI1_BASE               0x40015000UL
#define NRF_SWI2_BASE               0x40016000UL
#define NRF_SWI3_BASE               0x40017000UL
#define NRF_SWI4_BASE               0x40018000UL
#define NRF_SWI5_BASE               0x40019000UL
#define NRF_NVMC_BASE               0x4001E000UL
#define NRF_PPI_BASE                0x4001F000UL
#define NRF_GPIO_BASE               0x50000000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
#define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
#define NRF_MPU                     ((NRF_MPU_Type*)           NRF_MPU_BASE)
#define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
#define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
#define NRF_AMLI                    ((NRF_AMLI_Type*)          NRF_AMLI_BASE)
#define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
#define NRF_UART0                   ((NRF_UART_Type*)          NRF_UART0_BASE)
#define NRF_SPI0                    ((NRF_SPI_Type*)           NRF_SPI0_BASE)
#define NRF_TWI0                    ((NRF_TWI_Type*)           NRF_TWI0_BASE)
#define NRF_SPI1                    ((NRF_SPI_Type*)           NRF_SPI1_BASE)
#define NRF_SPIM1                   ((NRF_SPIM_Type*)          NRF_SPIM1_BASE)
#define NRF_SPIS1                   ((NRF_SPIS_Type*)          NRF_SPIS1_BASE)
#define NRF_TWI1                    ((NRF_TWI_Type*)           NRF_TWI1_BASE)
#define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
#define NRF_ADC                     ((NRF_ADC_Type*)           NRF_ADC_BASE)
#define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
#define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
#define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
#define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
#define NRF_TEMP                    ((NRF_TEMP_Type*)          NRF_TEMP_BASE)
#define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
#define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
#define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
#define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
#define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
#define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
#define NRF_QDEC                    ((NRF_QDEC_Type*)          NRF_QDEC_BASE)
#define NRF_LPCOMP                  ((NRF_LPCOMP_Type*)        NRF_LPCOMP_BASE)
#define NRF_SWI0                    ((NRF_SWI_Type*)           NRF_SWI0_BASE)
#define NRF_SWI1                    ((NRF_SWI_Type*)           NRF_SWI1_BASE)
#define NRF_SWI2                    ((NRF_SWI_Type*)           NRF_SWI2_BASE)
#define NRF_SWI3                    ((NRF_SWI_Type*)           NRF_SWI3_BASE)
#define NRF_SWI4                    ((NRF_SWI_Type*)           NRF_SWI4_BASE)
#define NRF_SWI5                    ((NRF_SWI_Type*)           NRF_SWI5_BASE)
#define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
#define NRF_PPI                     ((NRF_PPI_Type*)           NRF_PPI_BASE)
#define NRF_GPIO                    ((NRF_GPIO_Type*)          NRF_GPIO_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* NRF51_H */


/** @} */ /* End of group nrf51 */

/** @} */ /* End of group Nordic Semiconductor */
