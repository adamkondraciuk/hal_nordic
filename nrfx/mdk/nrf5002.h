/*
 * Copyright (c) 2010 - 2020, Nordic Semiconductor ASAAll rights reserved.Redistribution and use in sou
 * rce and binary forms, with or without modification,are permitted provided that the following conditi
 * ons are met:1. Redistributions of source code must retain the above copyright notice, this list of c
 * onditions and the following disclaimer.2. Redistributions in binary form, except as embedded into a 
 * Nordic Semiconductor ASA integrated circuit in a product or a software update for such product, must
 * reproduce the above copyright notice, this list of conditions and the following disclaimer in the d
 * ocumentation and/or other materials provided with the distribution.3. Neither the name of Nordic Sem
 * iconductor ASA nor the names of its contributors may be used to endorse or promote products derived 
 * from this software without specific prior written permission.4. This software, with or without modif
 * ication, must only be used with a Nordic Semiconductor ASA integrated circuit.5. Any software provid
 * ed in binary form under this license must not be reverse engineered, decompiled, modified and/or dis
 * assembled.THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESSOR IMPLIED WA
 * RRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIESOF MERCHANTABILITY, NONINFRINGEMENT, 
 * AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CO
 * NTRIBUTORS BELIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGE
 * S (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTEGOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT
 * , STRICTLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUTOF THE USE OF T
 * HIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf5002.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     14. August 2020
 * @note     Generated by SVDConv V3.3.35 on Friday, 14.08.2020 15:11:30
 *           from File 'nrf5002.svd',
 *           last modified on Friday, 14.08.2020 13:11:17
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf5002
  * @{
  */


#ifndef NRF5002_H
#define NRF5002_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  nrf5002 Specific Interrupt Numbers  =========================================== */
  CLOCK_POWER_IRQn          =   0,              /*!< 0  CLOCK_POWER                                                            */
  RADIO_IRQn                =   2,              /*!< 2  RADIO                                                                  */
  RNG_IRQn                  =   3,              /*!< 3  RNG                                                                    */
  GPIOTE_IRQn               =   4,              /*!< 4  GPIOTE                                                                 */
  WDT_IRQn                  =   5,              /*!< 5  WDT                                                                    */
  TIMER0_IRQn               =   6,              /*!< 6  TIMER0                                                                 */
  TIMER1_IRQn               =   7,              /*!< 7  TIMER1                                                                 */
  TIMER2_IRQn               =   8,              /*!< 8  TIMER2                                                                 */
  ECB_IRQn                  =   9,              /*!< 9  ECB                                                                    */
  AAR_CCM_IRQn              =  10,              /*!< 10 AAR_CCM                                                                */
  RTC0_IRQn                 =  12,              /*!< 12 RTC0                                                                   */
  RTC1_IRQn                 =  13,              /*!< 13 RTC1                                                                   */
  SPIM0_SPIS0_UARTE0_IRQn   =  14,              /*!< 14 SPIM0_SPIS0_UARTE0                                                     */
  TWIM1_TWIS1_IRQn          =  15,              /*!< 15 TWIM1_TWIS1                                                            */
  QDEC0_IRQn                =  18,              /*!< 18 QDEC0                                                                  */
  SAADC_IRQn                =  20,              /*!< 20 SAADC                                                                  */
  EGU0_IRQn                 =  23               /*!< 23 EGU0                                                                   */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M0 Processor and Core Peripherals  =========================== */
#define __CM0_REV                 0x0004U       /*!< CM0 Core Revision                                                         */
#define __DSP_PRESENT                  0        /*!< DSP present or not                                                        */
#define __VTOR_PRESENT                 0        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  0        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */
#define __SAUREGION_PRESENT            0        /*!< SAU region present                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm0.h"                           /*!< ARM Cortex-M0 processor and core peripherals                              */
#include "system_nrf5002.h"                     /*!< nrf5002 System                                                            */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief FICR_SOCINFO [SOCINFO] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  PARTNO;                       /*!< (@ 0x00000000) Part number of the device.                                 */
  __IM  uint32_t  HWREVISION;                   /*!< (@ 0x00000004) Hardware Revision of the device. Will be updated
                                                                    in production test.                                        */
  __IM  uint32_t  PRODUCTIONREVISION;           /*!< (@ 0x00000008) Production revision of the device. Will be updated
                                                                    in production test.                                        */
} FICR_SOCINFO_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  CONFIGID;                     /*!< (@ 0x00000000) Configuration identifier                                   */
  __IM  uint32_t  DEVICEID[2];                  /*!< (@ 0x00000004) Description collection: Device identifier                  */
  __IM  uint32_t  PART;                         /*!< (@ 0x0000000C) Part code                                                  */
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000010) Part Variant, Hardware version and Production
                                                                    configuration                                              */
  __IM  uint32_t  PACKAGE;                      /*!< (@ 0x00000014) Package option                                             */
  __IM  uint32_t  RAM;                          /*!< (@ 0x00000018) RAM variant                                                */
  __IM  uint32_t  MTP;                          /*!< (@ 0x0000001C) MTP variant                                                */
  __IM  uint32_t  CODEPAGESIZE;                 /*!< (@ 0x00000020) Code memory page size in bytes                             */
  __IM  uint32_t  CODESIZE;                     /*!< (@ 0x00000024) Code memory size                                           */
  __IM  uint32_t  DEVICETYPE;                   /*!< (@ 0x00000028) Device type                                                */
} FICR_INFO_Type;                               /*!< Size = 44 (0x2c)                                                          */


/**
  * @brief PAMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  SERIAL0;                      /*!< (@ 0x00000000) AHB bus master priority register for SPIM0, SPIS0,
                                                                    TWIM0, TWIS0 and UARTE0                                    */
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  RADIO;                        /*!< (@ 0x0000000C) AHB bus master priority register for RADIO                 */
  __IOM uint32_t  ECB;                          /*!< (@ 0x00000010) AHB bus master priority register for ECB                   */
  __IOM uint32_t  CCM;                          /*!< (@ 0x00000014) AHB bus master priority register for CCM                   */
  __IOM uint32_t  AAR;                          /*!< (@ 0x00000018) AHB bus master priority register for AAR                   */
  __IOM uint32_t  PWM;                          /*!< (@ 0x0000001C) AHB bus master priority register for PWM0                  */
} PAMLI_RAMPRI_Type;                            /*!< Size = 32 (0x20)                                                          */


/**
  * @brief VMC_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000000) Description cluster: RAM[n] power control register         */
  __IOM uint32_t  POWERSET;                     /*!< (@ 0x00000004) Description cluster: RAM[n] power control set
                                                                    register                                                   */
  __IOM uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAM[n] power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} VMC_RAM_Type;                                 /*!< Size = 16 (0x10)                                                          */


/**
  * @brief RAMBIST_STATUS [STATUS] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  BIST;                         /*!< (@ 0x00000000) Status of the BIST                                         */
  __IM  uint32_t  FAULTY;                       /*!< (@ 0x00000004) Which blocks are failing the test                          */
} RAMBIST_STATUS_Type;                          /*!< Size = 8 (0x8)                                                            */


/**
  * @brief RAMBIST_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RAMBIST;                      /*!< (@ 0x00000000) Configuration of the RamBist itself. When none
                                                                    of the fields are set, it runs the standard
                                                                    production test BIST.                                      */
  __IOM uint32_t  RAM;                          /*!< (@ 0x00000004) Override of the RAM configuration                          */
  __IOM uint32_t  CLAMP;                        /*!< (@ 0x00000008) Clamp/Exclude certain blocks from the test                 */
} RAMBIST_CONFIG_Type;                          /*!< Size = 12 (0xc)                                                           */


/**
  * @brief AMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  CPU;                          /*!< (@ 0x00000000) AHB bus master priority register for CPU                   */
  __IOM uint32_t  PERI;                         /*!< (@ 0x00000004) AHB bus master priority register for periperals            */
  __IOM uint32_t  USB;                          /*!< (@ 0x00000008) AHB bus master priority register for USB                   */
  __IOM uint32_t  CTRLAP;                       /*!< (@ 0x0000000C) AHB bus master priority register for CTRL-AP               */
} AMLI_RAMPRI_Type;                             /*!< Size = 16 (0x10)                                                          */


/**
  * @brief GPIO_PIN [PIN] (Pin n direct access)
  */
typedef struct {
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000000) Description cluster: Pin n direct access output
                                                                    register                                                   */
  __IOM uint32_t  IN;                           /*!< (@ 0x00000004) Description cluster: Pin n direct access input
                                                                    register                                                   */
} GPIO_PIN_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief OSCILLATORS_PLL64M [PLL64M] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) PLL64M bypass control                                      */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x00000004) Mute the PLL64M                                            */
  __IOM uint32_t  PROGCHPUMP;                   /*!< (@ 0x00000008) Program charge pump current                                */
  __IOM uint32_t  VCOTRIM;                      /*!< (@ 0x0000000C) VCO trim value for the 64 MHz PLL                          */
  __IOM uint32_t  VCOTRIMOVERRIDE;              /*!< (@ 0x00000010) Control overriding of the VCO trim values                  */
} OSCILLATORS_PLL64M_Type;                      /*!< Size = 20 (0x14)                                                          */


/**
  * @brief REGULATORS_VREGANA [VREGANA] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VOUT;                         /*!< (@ 0x00000000) Control the output voltage                                 */
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000004) Enable DC/DC operation of the regulator                    */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000008) Enable forcing of power mode in power regulator            */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x0000000C) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000010) Current mode in the power regulator                        */
  __IOM uint32_t  TESTLOAD;                     /*!< (@ 0x00000014) Test load setting                                          */
  __IOM uint32_t  ULPCAL;                       /*!< (@ 0x00000018) Calibration of ULP regulator                               */
  __IOM uint32_t  DEBUGLVLP;                    /*!< (@ 0x0000001C) Debug register - control spare signals in LVLP             */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  BUCKCALMAXILIM;               /*!< (@ 0x00000024) TBD                                                        */
  __IOM uint32_t  BUCKCALPWM;                   /*!< (@ 0x00000028) TBD                                                        */
  __IOM uint32_t  BUCKPFMEN;                    /*!< (@ 0x0000002C) PFM enable register                                        */
  __IOM uint32_t  BUCKPFMCAL;                   /*!< (@ 0x00000030) TBD                                                        */
  __IOM uint32_t  BUCKPFMICMPCAL;               /*!< (@ 0x00000034) TBD                                                        */
  __IOM uint32_t  BUCKPFMICMPCOUNT;             /*!< (@ 0x00000038) TBD                                                        */
  __IOM uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x0000003C) Set threshold value of power regulator                     */
  __IOM uint32_t  AVOIDULP;                     /*!< (@ 0x00000040) Backdoor to avoid ULP mode                                 */
} REGULATORS_VREGANA_Type;                      /*!< Size = 68 (0x44)                                                          */


/**
  * @brief REGULATORS_VREGMAIN [VREGMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VOUT;                         /*!< (@ 0x00000000) Control the output voltage                                 */
  __IOM uint32_t  ULPALWAYSON;                  /*!< (@ 0x00000004) Keep ULP regulator on at all times                         */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000008) Enable forcing of power mode in power regulator            */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x0000000C) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000010) Current mode in the power regulator                        */
  __IOM uint32_t  PWRREGICMPTIMER;              /*!< (@ 0x00000014) Control the stay-alive time for the current comparator     */
  __IOM uint32_t  TESTLOAD;                     /*!< (@ 0x00000018) Test load setting                                          */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  ULPCAL;                       /*!< (@ 0x00000020) Calibration of ULP regulator                               */
  __IOM uint32_t  ULPICMPCAL;                   /*!< (@ 0x00000024) Calibration of current comparator on ULP regulator         */
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000028) Bypass control                                             */
} REGULATORS_VREGMAIN_Type;                     /*!< Size = 44 (0x2c)                                                          */


/**
  * @brief RADIO_DEBUGPSEL [DEBUGPSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLOCK;                        /*!< (@ 0x00000000) Pin select for RADIO clock (direct mode, base
                                                                    band debug. Refer to digip_064 and digip_061,
                                                                    txCk and ckDataIn signals)                                 */
  __IOM uint32_t  DATA;                         /*!< (@ 0x00000004) Pin select for RADIO data (direct mode, base
                                                                    band debug. Refer to digip_064 and digip_061,
                                                                    txRadioData and dataIn signals)                            */
} RADIO_DEBUGPSEL_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief RADIO_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DFEGPIO[8];                   /*!< (@ 0x00000000) Description collection: Pin select for DFE pin
                                                                    n                                                          */
} RADIO_PSEL_Type;                              /*!< Size = 32 (0x20)                                                          */


/**
  * @brief RADIO_DFEPACKET [DFEPACKET] (DFE packet EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of buffer words to transfer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of samples transferred in the last transaction      */
} RADIO_DFEPACKET_Type;                         /*!< Size = 12 (0xc)                                                           */


/**
  * @brief RADIO_ACQDMA [ACQDMA] (EasyDMA channel for data acquisition (refer to 4378_164))
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) EasyDMA pointer for data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 32-bit words to transfer (refer
                                                                    to 4378_164)                                               */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 32-bit words transferred in the last
                                                                    transaction (refer to 4378_164)                            */
} RADIO_ACQDMA_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief GPIOTE_TASKS_PCPPEN [TASKS_PCPPEN] (Peripheral tasks.)
  */
typedef struct {
  __OM  uint32_t  LOW;                          /*!< (@ 0x00000000) Description cluster: Configure PCP[n] requests
                                                                    to have lowest possible penalty                            */
  __OM  uint32_t  HIGH;                         /*!< (@ 0x00000004) Description cluster: Configure PCP[n] requests
                                                                    to have highest possible penalty                           */
} GPIOTE_TASKS_PCPPEN_Type;                     /*!< Size = 8 (0x8)                                                            */


/**
  * @brief GPIOTE_SUBSCRIBE_PCPPEN [SUBSCRIBE_PCPPEN] (Subscribe configuration for tasks)
  */
typedef struct {
  __IOM uint32_t  LOW;                          /*!< (@ 0x00000000) Description cluster: Subscribe configuration
                                                                    for task PCPPEN[n].LOW                                     */
  __IOM uint32_t  HIGH;                         /*!< (@ 0x00000004) Description cluster: Subscribe configuration
                                                                    for task PCPPEN[n].HIGH                                    */
} GPIOTE_SUBSCRIBE_PCPPEN_Type;                 /*!< Size = 8 (0x8)                                                            */


/**
  * @brief DPPIC_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Enable channel group n                */
  __OM  uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Disable channel group n               */
} DPPIC_TASKS_CHG_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief DPPIC_SUBSCRIBE_CHG [SUBSCRIBE_CHG] (Subscribe configuration for tasks)
  */
typedef struct {
  __IOM uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Subscribe configuration
                                                                    for task CHG[n].EN                                         */
  __IOM uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Subscribe configuration
                                                                    for task CHG[n].DIS                                        */
} DPPIC_SUBSCRIBE_CHG_Type;                     /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN                                         */
} SPIM_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of bytes in transmit buffer                         */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RXDELAY;                      /*!< (@ 0x00000000) Sample delay for input serial data on MISO                 */
  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
                                                                    of SCK and minimum duration CSN must stay
                                                                    high between transactions                                  */
} SPIM_IFTIMING_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000004) Pin select for MISO signal                                 */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000008) Pin select for MOSI signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN signal                                  */
} SPIS_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes received in last granted transaction       */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transmitted in last granted transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS signal                                  */
  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD signal                                  */
  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS signal                                  */
  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD signal                                  */
} UARTE_PSEL_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_RXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_TXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIM_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIS_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in RXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last RXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in TXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last TXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief QDEC_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LED;                          /*!< (@ 0x00000000) Pin select for LED signal                                  */
  __IOM uint32_t  A;                            /*!< (@ 0x00000004) Pin select for A signal                                    */
  __IOM uint32_t  B;                            /*!< (@ 0x00000008) Pin select for B signal                                    */
} QDEC_PSEL_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last results is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last results is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_PUBLISH_CH [PUBLISH_CH] (Publish configuration for events)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITH                                         */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITL                                         */
} SAADC_PUBLISH_CH_Type;                        /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring a channel                                       */
} SAADC_CH_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of buffer words to transfer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of buffer words transferred since last
                                                                    START                                                      */
} SAADC_RESULT_Type;                            /*!< Size = 12 (0xc)                                                           */


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           FICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory Information Configuration Registers (FICR)
  */

typedef struct {                                /*!< (@ 0x10000000) FICR Structure                                             */
  __IOM uint32_t  CHIPCONF00;                   /*!< (@ 0x00000000) Unspecified                                                */
  __IOM uint32_t  CHIPCONF01;                   /*!< (@ 0x00000004) Unspecified                                                */
  __IOM uint32_t  CHIPCONF02;                   /*!< (@ 0x00000008) Unspecified                                                */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  CHIPCONF03;                   /*!< (@ 0x00000010) Unspecified                                                */
  __IOM uint32_t  CHIPCONF04;                   /*!< (@ 0x00000014) Unspecified                                                */
  __IM  uint32_t  RESERVED1[70];
  __IOM FICR_SOCINFO_Type SOCINFO;              /*!< (@ 0x00000130) Unspecified                                                */
  __IM  uint32_t  RESERVED2[49];
  __IOM FICR_INFO_Type INFO;                    /*!< (@ 0x00000200) Device info                                                */
} NRF_FICR_Type;                                /*!< Size = 556 (0x22c)                                                        */



/* =========================================================================================================================== */
/* ================                                           UICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief User Information Configuration Registers (UICR)
  */

typedef struct {                                /*!< (@ 0x10001000) UICR Structure                                             */
  __IOM uint32_t  APPROTECT;                    /*!< (@ 0x00000000) Access port protection                                     */
  __IM  uint32_t  RESERVED[8];
  __IOM uint32_t  TINSTANCE;                    /*!< (@ 0x00000024) SW-DP Target instance                                      */
  __IOM uint32_t  PSELRESET[2];                 /*!< (@ 0x00000028) Description collection: Mapping of the nRESET
                                                                    function (see POWER chapter for details)                   */
} NRF_UICR_Type;                                /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           PAMLI                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Peripheral AHB Multi-Layer Interface (PAMLI)
  */

typedef struct {                                /*!< (@ 0x40020000) PAMLI Structure                                            */
  __IM  uint32_t  RESERVED[896];
  __IOM PAMLI_RAMPRI_Type RAMPRI;               /*!< (@ 0x00000E00) RAM configurable priority configuration structure          */
} NRF_PAMLI_Type;                               /*!< Size = 3616 (0xe20)                                                       */



/* =========================================================================================================================== */
/* ================                                            VMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Volatile Memory controller (VMC)
  */

typedef struct {                                /*!< (@ 0x40022000) VMC Structure                                              */
  __IM  uint32_t  RESERVED[384];
  __IOM VMC_RAM_Type RAM[2];                    /*!< (@ 0x00000600) Unspecified                                                */
} NRF_VMC_Type;                                 /*!< Size = 1568 (0x620)                                                       */



/* =========================================================================================================================== */
/* ================                                           NVMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Non Volatile Memory Controller (NVMC)
  */

typedef struct {                                /*!< (@ 0x40023000) NVMC Structure                                             */
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;                        /*!< (@ 0x00000400) Ready flag                                                 */
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;                    /*!< (@ 0x00000408) Ready flag                                                 */
  __IM  uint32_t  TESTWORDSTATE;                /*!< (@ 0x0000040C) Test word status                                           */
  __IM  uint32_t  RESERVED2[61];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __OM  uint32_t  ERASEPAGE;                    /*!< (@ 0x00000508) Register for erasing a page in code area                   */
  __OM  uint32_t  ERASEALL;                     /*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  ERASEUICR;                    /*!< (@ 0x00000514) Register for erasing whole UICR page                       */
  __IM  uint32_t  RESERVED4[6];
  __IOM uint32_t  WAITSTATENUM;                 /*!< (@ 0x00000530) Register to set the number of wait-state for
                                                                    non-volatile memory access. To update the
                                                                    WAITSTATENUM field, the ACCESSCODE must
                                                                    be correct.                                                */
  __OM  uint32_t  TESTWORD;                     /*!< (@ 0x00000534) Test the programming state of the least significant
                                                                    bit in a word                                              */
  __IM  uint32_t  RESERVED5[10];
  __IOM uint32_t  VSELREAD;                     /*!< (@ 0x00000560) Select output voltage of power generator for
                                                                    read mode                                                  */
  __IOM uint32_t  VSELWRITE;                    /*!< (@ 0x00000564) Select output voltage of power generator for
                                                                    write mode                                                 */
  __IOM uint32_t  VSELERASE;                    /*!< (@ 0x00000568) Select output voltage of power generator for
                                                                    erase mode                                                 */
  __IM  uint32_t  RESERVED6[37];
  __IOM uint32_t  TESTMODE;                     /*!< (@ 0x00000600) Register for entering test mode. Refer to the
                                                                    MTP IP test documentation for more details.                */
  __IM  uint32_t  RESERVED7[3];
  __OM  uint32_t  TESTMASSERASE;                /*!< (@ 0x00000610) Self-timed mass-erase operation                            */
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  TESTDATA128[2];               /*!< (@ 0x00000620) Description collection: Direct MTP test data
                                                                    word n                                                     */
  __IM  uint32_t  RESERVED9[2];
  __IM  uint32_t  TESTDATA128INC[2];            /*!< (@ 0x00000630) Description collection: Direct MTP test data
                                                                    word n. Post-increments TESTCONTROLADDR                    */
  __IM  uint32_t  RESERVED10[2];
  __IM  uint32_t  TESTCMPINC;                   /*!< (@ 0x00000640) Reads and compares last MTP row to TESTDATA128
                                                                    content. Post-increments TESTCONTROLADDR.                  */
  __IM  uint32_t  TESTNCMPINC;                  /*!< (@ 0x00000644) Reads and compares last MTP row to complement
                                                                    of TESTDATA128 content. Post-increments
                                                                    TESTCONTROLADDR.                                           */
  __IOM uint32_t  TESTCONTROLLINES;             /*!< (@ 0x00000648) Direct MTP test, control lines. Refer to the
                                                                    MTP IP documentation for more details.                     */
  __IOM uint32_t  TESTCONTROLADDR;              /*!< (@ 0x0000064C) Direct MTP test control, address lines                     */
  __IOM uint32_t  TESTCOUNTERRELOAD;            /*!< (@ 0x00000650) Counter reload value, used when counting from
                                                                    CE rising edge to latching of data                         */
  __IM  uint32_t  TESTCOUNTERRUNNING;           /*!< (@ 0x00000654) Returns the state (counting or not) of the counter         */
  __IOM uint32_t  TESTCONFIG;                   /*!< (@ 0x00000658) Mode of operation of the counter                           */
  __IOM uint32_t  TESTMEASVPPEN;                /*!< (@ 0x0000065C) Controls analog signals for MTP measurements               */
  __IOM uint32_t  TESTPOWERCONTROL;             /*!< (@ 0x00000660) Direct test, control lines to the MTP power generator
                                                                    module. Refer to the MTP IP documentation
                                                                    for more details.                                          */
  __IM  uint32_t  RESERVED11[39];
  __IOM uint32_t  FORCEONNVM;                   /*!< (@ 0x00000700) Force on NVM supply                                        */
  __IM  uint32_t  RESERVED12[9];
  __IOM uint32_t  FORCEOFFNVM;                  /*!< (@ 0x00000728) Force off NVM supply                                       */
} NRF_NVMC_Type;                                /*!< Size = 1836 (0x72c)                                                       */



/* =========================================================================================================================== */
/* ================                                           BPROT                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Block Protect (BPROT)
  */

typedef struct {                                /*!< (@ 0x40024000) BPROT Structure                                            */
  __IM  uint32_t  RESERVED[384];
  __IOM uint32_t  CONFIG0;                      /*!< (@ 0x00000600) Block protect configuration register 0                     */
  __IOM uint32_t  CONFIG1;                      /*!< (@ 0x00000604) Block protect configuration register 1                     */
  __IOM uint32_t  DISABLEINDEBUG;               /*!< (@ 0x00000608) Disable protection mechanism in debug mode                 */
} NRF_BPROT_Type;                               /*!< Size = 1548 (0x60c)                                                       */



/* =========================================================================================================================== */
/* ================                                         RAMBIST0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief The RamBist perform hardware accelerated RAM tests (RAMBIST0)
  */

typedef struct {                                /*!< (@ 0x40025000) RAMBIST0 Structure                                         */
  __IM  uint32_t  RESERVED[256];
  __IOM RAMBIST_STATUS_Type STATUS;             /*!< (@ 0x00000400) Unspecified                                                */
  __IM  uint32_t  RESERVED1[62];
  __IOM uint32_t  RUN;                          /*!< (@ 0x00000500) Run the BIST engine, must be kept 1 until the
                                                                    BIST is finished                                           */
  __IOM RAMBIST_CONFIG_Type CONFIG;             /*!< (@ 0x00000504) Unspecified                                                */
} NRF_RAMBIST_Type;                             /*!< Size = 1296 (0x510)                                                       */



/* =========================================================================================================================== */
/* ================                                         RCOSC32K                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief 32.768 kHz RC oscillator (RCOSC32K)
  */

typedef struct {                                /*!< (@ 0x40027000) RCOSC32K Structure                                         */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000000) Start calibration of LFRC oscillator                       */
  __OM  uint32_t  TASKS_CTSTART;                /*!< (@ 0x00000004) Deprecated register - Start calibration timer              */
  __OM  uint32_t  TASKS_CTSTOP;                 /*!< (@ 0x00000008) Deprecated register - Stop calibration timer               */
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_CAL;                /*!< (@ 0x00000080) Subscribe configuration for task CAL                       */
  __IOM uint32_t  SUBSCRIBE_CTSTART;            /*!< (@ 0x00000084) Deprecated register - Subscribe configuration
                                                                    for task CTSTART                                           */
  __IOM uint32_t  SUBSCRIBE_CTSTOP;             /*!< (@ 0x00000088) Deprecated register - Subscribe configuration
                                                                    for task CTSTOP                                            */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_CTTO;                  /*!< (@ 0x00000100) Deprecated register - Calibration timer timeout            */
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000104) Calibration of LFCLK RC oscillator complete event          */
  __IOM uint32_t  EVENTS_CTSTARTED;             /*!< (@ 0x00000108) Deprecated register - Calibration timer started            */
  __IOM uint32_t  EVENTS_CTSTOPPED;             /*!< (@ 0x0000010C) Deprecated register - Calibration timer stopped            */
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_CTTO;                 /*!< (@ 0x00000180) Deprecated register - Publish configuration for
                                                                    event CTTO                                                 */
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x00000184) Publish configuration for event DONE                       */
  __IOM uint32_t  PUBLISH_CTSTARTED;            /*!< (@ 0x00000188) Deprecated register - Publish configuration for
                                                                    event CTSTARTED                                            */
  __IOM uint32_t  PUBLISH_CTSTOPPED;            /*!< (@ 0x0000018C) Deprecated register - Publish configuration for
                                                                    event CTSTOPPED                                            */
  __IM  uint32_t  RESERVED3[164];
  __IM  uint32_t  RCOSC32KIFINE;                /*!< (@ 0x00000420) Fine calibration read value for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IM  uint32_t  RCOSC32KICOARSE;              /*!< (@ 0x00000424) Coarse calibration read value for 32.768 kHz
                                                                    RC oscillator                                              */
  __IM  uint32_t  RESERVED4[67];
  __IOM uint32_t  RCOSC32KICALTEST;             /*!< (@ 0x00000534) 32.768 kHz RC oscillator calibration debug register
                                                                    NOTE: This register should not be written
                                                                    to while the RCOSC source is running.                      */
  __IOM uint32_t  CTIV;                         /*!< (@ 0x00000538) Deprecated register - Calibration timer interval
                                                                    NOTE: This register should not be written
                                                                    to while the calibration timer is running.                 */
  __IOM uint32_t  RCOSC32KICALLENGTH;           /*!< (@ 0x0000053C) 32kHz RC oscillator calibration length This value
                                                                    is read from FICR                                          */
  __IOM uint32_t  RCOSC32KICOARSEIN;            /*!< (@ 0x00000540) RCOSC coarse calibration input This value is
                                                                    read from FICR                                             */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  RCOSC32KICABD;                /*!< (@ 0x0000054C) Comparator adaptive biasing disable                        */
  __IM  uint32_t  RESERVED6[13];
  __IOM uint32_t  ATECLOCK;                     /*!< (@ 0x00000584) Analog test bus control for clock modules                  */
  __IM  uint32_t  RESERVED7[11];
  __IOM uint32_t  LFRCMODE;                     /*!< (@ 0x000005B4) LFRC mode configuration                                    */
  __IOM uint32_t  LFULP32KICOARSEIN;            /*!< (@ 0x000005B8) Deprecated register - LFULP coarse calibration
                                                                    input This value is read from FICR                         */
  __IOM uint32_t  LFULP32KICALLENGTH;           /*!< (@ 0x000005BC) Deprecated register - 32kHz LFULP RC oscillator
                                                                    calibration length This value is read from
                                                                    FICR                                                       */
  __IM  uint32_t  RESERVED8[399];
  __IOM uint32_t  DISABLERCOSC32KIPOWERUPCONTROL;/*!< (@ 0x00000BFC) Backdoor for disabling Rcosc32KiPowerUpControl
                                                                    module in Rcosc32KiGenerator.                              */
} NRF_RCOSC32K_Type;                            /*!< Size = 3072 (0xc00)                                                       */



/* =========================================================================================================================== */
/* ================                                      PCGCSLAVE_AMLI                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief PCGCSlave (PCGCSLAVE_AMLI)
  */

typedef struct {                                /*!< (@ 0x41000000) PCGCSLAVE_AMLI Structure                                   */
  __IM  uint32_t  RESERVED[30];
  __IM  uint32_t  TRIGZEROPENALTY;              /*!< (@ 0x00000078) Trigger zero penalty                                       */
  __IM  uint32_t  TRIGFULLPENALTY;              /*!< (@ 0x0000007C) Trigger full penalty                                       */
  __IM  uint32_t  RESERVED1[736];
  __IM  uint32_t  PENALTY[2];                   /*!< (@ 0x00000C00) Description collection: Penalty level for power/clock
                                                                    pair n                                                     */
  __IM  uint32_t  RESERVED2[30];
  __IM  uint32_t  FORCEOVERRIDE[2];             /*!< (@ 0x00000C80) Description collection: Force override of power/clock
                                                                    pair n                                                     */
} NRF_PCGCSLAVE_Type;                           /*!< Size = 3208 (0xc88)                                                       */



/* =========================================================================================================================== */
/* ================                                        PCGCMASTER0                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief PCGC Master (PCGCMASTER0)
  */

typedef struct {                                /*!< (@ 0x41001000) PCGCMASTER0 Structure                                      */
  __IM  uint32_t  RESERVED[56];
  __IM  uint32_t  SETPWRCONTHRESHOLDBASE[3];    /*!< (@ 0x000000E0) Description collection: Set power consumption
                                                                    threshold base for power source / regulator
                                                                    n                                                          */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  SETPOWERCONSUMPTIONBASE[2];   /*!< (@ 0x00000100) Description collection: Set power consumption
                                                                    base for power/clock pair n                                */
  __IM  uint32_t  RESERVED2[702];
  __IM  uint32_t  UNLOCKBACKDOORS;              /*!< (@ 0x00000C00) Unlock backdoors                                           */
  __IM  uint32_t  ENABLEPOWERREGFORCE;          /*!< (@ 0x00000C04) Enable power reg force                                     */
  __IM  uint32_t  POWERREGFORCE;                /*!< (@ 0x00000C08) Force reg                                                  */
  __IM  uint32_t  RESERVED3;
  __IM  uint32_t  MASTERFORCEREG;               /*!< (@ 0x00000C10) Force reg                                                  */
  __IM  uint32_t  RESERVED4[59];
  __IM  uint32_t  CLOCKFORCEREG[5];             /*!< (@ 0x00000D00) Description collection: Force clock n                      */
} NRF_PCGCMASTER_Type;                          /*!< Size = 3348 (0xd14)                                                       */



/* =========================================================================================================================== */
/* ================                                           CLOCK                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock management (CLOCK)
  */

typedef struct {                                /*!< (@ 0x40000000) CLOCK Structure                                            */
  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFCLK128M/HFCLK64M source as selected in
                                                                    HFCLKSRC                                                   */
  __OM  uint32_t  TASKS_HFCLKSTOP;              /*!< (@ 0x00000004) Stop HFCLK128M/HFCLK64M source                             */
  __OM  uint32_t  TASKS_LFCLKSTART;             /*!< (@ 0x00000008) Start LFCLK source as selected in LFCLKSRC                 */
  __OM  uint32_t  TASKS_LFCLKSTOP;              /*!< (@ 0x0000000C) Stop LFCLK source                                          */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000010) Start calibration of LFRC oscillator                       */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_HFCLKSTART;         /*!< (@ 0x00000080) Subscribe configuration for task HFCLKSTART                */
  __IOM uint32_t  SUBSCRIBE_HFCLKSTOP;          /*!< (@ 0x00000084) Subscribe configuration for task HFCLKSTOP                 */
  __IOM uint32_t  SUBSCRIBE_LFCLKSTART;         /*!< (@ 0x00000088) Subscribe configuration for task LFCLKSTART                */
  __IOM uint32_t  SUBSCRIBE_LFCLKSTOP;          /*!< (@ 0x0000008C) Subscribe configuration for task LFCLKSTOP                 */
  __IOM uint32_t  SUBSCRIBE_CAL;                /*!< (@ 0x00000090) Subscribe configuration for task CAL                       */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;          /*!< (@ 0x00000100) HFCLK source started                                       */
  __IOM uint32_t  EVENTS_LFCLKSTARTED;          /*!< (@ 0x00000104) LFCLK source started                                       */
  __IM  uint32_t  RESERVED2[5];
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x0000011C) Calibration of LFRC oscillator complete event              */
  __IM  uint32_t  RESERVED3[24];
  __IOM uint32_t  PUBLISH_HFCLKSTARTED;         /*!< (@ 0x00000180) Publish configuration for event HFCLKSTARTED               */
  __IOM uint32_t  PUBLISH_LFCLKSTARTED;         /*!< (@ 0x00000184) Publish configuration for event LFCLKSTARTED               */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x0000019C) Publish configuration for event DONE                       */
  __IM  uint32_t  RESERVED5[88];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  INTPEND;                      /*!< (@ 0x0000030C) Pending interrupts                                         */
  __IM  uint32_t  RESERVED6[62];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) Status indicating which HFCLK128M/HFCLK64M source
                                                                    is running Note: Value of this register
                                                                    in any CLOCK instance reflects status only
                                                                    due to configurations/actions in that CLOCK
                                                                    instance.                                                  */
  __IM  uint32_t  RESERVED7;
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) Status indicating which LFCLK source is running
                                                                    Note: Value of this register in any CLOCK
                                                                    instance reflects status only due to configurations/action
                                                                    in that CLOCK instance.                                    */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RESERVED8[4];
  __IOM uint32_t  HFCLKCURRFREQ;                /*!< (@ 0x00000430) Current frequency of HFCLK                                 */
  __IM  uint32_t  RESERVED9[56];
  __IOM uint32_t  HFCLKSRC;                     /*!< (@ 0x00000514) Clock source for HFCLK                                     */
  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for LFCLK                                     */
  __IM  uint32_t  RESERVED10[15];
  __IOM uint32_t  HFCLKCTRL;                    /*!< (@ 0x00000558) HFCLK frequency configuration                              */
  __IM  uint32_t  RESERVED11[5];
  __IOM uint32_t  HFCLKALWAYSRUN;               /*!< (@ 0x00000570) Automatic or manual control of HFCLK                       */
  __IOM uint32_t  LFCLKALWAYSRUN;               /*!< (@ 0x00000574) Automatic or manual control of LFCLK                       */
} NRF_CLOCK_Type;                               /*!< Size = 1400 (0x578)                                                       */



/* =========================================================================================================================== */
/* ================                                           POWER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control (POWER)
  */

typedef struct {                                /*!< (@ 0x40000000) POWER Structure                                            */
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;               /*!< (@ 0x00000078) Enable constant latency mode When going to sleep:
                                                                    CPU is clock gated, but regulators, oscillators
                                                                    and clock tree is kept on.                                 */
  __OM  uint32_t  TASKS_LOWPWR;                 /*!< (@ 0x0000007C) Enable low power mode (variable latency) When
                                                                    going to sleep: Oscillators are switched
                                                                    off (if nothing else is requesting clocks).
                                                                    Regulators are switched off (if nothing
                                                                    else is requesting power).                                 */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_CONSTLAT;           /*!< (@ 0x000000F8) Subscribe configuration for task CONSTLAT                  */
  __IOM uint32_t  SUBSCRIBE_LOWPWR;             /*!< (@ 0x000000FC) Subscribe configuration for task LOWPWR                    */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_POFWARN;               /*!< (@ 0x00000108) Power failure warning                                      */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;            /*!< (@ 0x00000114) CPU entered WFI/WFE sleep                                  */
  __IOM uint32_t  EVENTS_SLEEPEXIT;             /*!< (@ 0x00000118) CPU exited WFI/WFE sleep                                   */
  __IM  uint32_t  RESERVED4[27];
  __IOM uint32_t  PUBLISH_POFWARN;              /*!< (@ 0x00000188) Publish configuration for event POFWARN                    */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  PUBLISH_SLEEPENTER;           /*!< (@ 0x00000194) Publish configuration for event SLEEPENTER                 */
  __IOM uint32_t  PUBLISH_SLEEPEXIT;            /*!< (@ 0x00000198) Publish configuration for event SLEEPEXIT                  */
  __IM  uint32_t  RESERVED6[89];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[132];
  __IOM uint32_t  GPREGRET[2];                  /*!< (@ 0x0000051C) Description collection: General purpose retention
                                                                    register                                                   */
} NRF_POWER_Type;                               /*!< Size = 1316 (0x524)                                                       */



/* =========================================================================================================================== */
/* ================                                           RESET                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset control (RESET)
  */

typedef struct {                                /*!< (@ 0x40000000) RESET Structure                                            */
  __IM  uint32_t  RESERVED[256];
  __IOM uint32_t  RESETREAS;                    /*!< (@ 0x00000400) Reset reason                                               */
} NRF_RESET_Type;                               /*!< Size = 1028 (0x404)                                                       */



/* =========================================================================================================================== */
/* ================                                           AMLI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AHB Multi-Layer Interface (AMLI)
  */

typedef struct {                                /*!< (@ 0x41000000) AMLI Structure                                             */
  __IM  uint32_t  RESERVED[384];
  __IOM AMLI_RAMPRI_Type RAMPRI;                /*!< (@ 0x00000600) RAM configurable priority configuration structure          */
} NRF_AMLI_Type;                                /*!< Size = 1552 (0x610)                                                       */



/* =========================================================================================================================== */
/* ================                                            P0                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (P0)
  */

typedef struct {                                /*!< (@ 0x50000000) P0 Structure                                               */
  __IM  uint32_t  RESERVED[321];
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000504) Write GPIO port                                            */
  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000508) Set individual bits in GPIO port                           */
  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */
  __IM  uint32_t  IN;                           /*!< (@ 0x00000510) Read GPIO port                                             */
  __IOM uint32_t  DIR;                          /*!< (@ 0x00000514) Direction of GPIO pins                                     */
  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000518) DIR set register                                           */
  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000051C) DIR clear register                                         */
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000520) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000524) Select between default DETECT signal behaviour
                                                                    and LDETECT mode                                           */
  __IM  uint32_t  RESERVED1[54];
  __IOM GPIO_PIN_Type PIN[32];                  /*!< (@ 0x00000600) Pin n direct access                                        */
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;                                /*!< Size = 1920 (0x780)                                                       */



/* =========================================================================================================================== */
/* ================                                        OSCILLATORS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Oscillator control (OSCILLATORS)
  */

typedef struct {                                /*!< (@ 0x40001000) OSCILLATORS Structure                                      */
  __IM  uint32_t  RESERVED[353];
  __IOM uint32_t  ATECLOCK;                     /*!< (@ 0x00000584) Analog test bus control for clock modules                  */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  BYPASSHFXOSC;                 /*!< (@ 0x00000600) Enable or disable bypass of HFCLK crystal oscillator
                                                                    with external clock source                                 */
  __IM  uint32_t  RESERVED2[31];
  __IOM OSCILLATORS_PLL64M_Type PLL64M;         /*!< (@ 0x00000680) Unspecified                                                */
} NRF_OSCILLATORS_Type;                         /*!< Size = 1684 (0x694)                                                       */



/* =========================================================================================================================== */
/* ================                                        REGULATORS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Regulator control (REGULATORS)
  */

typedef struct {                                /*!< (@ 0x40001000) REGULATORS Structure                                       */
  __IM  uint32_t  RESERVED[269];
  __OM  uint32_t  DISABLEHPBOR;                 /*!< (@ 0x00000434) Enable or disable HPBOR                                    */
  __IM  uint32_t  RESERVED1[50];
  __OM  uint32_t  SYSTEMOFF;                    /*!< (@ 0x00000500) System OFF register                                        */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  POFCON;                       /*!< (@ 0x00000510) Power-fail comparator configuration                        */
  __OM  uint32_t  IGNOREDAPCPWRREGMODE;         /*!< (@ 0x00000514) Ignore DAPCP power mode                                    */
  __IOM uint32_t  RSTVTHTRIM;                   /*!< (@ 0x00000518) Threshold trim, power-on reset                             */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  BGREFTRIM;                    /*!< (@ 0x00000520) Master bias bandgap trim                                   */
  __IM  uint32_t  RESERVED4[25];
  __IOM uint32_t  ATEPOWER;                     /*!< (@ 0x00000588) Analog test bus control for power modules                  */
  __IOM uint32_t  VREFULPTRIM;                  /*!< (@ 0x0000058C) Trim value of VREF_ULP                                     */
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  FORCEVBUSDET;                 /*!< (@ 0x000005E8) Force VBUS detection indication                            */
  __IM  uint32_t  RESERVED6[197];
  __IOM REGULATORS_VREGANA_Type VREGANA;        /*!< (@ 0x00000900) Unspecified                                                */
  __IM  uint32_t  RESERVED7[47];
  __IOM REGULATORS_VREGMAIN_Type VREGMAIN;      /*!< (@ 0x00000A00) Unspecified                                                */
  __IM  uint32_t  RESERVED8[302];
  __OM  uint32_t  DISABLEPACSYSTEMOFFACK;       /*!< (@ 0x00000EE4) Enable or disable System OFF ack from PAC                  */
  __OM  uint32_t  DISABLESRAMSYSTEMOFFACK;      /*!< (@ 0x00000EE8) Enable or disable System OFF ack from SRAM                 */
  __OM  uint32_t  DISABLENVMSYSTEMOFFACK;       /*!< (@ 0x00000EEC) Enable or disable System OFF ack from NVM                  */
} NRF_REGULATORS_Type;                          /*!< Size = 3824 (0xef0)                                                       */



/* =========================================================================================================================== */
/* ================                                           RADIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief 2.4 GHz radio (RADIO)
  */

typedef struct {                                /*!< (@ 0x40002000) RADIO Structure                                            */
  __OM  uint32_t  TASKS_TXEN;                   /*!< (@ 0x00000000) Enable RADIO in TX mode                                    */
  __OM  uint32_t  TASKS_RXEN;                   /*!< (@ 0x00000004) Enable RADIO in RX mode                                    */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000008) Start RADIO                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x0000000C) Stop RADIO                                                 */
  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000010) Disable RADIO                                              */
  __OM  uint32_t  TASKS_RSSISTART;              /*!< (@ 0x00000014) Start the RSSI and take one single sample of
                                                                    the receive signal strength                                */
  __OM  uint32_t  TASKS_RSSISTOP;               /*!< (@ 0x00000018) Stop the RSSI measurement                                  */
  __OM  uint32_t  TASKS_BCSTART;                /*!< (@ 0x0000001C) Start the bit counter                                      */
  __OM  uint32_t  TASKS_BCSTOP;                 /*!< (@ 0x00000020) Stop the bit counter                                       */
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_CNTP_START;             /*!< (@ 0x00000038) Start packet counter                                       */
  __OM  uint32_t  TASKS_CNTP_STOP;              /*!< (@ 0x0000003C) Stop packet counter                                        */
  __OM  uint32_t  TASKS_CNTP_CLEAR;             /*!< (@ 0x00000040) Clear packet counter                                       */
  __OM  uint32_t  TASKS_DFESTART;               /*!< (@ 0x00000044) Start an AoA/AoD procedure (antenna switching
                                                                    and baseband sampling)                                     */
  __OM  uint32_t  TASKS_DFESTOP;                /*!< (@ 0x00000048) Stop an AoA/AoD procedure                                  */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_DMA_START;              /*!< (@ 0x00000050) Start DMA transaction                                      */
  __OM  uint32_t  TASKS_DMA_STOP;               /*!< (@ 0x00000054) Stop ongoing DMA transaction                               */
  __IM  uint32_t  RESERVED2[2];
  __OM  uint32_t  TASKS_ACQSTART;               /*!< (@ 0x00000060) Start data acquisition                                     */
  __OM  uint32_t  TASKS_ACQSTOP;                /*!< (@ 0x00000064) Stop data acquisition                                      */
  __OM  uint32_t  TASKS_PCGC_PCP2_ZERO;         /*!< (@ 0x00000068) Zero penalty                                               */
  __OM  uint32_t  TASKS_PCGC_PCP2_FULL;         /*!< (@ 0x0000006C) Full penalty                                               */
  __OM  uint32_t  TASKS_PCGC_PCP1_ZERO;         /*!< (@ 0x00000070) Zero penalty                                               */
  __OM  uint32_t  TASKS_PCGC_PCP1_FULL;         /*!< (@ 0x00000074) Full penalty                                               */
  __OM  uint32_t  TASKS_PCGC_PCP0_ZERO;         /*!< (@ 0x00000078) Zero penalty                                               */
  __OM  uint32_t  TASKS_PCGC_PCP0_FULL;         /*!< (@ 0x0000007C) Full penalty                                               */
  __IOM uint32_t  SUBSCRIBE_TXEN;               /*!< (@ 0x00000080) Subscribe configuration for task TXEN                      */
  __IOM uint32_t  SUBSCRIBE_RXEN;               /*!< (@ 0x00000084) Subscribe configuration for task RXEN                      */
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000088) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x0000008C) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_DISABLE;            /*!< (@ 0x00000090) Subscribe configuration for task DISABLE                   */
  __IOM uint32_t  SUBSCRIBE_RSSISTART;          /*!< (@ 0x00000094) Subscribe configuration for task RSSISTART                 */
  __IOM uint32_t  SUBSCRIBE_RSSISTOP;           /*!< (@ 0x00000098) Subscribe configuration for task RSSISTOP                  */
  __IOM uint32_t  SUBSCRIBE_BCSTART;            /*!< (@ 0x0000009C) Subscribe configuration for task BCSTART                   */
  __IOM uint32_t  SUBSCRIBE_BCSTOP;             /*!< (@ 0x000000A0) Subscribe configuration for task BCSTOP                    */
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  SUBSCRIBE_CNTP_START;         /*!< (@ 0x000000B8) Subscribe configuration for task CNTP_START                */
  __IOM uint32_t  SUBSCRIBE_CNTP_STOP;          /*!< (@ 0x000000BC) Subscribe configuration for task CNTP_STOP                 */
  __IOM uint32_t  SUBSCRIBE_CNTP_CLEAR;         /*!< (@ 0x000000C0) Subscribe configuration for task CNTP_CLEAR                */
  __IOM uint32_t  SUBSCRIBE_DFESTART;           /*!< (@ 0x000000C4) Subscribe configuration for task DFESTART                  */
  __IOM uint32_t  SUBSCRIBE_DFESTOP;            /*!< (@ 0x000000C8) Subscribe configuration for task DFESTOP                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_DMA_START;          /*!< (@ 0x000000D0) Subscribe configuration for task DMA_START                 */
  __IOM uint32_t  SUBSCRIBE_DMA_STOP;           /*!< (@ 0x000000D4) Subscribe configuration for task DMA_STOP                  */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_ACQSTART;           /*!< (@ 0x000000E0) Subscribe configuration for task ACQSTART                  */
  __IOM uint32_t  SUBSCRIBE_ACQSTOP;            /*!< (@ 0x000000E4) Subscribe configuration for task ACQSTOP                   */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP2_ZERO;     /*!< (@ 0x000000E8) Subscribe configuration for task PCGC_PCP2_ZERO            */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP2_FULL;     /*!< (@ 0x000000EC) Subscribe configuration for task PCGC_PCP2_FULL            */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP1_ZERO;     /*!< (@ 0x000000F0) Subscribe configuration for task PCGC_PCP1_ZERO            */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP1_FULL;     /*!< (@ 0x000000F4) Subscribe configuration for task PCGC_PCP1_FULL            */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP0_ZERO;     /*!< (@ 0x000000F8) Subscribe configuration for task PCGC_PCP0_ZERO            */
  __IOM uint32_t  SUBSCRIBE_PCGC_PCP0_FULL;     /*!< (@ 0x000000FC) Subscribe configuration for task PCGC_PCP0_FULL            */
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) RADIO has ramped up and is ready to be started             */
  __IOM uint32_t  EVENTS_ADDRESS;               /*!< (@ 0x00000104) Address sent or received                                   */
  __IOM uint32_t  EVENTS_PAYLOAD;               /*!< (@ 0x00000108) Packet payload sent or received                            */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x0000010C) Packet sent or received                                    */
  __IOM uint32_t  EVENTS_DISABLED;              /*!< (@ 0x00000110) RADIO has been disabled                                    */
  __IOM uint32_t  EVENTS_DEVMATCH;              /*!< (@ 0x00000114) A device address match occurred on the last received
                                                                    packet                                                     */
  __IOM uint32_t  EVENTS_DEVMISS;               /*!< (@ 0x00000118) No device address match occurred on the last
                                                                    received packet                                            */
  __IOM uint32_t  EVENTS_RSSIEND;               /*!< (@ 0x0000011C) Sampling of receive signal strength complete               */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  EVENTS_BCMATCH;               /*!< (@ 0x00000128) Bit counter reached bit count value                        */
  __IOM uint32_t  EVENTS_CTEEND;                /*!< (@ 0x0000012C) End of CTE                                                 */
  __IOM uint32_t  EVENTS_CRCOK;                 /*!< (@ 0x00000130) Packet received with CRC ok                                */
  __IOM uint32_t  EVENTS_CRCERROR;              /*!< (@ 0x00000134) Packet received with CRC error                             */
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  EVENTS_TXREADY;               /*!< (@ 0x00000154) RADIO has ramped up and is ready to be started
                                                                    TX path                                                    */
  __IOM uint32_t  EVENTS_RXREADY;               /*!< (@ 0x00000158) RADIO has ramped up and is ready to be started
                                                                    RX path                                                    */
  __IOM uint32_t  EVENTS_MHRMATCH;              /*!< (@ 0x0000015C) MAC header match found                                     */
  __IOM uint32_t  EVENTS_ACQEND;                /*!< (@ 0x00000160) ACQDMA EasyDMA buffer full                                 */
  __IOM uint32_t  EVENTS_ACQREADY;              /*!< (@ 0x00000164) ACQDMA EasyDMA sample ready                                */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  EVENTS_PHYEND;                /*!< (@ 0x0000016C) Generated when last bit is sent on air, or received
                                                                    from air                                                   */
  __IOM uint32_t  EVENTS_CTEPRESENT;            /*!< (@ 0x00000170) CTE is present (early warning right after receiving
                                                                    CTEInfo byte)                                              */
  __IOM uint32_t  EVENTS_CTEWARNING;            /*!< (@ 0x00000174) CTE is present, but CTEType or CTETime is out
                                                                    of valid range (early warning right after
                                                                    receiving CTEinfo byte)                                    */
  __IOM uint32_t  EVENTS_DFEEND;                /*!< (@ 0x00000178) When both antenna switching AND direction finding
                                                                    sampling have completed                                    */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000180) Publish configuration for event READY                      */
  __IOM uint32_t  PUBLISH_ADDRESS;              /*!< (@ 0x00000184) Publish configuration for event ADDRESS                    */
  __IOM uint32_t  PUBLISH_PAYLOAD;              /*!< (@ 0x00000188) Publish configuration for event PAYLOAD                    */
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x0000018C) Publish configuration for event END                        */
  __IOM uint32_t  PUBLISH_DISABLED;             /*!< (@ 0x00000190) Publish configuration for event DISABLED                   */
  __IOM uint32_t  PUBLISH_DEVMATCH;             /*!< (@ 0x00000194) Publish configuration for event DEVMATCH                   */
  __IOM uint32_t  PUBLISH_DEVMISS;              /*!< (@ 0x00000198) Publish configuration for event DEVMISS                    */
  __IOM uint32_t  PUBLISH_RSSIEND;              /*!< (@ 0x0000019C) Publish configuration for event RSSIEND                    */
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_BCMATCH;              /*!< (@ 0x000001A8) Publish configuration for event BCMATCH                    */
  __IOM uint32_t  PUBLISH_CTEEND;               /*!< (@ 0x000001AC) Publish configuration for event CTEEND                     */
  __IOM uint32_t  PUBLISH_CRCOK;                /*!< (@ 0x000001B0) Publish configuration for event CRCOK                      */
  __IOM uint32_t  PUBLISH_CRCERROR;             /*!< (@ 0x000001B4) Publish configuration for event CRCERROR                   */
  __IM  uint32_t  RESERVED11[7];
  __IOM uint32_t  PUBLISH_TXREADY;              /*!< (@ 0x000001D4) Publish configuration for event TXREADY                    */
  __IOM uint32_t  PUBLISH_RXREADY;              /*!< (@ 0x000001D8) Publish configuration for event RXREADY                    */
  __IOM uint32_t  PUBLISH_MHRMATCH;             /*!< (@ 0x000001DC) Publish configuration for event MHRMATCH                   */
  __IOM uint32_t  PUBLISH_ACQEND;               /*!< (@ 0x000001E0) Publish configuration for event ACQEND                     */
  __IOM uint32_t  PUBLISH_ACQREADY;             /*!< (@ 0x000001E4) Publish configuration for event ACQREADY                   */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PUBLISH_PHYEND;               /*!< (@ 0x000001EC) Publish configuration for event PHYEND                     */
  __IOM uint32_t  PUBLISH_CTEPRESENT;           /*!< (@ 0x000001F0) Publish configuration for event CTEPRESENT                 */
  __IOM uint32_t  PUBLISH_CTEWARNING;           /*!< (@ 0x000001F4) Publish configuration for event CTEWARNING                 */
  __IOM uint32_t  PUBLISH_DFEEND;               /*!< (@ 0x000001F8) Publish configuration for event DFEEND                     */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED14[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED15[61];
  __IM  uint32_t  CRCSTATUS;                    /*!< (@ 0x00000400) CRC status                                                 */
  __IM  uint32_t  RESERVED16;
  __IM  uint32_t  RXMATCH;                      /*!< (@ 0x00000408) Received address                                           */
  __IM  uint32_t  RXCRC;                        /*!< (@ 0x0000040C) CRC field of previously received packet                    */
  __IM  uint32_t  DAI;                          /*!< (@ 0x00000410) Device address match index                                 */
  __IM  uint32_t  PDUSTAT;                      /*!< (@ 0x00000414) Payload status                                             */
  __IM  uint32_t  DMA_STAT;                     /*!< (@ 0x00000418) DMA byte count                                             */
  __IM  uint32_t  RESERVED17;
  __IM  uint32_t  PLL_CAL_VCO;                  /*!< (@ 0x00000420) PLL Calibration                                            */
  __IM  uint32_t  LNB_OUT_SPI;                  /*!< (@ 0x00000424) Readout of gain settings set by the AGC. They
                                                                    are sampled at EVENTS_ADDRESS and when triggering
                                                                    TASKS_RSSISTART                                            */
  __IM  uint32_t  RESERVED18[2];
  __IM  uint32_t  MISC_CAL_OUT1;                /*!< (@ 0x00000430) Misc cal readouts                                          */
  __IM  uint32_t  MISC_CAL_OUT2;                /*!< (@ 0x00000434) Misc cal readouts                                          */
  __IM  uint32_t  RESERVED19[2];
  __IM  uint32_t  CFO_STAT;                     /*!< (@ 0x00000440) Carrier freq. offset estimate                              */
  __IM  uint32_t  IQCAL_OUT;                    /*!< (@ 0x00000444) Test: IandQ gain/phase mismatch calibration values
                                                                    out                                                        */
  __IM  uint32_t  PBCAL_OUT;                    /*!< (@ 0x00000448) Test: PB calibration values out                            */
  __IM  uint32_t  CTESTATUS;                    /*!< (@ 0x0000044C) CTEInfo parsed from received packet                        */
  __IOM uint32_t  HYPSTDCHECKSTAT;              /*!< (@ 0x00000450) Address Check Override                                     */
  __IOM uint32_t  HYPSTDAADIFFVEC;              /*!< (@ 0x00000454) Address Diff Vector                                        */
  __IM  uint32_t  DFESTATUS;                    /*!< (@ 0x00000458) DFE status information                                     */
  __IM  uint32_t  RESERVED20[42];
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000504) Packet pointer                                             */
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000508) Frequency                                                  */
  __IOM uint32_t  TXPOWER;                      /*!< (@ 0x0000050C) Output power                                               */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000510) Data rate and modulation                                   */
  __IOM uint32_t  PCNF0;                        /*!< (@ 0x00000514) Packet configuration register 0                            */
  __IOM uint32_t  PCNF1;                        /*!< (@ 0x00000518) Packet configuration register 1                            */
  __IOM uint32_t  BASE0;                        /*!< (@ 0x0000051C) Base address 0                                             */
  __IOM uint32_t  BASE1;                        /*!< (@ 0x00000520) Base address 1                                             */
  __IOM uint32_t  PREFIX0;                      /*!< (@ 0x00000524) Prefixes bytes for logical addresses 0-3                   */
  __IOM uint32_t  PREFIX1;                      /*!< (@ 0x00000528) Prefixes bytes for logical addresses 4-7                   */
  __IOM uint32_t  TXADDRESS;                    /*!< (@ 0x0000052C) Transmit address select                                    */
  __IOM uint32_t  RXADDRESSES;                  /*!< (@ 0x00000530) Receive address select                                     */
  __IOM uint32_t  CRCCNF;                       /*!< (@ 0x00000534) CRC configuration                                          */
  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000538) CRC polynomial                                             */
  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x0000053C) CRC initial value                                          */
  __IM  uint32_t  RESERVED21;
  __IOM uint32_t  TIFS;                         /*!< (@ 0x00000544) Interframe spacing in us                                   */
  __IM  uint32_t  RSSISAMPLE;                   /*!< (@ 0x00000548) RSSI sample                                                */
  __IOM uint32_t  RSSI_CONFIG;                  /*!< (@ 0x0000054C) RSSI resolution                                            */
  __IM  uint32_t  STATE;                        /*!< (@ 0x00000550) Current radio state                                        */
  __IOM uint32_t  DATAWHITEIV;                  /*!< (@ 0x00000554) Data whitening initial value                               */
  __IM  uint32_t  RESERVED22;
  __IOM uint32_t  DMA_MAXLEN;                   /*!< (@ 0x0000055C) DMA max length                                             */
  __IOM uint32_t  BCC;                          /*!< (@ 0x00000560) Bit counter compare                                        */
  __IM  uint32_t  RESERVED23;
  __IOM uint32_t  AACHKOVERRIDE;                /*!< (@ 0x00000568) Address Check Override                                     */
  __IOM uint32_t  PB_TEST;                      /*!< (@ 0x0000056C) Test: PB calibration                                       */
  __IM  uint32_t  PACKET_CNTR1;                 /*!< (@ 0x00000570) Test: PER msrmnts                                          */
  __IM  uint32_t  PACKET_CNTR2;                 /*!< (@ 0x00000574) Test: PER msrmnts                                          */
  __IOM uint32_t  IQCAL_TEST;                   /*!< (@ 0x00000578) Test: IandQ gain/phase mismatch calibration control        */
  __IM  uint32_t  RESERVED24;
  __IOM uint32_t  DBC_COEFFS;                   /*!< (@ 0x00000580) Test and Debug: DBC coefficients override                  */
  __IOM uint32_t  FS_CONFIG;                    /*!< (@ 0x00000584) Fs config (ana+dig)                                        */
  __IOM uint32_t  FS_TEST;                      /*!< (@ 0x00000588) Fs misc test                                               */
  __IOM uint32_t  FS_TRIM;                      /*!< (@ 0x0000058C) Fs misc trim                                               */
  __IOM uint32_t  MISC_TRIM1;                   /*!< (@ 0x00000590) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  MISC_TEST1;                   /*!< (@ 0x00000594) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  MISC_TEST2;                   /*!< (@ 0x00000598) Misc Aaf/ADC trim related                                  */
  __IOM uint32_t  RX_CONFIG;                    /*!< (@ 0x0000059C) Misc RX config                                             */
  __IM  uint32_t  RESERVED25[24];
  __IOM uint32_t  DAB[8];                       /*!< (@ 0x00000600) Description collection: Device address base segment
                                                                    n                                                          */
  __IOM uint32_t  DAP[8];                       /*!< (@ 0x00000620) Description collection: Device address prefix
                                                                    n                                                          */
  __IOM uint32_t  DACNF;                        /*!< (@ 0x00000640) Device address match configuration                         */
  __IM  uint32_t  RESERVED26[2];
  __IOM uint32_t  ADDRWINSIZE;                  /*!< (@ 0x0000064C) address match safe window size (the number of
                                                                    bits after detect is asserted, before starting
                                                                    to look for address match). Only valid when
                                                                    OVERRIDE22.DISABLEADDRWINDOW is '0'                        */
  __IOM uint32_t  MODECNF0;                     /*!< (@ 0x00000650) Radio mode configuration register 0                        */
  __IOM uint32_t  MODECNF1;                     /*!< (@ 0x00000654) Radio mode configuration register 1                        */
  __IM  uint32_t  RESERVED27[43];
  __IOM uint32_t  AGC_TOGGLE;                   /*!< (@ 0x00000704) Constant AGC Gain switching, Debug                         */
  __IOM uint32_t  AGC_EN;                       /*!< (@ 0x00000708) AGC enable                                                 */
  __IOM uint32_t  AGC_OVERRIDE;                 /*!< (@ 0x0000070C) Gain setting                                               */
  __IM  uint32_t  RESERVED28[5];
  __IOM uint32_t  QOVERRIDE0;                   /*!< (@ 0x00000724) Trim value override register 0 for nRF52                   */
  __IOM uint32_t  QOVERRIDE1;                   /*!< (@ 0x00000728) Trim value override register 1 for nRF52                   */
  __IOM uint32_t  QOVERRIDE2;                   /*!< (@ 0x0000072C) Trim value override register 2 for nRF52                   */
  __IOM uint32_t  QOVERRIDE3;                   /*!< (@ 0x00000730) Trim value override register 3 for nRF52                   */
  __IOM uint32_t  QOVERRIDE4;                   /*!< (@ 0x00000734) Trim value override register 4 for nRF52                   */
  __IOM uint32_t  QOVERRIDE5;                   /*!< (@ 0x00000738) Trim value override register 5 for nRF52                   */
  __IOM uint32_t  QOVERRIDE6;                   /*!< (@ 0x0000073C) Trim value override register 6 for nRF52                   */
  __IOM uint32_t  QOVERRIDE7;                   /*!< (@ 0x00000740) Trim value override register 7 for nRF52                   */
  __IOM uint32_t  QOVERRIDE8;                   /*!< (@ 0x00000744) Trim value override register 8 for nRF52                   */
  __IOM uint32_t  QOVERRIDE9;                   /*!< (@ 0x00000748) Trim value override register 9 for nRF52                   */
  __IOM uint32_t  QOVERRIDE10;                  /*!< (@ 0x0000074C) Trim value override register 10 for nRF52                  */
  __IOM uint32_t  QOVERRIDE11;                  /*!< (@ 0x00000750) Trim value override register 11 for nRF52                  */
  __IOM uint32_t  QOVERRIDE12;                  /*!< (@ 0x00000754) Trim value override register 12 for nRF52                  */
  __IOM uint32_t  QOVERRIDE13;                  /*!< (@ 0x00000758) Trim value override register 13 for nRF52                  */
  __IOM uint32_t  QOVERRIDE14;                  /*!< (@ 0x0000075C) Trim value override register 14 for nRF52                  */
  __IOM uint32_t  QOVERRIDE15;                  /*!< (@ 0x00000760) Trim value override register 15 for nRF52                  */
  __IOM uint32_t  QOVERRIDE16;                  /*!< (@ 0x00000764) Trim value override register 16 for nRF52                  */
  __IOM uint32_t  QOVERRIDE17;                  /*!< (@ 0x00000768) Trim value override register 17 for nRF52                  */
  __IOM uint32_t  QOVERRIDE18;                  /*!< (@ 0x0000076C) Trim value override register 18 for nRF52                  */
  __IOM uint32_t  QOVERRIDE19;                  /*!< (@ 0x00000770) Trim value override register 19 for nRF52                  */
  __IOM uint32_t  QOVERRIDE20;                  /*!< (@ 0x00000774) Trim value override register 20 for nRF52                  */
  __IOM uint32_t  QOVERRIDE21;                  /*!< (@ 0x00000778) Trim value override register 21 for nRF52                  */
  __IOM uint32_t  QOVERRIDE22;                  /*!< (@ 0x0000077C) Trim value override register 22 for nRF52                  */
  __IOM uint32_t  QOVERRIDE23;                  /*!< (@ 0x00000780) Trim value override register 23 for nRF52                  */
  __IM  uint32_t  RESERVED29;
  __IOM uint32_t  QOVERRIDE25;                  /*!< (@ 0x00000788) Unspecified                                                */
  __IOM uint32_t  DBCPEAKDETTHR;                /*!< (@ 0x0000078C) Thresholds for each peak detector instance                 */
  __IM  uint32_t  RESERVED30[28];
  __IOM RADIO_DEBUGPSEL_Type DEBUGPSEL;         /*!< (@ 0x00000800) Unspecified                                                */
  __IM  uint32_t  RESERVED31[5];
  __IOM uint32_t  ATEPANTHER;                   /*!< (@ 0x0000081C) Analog test bus control for Panther radio                  */
  __IM  uint32_t  RESERVED32[2];
  __IOM uint32_t  RFMATCHTUNE;                  /*!< (@ 0x00000828) Adjust transformation ratio of on-chip matching
                                                                    Can be used for: 1) Optimise power consumption
                                                                    for different output power levels in TX
                                                                    mode 2) Optimise input impedance in RX mode.               */
  __IM  uint32_t  RESERVED33[53];
  __IOM uint32_t  DFEMODE;                      /*!< (@ 0x00000900) Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure
                                                                    (AOD)                                                      */
  __IOM uint32_t  CTEINLINECONF;                /*!< (@ 0x00000904) Configuration for CTE inline mode                          */
  __IM  uint32_t  RESERVED34[2];
  __IOM uint32_t  DFECTRL1;                     /*!< (@ 0x00000910) Various configuration for Direction finding                */
  __IOM uint32_t  DFECTRL2;                     /*!< (@ 0x00000914) Start offset for Direction finding                         */
  __IOM uint32_t  DFECTRL3;                     /*!< (@ 0x00000918) Various hacker/tuning configuration for Direction
                                                                    finding                                                    */
  __IOM uint32_t  DFECTRL4;                     /*!< (@ 0x0000091C) Various hacker/tuning configuration for Direction
                                                                    finding                                                    */
  __IOM uint32_t  DFECTRL5;                     /*!< (@ 0x00000920) Various hacker/tuning configuration for Direction
                                                                    finding                                                    */
  __IM  uint32_t  RESERVED35;
  __IOM uint32_t  SWITCHPATTERN;                /*!< (@ 0x00000928) GPIO patterns to be used for each antenna                  */
  __IOM uint32_t  CLEARPATTERN;                 /*!< (@ 0x0000092C) Clear the GPIO pattern array for antenna control           */
  __IOM RADIO_PSEL_Type PSEL;                   /*!< (@ 0x00000930) Unspecified                                                */
  __IOM RADIO_DFEPACKET_Type DFEPACKET;         /*!< (@ 0x00000950) DFE packet EasyDMA channel                                 */
  __IM  uint32_t  RESERVED36;
  __IOM uint32_t  DFEDMAEND;                    /*!< (@ 0x00000960) END event for DFE DMA without PPI nor IRQ                  */
  __IOM uint32_t  DFEDMASTART;                  /*!< (@ 0x00000964) Manually start DmaChannelPeripheral for DFE                */
  __IOM uint32_t  DFEDMASTOP;                   /*!< (@ 0x00000968) Force stop DmaChannelPeripheral for DFE                    */
  __IM  uint32_t  RESERVED37[49];
  __IOM uint32_t  ACQENABLE;                    /*!< (@ 0x00000A30) Enable or disable data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM RADIO_ACQDMA_Type ACQDMA;               /*!< (@ 0x00000A34) EasyDMA channel for data acquisition (refer to
                                                                    4378_164)                                                  */
  __IOM uint32_t  ACQMODE;                      /*!< (@ 0x00000A40) Data acquisition capture mode (refer to 4378_164)          */
  __IOM uint32_t  ACQAHBCNF;                    /*!< (@ 0x00000A44) Data acquisition EasyDMA AHB configuration register
                                                                    (refer to 4378_164)                                        */
  __IM  uint32_t  RESERVED38[110];
  __IOM uint32_t  PCGC_PENALTY;                 /*!< (@ 0x00000C00) Power and clock                                            */
  __IM  uint32_t  RESERVED39[3];
  __IOM uint32_t  PCGC_OVERRIDE;                /*!< (@ 0x00000C10) Power and clock                                            */
  __IM  uint32_t  RESERVED40[3];
  __IOM uint32_t  PCGC_CLK_REQ;                 /*!< (@ 0x00000C20) Power and clock                                            */
  __IM  uint32_t  RESERVED41[55];
  __IOM uint32_t  PCGC_BACKDOOR;                /*!< (@ 0x00000D00) Power and clock                                            */
  __IOM uint32_t  PCGC_FORCEREG;                /*!< (@ 0x00000D04) Power and clock                                            */
  __IM  uint32_t  RESERVED42[189];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RADIO_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Random Number Generator (RNG)
  */

typedef struct {                                /*!< (@ 0x40003000) RNG Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the random number generator                  */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the random number generator                  */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_VALRDY;                /*!< (@ 0x00000100) Event being generated for every new random number
                                                                    written to the VALUE register                              */
  __IM  uint32_t  RESERVED2[31];
  __IOM uint32_t  PUBLISH_VALRDY;               /*!< (@ 0x00000180) Publish configuration for event VALRDY                     */
  __IM  uint32_t  RESERVED3[31];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[126];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IM  uint32_t  VALUE;                        /*!< (@ 0x00000508) Output random number                                       */
  __IM  uint32_t  RESERVED6[700];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_RNG_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          GPIOTE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events (GPIOTE)
  */

typedef struct {                                /*!< (@ 0x40004000) GPIOTE Structure                                           */
  __OM  uint32_t  TASKS_OUT[2];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[10];
  __OM  uint32_t  TASKS_SET[2];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[10];
  __OM  uint32_t  TASKS_CLR[2];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IM  uint32_t  RESERVED2[6];
  __IOM uint32_t  SUBSCRIBE_OUT[2];             /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task OUT[n]                                            */
  __IM  uint32_t  RESERVED3[10];
  __IOM uint32_t  SUBSCRIBE_SET[2];             /*!< (@ 0x000000B0) Description collection: Subscribe configuration
                                                                    for task SET[n]                                            */
  __IM  uint32_t  RESERVED4[10];
  __IOM uint32_t  SUBSCRIBE_CLR[2];             /*!< (@ 0x000000E0) Description collection: Subscribe configuration
                                                                    for task CLR[n]                                            */
  __IM  uint32_t  RESERVED5[6];
  __IOM uint32_t  EVENTS_IN[2];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED6[29];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IOM uint32_t  PUBLISH_IN[2];                /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event IN[n]                                            */
  __IM  uint32_t  RESERVED7[29];
  __IOM uint32_t  PUBLISH_PORT;                 /*!< (@ 0x000001FC) Publish configuration for event PORT                       */
  __IM  uint32_t  RESERVED8[64];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED9[129];
  __IOM uint32_t  CONFIG[2];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
  __IM  uint32_t  RESERVED10[58];
  __IOM uint32_t  DEBOUNCE[2];                  /*!< (@ 0x00000600) Description collection: Debounce mode for GPIOTE
                                                                    channel n                                                  */
  __IM  uint32_t  RESERVED11[446];
  __OM  GPIOTE_TASKS_PCPPEN_Type TASKS_PCPPEN[5];/*!< (@ 0x00000D00) Peripheral tasks.                                         */
  __IM  uint32_t  RESERVED12[22];
  __IOM GPIOTE_SUBSCRIBE_PCPPEN_Type SUBSCRIBE_PCPPEN[5];/*!< (@ 0x00000D80) Subscribe configuration for tasks                 */
  __IM  uint32_t  RESERVED13[149];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_GPIOTE_Type;                              /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer (WDT)
  */

typedef struct {                                /*!< (@ 0x40005000) WDT Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the watchdog                                         */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop the watchdog timer.                                   */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_TIMEOUT;               /*!< (@ 0x00000100) Watchdog timeout                                           */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Watchdog stopped                                           */
  __IM  uint32_t  RESERVED2[30];
  __IOM uint32_t  PUBLISH_TIMEOUT;              /*!< (@ 0x00000180) Publish configuration for event TIMEOUT                    */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[61];
  __IM  uint32_t  RUNSTATUS;                    /*!< (@ 0x00000400) Run status                                                 */
  __IM  uint32_t  REQSTATUS;                    /*!< (@ 0x00000404) Request status                                             */
  __IM  uint32_t  RCNT;                         /*!< (@ 0x00000408) Reload count                                               */
  __IM  uint32_t  RESERVED5[62];
  __IOM uint32_t  CRV;                          /*!< (@ 0x00000504) Counter reload value                                       */
  __IOM uint32_t  RREN;                         /*!< (@ 0x00000508) Enable register for reload request registers               */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000050C) Configuration register                                     */
  __IOM uint32_t  RRKEY;                        /*!< (@ 0x00000510) Reload request key                                         */
  __IM  uint32_t  RESERVED6[59];
  __OM  uint32_t  RR[8];                        /*!< (@ 0x00000600) Description collection: Reload request n                   */
} NRF_WDT_Type;                                 /*!< Size = 1568 (0x620)                                                       */



/* =========================================================================================================================== */
/* ================                                          TIMER0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0)
  */

typedef struct {                                /*!< (@ 0x40006000) TIMER0 Structure                                           */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start Timer                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop Timer                                                 */
  __OM  uint32_t  TASKS_COUNT;                  /*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x0000000C) Clear time                                                 */
  __OM  uint32_t  TASKS_SHUTDOWN;               /*!< (@ 0x00000010) Deprecated register - Shut down timer                      */
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[8];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[8];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_COUNT;              /*!< (@ 0x00000088) Subscribe configuration for task COUNT                     */
  __IOM uint32_t  SUBSCRIBE_CLEAR;              /*!< (@ 0x0000008C) Subscribe configuration for task CLEAR                     */
  __IOM uint32_t  SUBSCRIBE_SHUTDOWN;           /*!< (@ 0x00000090) Deprecated register - Subscribe configuration
                                                                    for task SHUTDOWN                                          */
  __IM  uint32_t  RESERVED2[11];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[8];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[24];
  __IOM uint32_t  EVENTS_COMPARE[8];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  PUBLISH_COMPARE[8];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[8];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED6[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Timer mode selection                                       */
  __IOM uint32_t  BITMODE;                      /*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000510) Timer prescaler register                                   */
  __IM  uint32_t  RESERVED9[11];
  __IOM uint32_t  CC[8];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
  __IM  uint32_t  RESERVED10[679];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TIMER_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            ECB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES ECB Mode Encryption (ECB)
  */

typedef struct {                                /*!< (@ 0x40009000) ECB Structure                                              */
  __OM  uint32_t  TASKS_STARTECB;               /*!< (@ 0x00000000) Start ECB block encrypt                                    */
  __OM  uint32_t  TASKS_STOPECB;                /*!< (@ 0x00000004) Abort a possible executing ECB operation                   */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_STARTECB;           /*!< (@ 0x00000080) Subscribe configuration for task STARTECB                  */
  __IOM uint32_t  SUBSCRIBE_STOPECB;            /*!< (@ 0x00000084) Subscribe configuration for task STOPECB                   */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_ENDECB;                /*!< (@ 0x00000100) ECB block encrypt complete                                 */
  __IOM uint32_t  EVENTS_ERRORECB;              /*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
                                                                    task or due to an error                                    */
  __IM  uint32_t  RESERVED2[30];
  __IOM uint32_t  PUBLISH_ENDECB;               /*!< (@ 0x00000180) Publish configuration for event ENDECB                     */
  __IOM uint32_t  PUBLISH_ERRORECB;             /*!< (@ 0x00000184) Publish configuration for event ERRORECB                   */
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[126];
  __IOM uint32_t  ECBDATAPTR;                   /*!< (@ 0x00000504) ECB block encrypt memory pointers                          */
  __IM  uint32_t  RESERVED5[701];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_ECB_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            AAR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Accelerated Address Resolver (AAR)
  */

typedef struct {                                /*!< (@ 0x4000A000) AAR Structure                                              */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
                                                                    in the IRK data structure                                  */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop resolving addresses                                   */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000088) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED3[29];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000100) Address resolution procedure complete                      */
  __IOM uint32_t  EVENTS_RESOLVED;              /*!< (@ 0x00000104) Address resolved                                           */
  __IOM uint32_t  EVENTS_NOTRESOLVED;           /*!< (@ 0x00000108) Address not resolved                                       */
  __IM  uint32_t  RESERVED4[29];
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000180) Publish configuration for event END                        */
  __IOM uint32_t  PUBLISH_RESOLVED;             /*!< (@ 0x00000184) Publish configuration for event RESOLVED                   */
  __IOM uint32_t  PUBLISH_NOTRESOLVED;          /*!< (@ 0x00000188) Publish configuration for event NOTRESOLVED                */
  __IM  uint32_t  RESERVED5[93];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Resolution status                                          */
  __IM  uint32_t  RESERVED7[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable AAR                                                 */
  __IOM uint32_t  NIRK;                         /*!< (@ 0x00000504) Number of IRKs                                             */
  __IOM uint32_t  IRKPTR;                       /*!< (@ 0x00000508) Pointer to IRK data structure                              */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  ADDRPTR;                      /*!< (@ 0x00000510) Pointer to the resolvable address                          */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IM  uint32_t  RESERVED9[697];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_AAR_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            CCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES CCM mode encryption (CCM)
  */

typedef struct {                                /*!< (@ 0x4000A000) CCM Structure                                              */
  __OM  uint32_t  TASKS_KSGEN;                  /*!< (@ 0x00000000) Start generation of keystream. This operation
                                                                    will stop by itself when completed.                        */
  __OM  uint32_t  TASKS_CRYPT;                  /*!< (@ 0x00000004) Start encryption/decryption. This operation will
                                                                    stop by itself when completed.                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop encryption/decryption                                 */
  __OM  uint32_t  TASKS_RATEOVERRIDE;           /*!< (@ 0x0000000C) Override DATARATE setting in MODE register with
                                                                    the contents of the RATEOVERRIDE register
                                                                    for any ongoing encryption/decryption                      */
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_KSGEN;              /*!< (@ 0x00000080) Subscribe configuration for task KSGEN                     */
  __IOM uint32_t  SUBSCRIBE_CRYPT;              /*!< (@ 0x00000084) Subscribe configuration for task CRYPT                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000088) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_RATEOVERRIDE;       /*!< (@ 0x0000008C) Subscribe configuration for task RATEOVERRIDE              */
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_ENDKSGEN;              /*!< (@ 0x00000100) Keystream generation complete                              */
  __IOM uint32_t  EVENTS_ENDCRYPT;              /*!< (@ 0x00000104) Encrypt/decrypt complete                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000108) Deprecated register - CCM error event                      */
  __IM  uint32_t  RESERVED2[29];
  __IOM uint32_t  PUBLISH_ENDKSGEN;             /*!< (@ 0x00000180) Publish configuration for event ENDKSGEN                   */
  __IOM uint32_t  PUBLISH_ENDCRYPT;             /*!< (@ 0x00000184) Publish configuration for event ENDCRYPT                   */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x00000188) Deprecated register - Publish configuration for
                                                                    event ERROR                                                */
  __IM  uint32_t  RESERVED3[29];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[64];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  MICSTATUS;                    /*!< (@ 0x00000400) MIC check result                                           */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable                                                     */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Operation mode                                             */
  __IOM uint32_t  CNFPTR;                       /*!< (@ 0x00000508) Pointer to data structure holding the AES key
                                                                    and the NONCE vector                                       */
  __IOM uint32_t  INPTR;                        /*!< (@ 0x0000050C) Input pointer                                              */
  __IOM uint32_t  OUTPTR;                       /*!< (@ 0x00000510) Output pointer                                             */
  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
  __IOM uint32_t  MAXPACKETSIZE;                /*!< (@ 0x00000518) Length of keystream generated when MODE.LENGTH
                                                                    = Extended                                                 */
  __IOM uint32_t  RATEOVERRIDE;                 /*!< (@ 0x0000051C) Data rate override setting.                                */
  __IM  uint32_t  RESERVED7[695];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_CCM_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           DPPIC                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Distributed programmable peripheral interconnect controller (DPPIC)
  */

typedef struct {                                /*!< (@ 0x4000B000) DPPIC Structure                                            */
  __OM  DPPIC_TASKS_CHG_Type TASKS_CHG[6];      /*!< (@ 0x00000000) Channel group tasks                                        */
  __IM  uint32_t  RESERVED[20];
  __IOM DPPIC_SUBSCRIBE_CHG_Type SUBSCRIBE_CHG[6];/*!< (@ 0x00000080) Subscribe configuration for tasks                        */
  __IM  uint32_t  RESERVED1[276];
  __IOM uint32_t  CHEN;                         /*!< (@ 0x00000500) Channel enable register                                    */
  __IOM uint32_t  CHENSET;                      /*!< (@ 0x00000504) Channel enable set register                                */
  __IOM uint32_t  CHENCLR;                      /*!< (@ 0x00000508) Channel enable clear register                              */
  __IM  uint32_t  RESERVED2[189];
  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n Note:
                                                                    Writes to this register are ignored if either
                                                                    SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS
                                                                    is enabled                                                 */
} NRF_DPPIC_Type;                               /*!< Size = 2072 (0x818)                                                       */



/* =========================================================================================================================== */
/* ================                                           RTC0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real-time counter 0 (RTC0)
  */

typedef struct {                                /*!< (@ 0x4000C000) RTC0 Structure                                             */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start RTC counter                                          */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop RTC counter                                           */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x00000008) Clear RTC counter                                          */
  __OM  uint32_t  TASKS_TRIGOVRFLW;             /*!< (@ 0x0000000C) Set counter to 0xFFFFF0                                    */
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_CLEAR;              /*!< (@ 0x00000088) Subscribe configuration for task CLEAR                     */
  __IOM uint32_t  SUBSCRIBE_TRIGOVRFLW;         /*!< (@ 0x0000008C) Subscribe configuration for task TRIGOVRFLW                */
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_TICK;                  /*!< (@ 0x00000100) Event on counter increment                                 */
  __IOM uint32_t  EVENTS_OVRFLW;                /*!< (@ 0x00000104) Event on counter overflow                                  */
  __IM  uint32_t  RESERVED2[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED3[12];
  __IOM uint32_t  PUBLISH_TICK;                 /*!< (@ 0x00000180) Publish configuration for event TICK                       */
  __IOM uint32_t  PUBLISH_OVRFLW;               /*!< (@ 0x00000184) Publish configuration for event OVRFLW                     */
  __IM  uint32_t  RESERVED4[14];
  __IOM uint32_t  PUBLISH_COMPARE[4];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[76];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[13];
  __IOM uint32_t  EVTEN;                        /*!< (@ 0x00000340) Enable or disable event routing                            */
  __IOM uint32_t  EVTENSET;                     /*!< (@ 0x00000344) Enable event routing                                       */
  __IOM uint32_t  EVTENCLR;                     /*!< (@ 0x00000348) Disable event routing                                      */
  __IM  uint32_t  RESERVED7[110];
  __IM  uint32_t  COUNTER;                      /*!< (@ 0x00000504) Current counter value                                      */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12-bit prescaler for counter frequency (32768/(PRESCALER+1)).
                                                                    Must be written when RTC is stopped.                       */
  __IM  uint32_t  RESERVED8[13];
  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection: Compare register n                 */
} NRF_RTC_Type;                                 /*!< Size = 1360 (0x550)                                                       */



/* =========================================================================================================================== */
/* ================                                           SPIM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA (SPIM0)
  */

typedef struct {                                /*!< (@ 0x4000E000) SPIM0 Structure                                            */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000010) Start SPI transaction                                      */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop SPI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend SPI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume SPI transaction                                     */
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000090) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) SPI transaction has stopped                                */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000118) End of RXD buffer and TXD buffer reached                   */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) End of TXD buffer reached                                  */
  __IM  uint32_t  RESERVED8[10];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x0000014C) Transaction started                                        */
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000198) Publish configuration for event END                        */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IM  uint32_t  RESERVED13[10];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x000001CC) Publish configuration for event STARTED                    */
  __IM  uint32_t  RESERVED14[12];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED15[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED16[61];
  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
                                                                    in this register is set to STALL by hardware
                                                                    whenever a stall occurres and can be cleared
                                                                    (set to NOSTALL) by the CPU.                               */
  __IM  uint32_t  RESERVED17[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPIM                                                */
  __IM  uint32_t  RESERVED18;
  __IOM SPIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RXDDATA;                      /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXDDATA;                      /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED19;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED20[3];
  __IOM SPIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM SPIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED21[2];
  __IOM SPIM_IFTIMING_Type IFTIMING;            /*!< (@ 0x00000560) Unspecified                                                */
  __IOM uint32_t  CSNPOL;                       /*!< (@ 0x00000568) Polarity of CSN output                                     */
  __IOM uint32_t  PSELDCX;                      /*!< (@ 0x0000056C) Pin select for DCX signal                                  */
  __IOM uint32_t  DCXCNT;                       /*!< (@ 0x00000570) DCX configuration                                          */
  __IM  uint32_t  RESERVED22[19];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
                                                                    been transmitted in the case when RXD.MAXCNT
                                                                    is greater than TXD.MAXCNT                                 */
  __IM  uint32_t  RESERVED23[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIM_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPIS0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave (SPIS0)
  */

typedef struct {                                /*!< (@ 0x4000E000) SPIS0 Structure                                            */
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;                /*!< (@ 0x00000024) Acquire SPI semaphore                                      */
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_ACQUIRE;            /*!< (@ 0x000000A4) Subscribe configuration for task ACQUIRE                   */
  __IOM uint32_t  SUBSCRIBE_RELEASE;            /*!< (@ 0x000000A8) Subscribe configuration for task RELEASE                   */
  __IM  uint32_t  RESERVED2[22];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) Granted transaction completed                              */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_ACQUIRED;              /*!< (@ 0x00000128) Semaphore acquired                                         */
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000184) Publish configuration for event END                        */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED7[5];
  __IOM uint32_t  PUBLISH_ACQUIRED;             /*!< (@ 0x000001A8) Publish configuration for event ACQUIRED                   */
  __IM  uint32_t  RESERVED8[21];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED9[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED10[61];
  __IM  uint32_t  SEMSTAT;                      /*!< (@ 0x00000400) Semaphore status register                                  */
  __IM  uint32_t  RESERVED11[15];
  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000440) Status from last transaction                               */
  __IM  uint32_t  RESERVED12[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI slave                                           */
  __IM  uint32_t  RESERVED13;
  __IOM SPIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED14[7];
  __IOM SPIS_RXD_Type RXD;                      /*!< (@ 0x00000534) Unspecified                                                */
  __IOM SPIS_TXD_Type TXD;                      /*!< (@ 0x00000544) Unspecified                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED16[24];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character                                        */
  __IM  uint32_t  RESERVED17[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPIS_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          UARTE0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA (UARTE0)
  */

typedef struct {                                /*!< (@ 0x4000E000) UARTE0 Structure                                           */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART transaction                                   */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume UART transaction                                    */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_FLUSHRX;                /*!< (@ 0x0000002C) Flush RX FIFO into RX buffer                               */
  __IM  uint32_t  RESERVED2[20];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IOM uint32_t  SUBSCRIBE_STOPRX;             /*!< (@ 0x00000084) Subscribe configuration for task STOPRX                    */
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IOM uint32_t  SUBSCRIBE_STOPTX;             /*!< (@ 0x0000008C) Subscribe configuration for task STOPTX                    */
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  SUBSCRIBE_FLUSHRX;            /*!< (@ 0x000000AC) Subscribe configuration for task FLUSHRX                   */
  __IM  uint32_t  RESERVED5[20];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) Receive buffer is filled up                                */
  __IM  uint32_t  RESERVED7[2];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) Last TX byte transmitted                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED8[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) UART receiver has started                                  */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) UART transmitter has started                               */
  __IOM uint32_t  EVENTS_RTS;                   /*!< (@ 0x00000154) RX FIFO has only room for four more bytes before
                                                                    it overflows                                               */
  __IOM uint32_t  EVENTS_TXSTOPPED;             /*!< (@ 0x00000158) Transmitter stopped                                        */
  __IM  uint32_t  RESERVED10[9];
  __IOM uint32_t  PUBLISH_CTS;                  /*!< (@ 0x00000180) Publish configuration for event CTS                        */
  __IOM uint32_t  PUBLISH_NCTS;                 /*!< (@ 0x00000184) Publish configuration for event NCTS                       */
  __IOM uint32_t  PUBLISH_RXDRDY;               /*!< (@ 0x00000188) Publish configuration for event RXDRDY                     */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED12[2];
  __IOM uint32_t  PUBLISH_TXDRDY;               /*!< (@ 0x0000019C) Publish configuration for event TXDRDY                     */
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED13[7];
  __IOM uint32_t  PUBLISH_RXTO;                 /*!< (@ 0x000001C4) Publish configuration for event RXTO                       */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IOM uint32_t  PUBLISH_RTS;                  /*!< (@ 0x000001D4) Publish configuration for event RTS                        */
  __IOM uint32_t  PUBLISH_TXSTOPPED;            /*!< (@ 0x000001D8) Publish configuration for event TXSTOPPED                  */
  __IM  uint32_t  RESERVED15[9];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED17[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source This register is read/write one
                                                                    to clear.                                                  */
  __IM  uint32_t  RESERVED18[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED19;
  __IOM UARTE_PSEL_Type PSEL;                   /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED20[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED21[3];
  __IOM UARTE_RXD_Type RXD;                     /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED22;
  __IOM UARTE_TXD_Type TXD;                     /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED23[7];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
  __IM  uint32_t  RESERVED24[675];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_UARTE_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWIM1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA (TWIM1)
  */

typedef struct {                                /*!< (@ 0x4000F000) TWIM1 Structure                                            */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer access by EasyDMA                        */
  __IM  uint32_t  RESERVED9[3];
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) END of TXD buffer access by EasyDMA                        */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED11[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
                                                                    now suspended.                                             */
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED12[2];
  __IOM uint32_t  EVENTS_LASTRX;                /*!< (@ 0x0000015C) Byte boundary, starting to receive the last byte           */
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED13[8];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED14[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED15[3];
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED16[4];
  __IOM uint32_t  PUBLISH_BB;                   /*!< (@ 0x000001B8) Publish configuration for event BB                         */
  __IM  uint32_t  RESERVED17[3];
  __IOM uint32_t  PUBLISH_SUSPENDED;            /*!< (@ 0x000001C8) Publish configuration for event SUSPENDED                  */
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IM  uint32_t  RESERVED18[2];
  __IOM uint32_t  PUBLISH_LASTRX;               /*!< (@ 0x000001DC) Publish configuration for event LASTRX                     */
  __IOM uint32_t  PUBLISH_LASTTX;               /*!< (@ 0x000001E0) Publish configuration for event LASTTX                     */
  __IM  uint32_t  RESERVED19[7];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED20[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED21[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED22[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIM                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IOM TWIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED23[5];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED24[3];
  __IOM TWIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED25[13];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
  __IM  uint32_t  RESERVED26[668];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWIM_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TWIS1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA (TWIS1)
  */

typedef struct {                                /*!< (@ 0x4000F000) TWIS1 Structure                                            */
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;              /*!< (@ 0x00000030) Prepare the TWI slave to respond to a write command        */
  __OM  uint32_t  TASKS_PREPARETX;              /*!< (@ 0x00000034) Prepare the TWI slave to respond to a read command         */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  SUBSCRIBE_PREPARERX;          /*!< (@ 0x000000B0) Subscribe configuration for task PREPARERX                 */
  __IOM uint32_t  SUBSCRIBE_PREPARETX;          /*!< (@ 0x000000B4) Subscribe configuration for task PREPARETX                 */
  __IM  uint32_t  RESERVED6[19];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  EVENTS_NACKTX;                /*!< (@ 0x00000134) NACK on TX                                                 */
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED9[4];
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  EVENTS_WRITE;                 /*!< (@ 0x00000164) Write command received                                     */
  __IOM uint32_t  EVENTS_READ;                  /*!< (@ 0x00000168) Read command received                                      */
  __IOM uint32_t  EVENTS_CSSTARTED;             /*!< (@ 0x0000016C) TWI started stretching the clock                           */
  __IOM uint32_t  EVENTS_CSSTOPPED;             /*!< (@ 0x00000170) TWI stopped stretching the clock                           */
  __IM  uint32_t  RESERVED11[4];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED13[3];
  __IOM uint32_t  PUBLISH_NACKTX;               /*!< (@ 0x000001B4) Publish configuration for event NACKTX                     */
  __IOM uint32_t  PUBLISH_BB;                   /*!< (@ 0x000001B8) Publish configuration for event BB                         */
  __IM  uint32_t  RESERVED14[4];
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IM  uint32_t  RESERVED15[4];
  __IOM uint32_t  PUBLISH_WRITE;                /*!< (@ 0x000001E4) Publish configuration for event WRITE                      */
  __IOM uint32_t  PUBLISH_READ;                 /*!< (@ 0x000001E8) Publish configuration for event READ                       */
  __IOM uint32_t  PUBLISH_CSSTARTED;            /*!< (@ 0x000001EC) Publish configuration for event CSSTARTED                  */
  __IOM uint32_t  PUBLISH_CSSTOPPED;            /*!< (@ 0x000001F0) Publish configuration for event CSSTOPPED                  */
  __IM  uint32_t  RESERVED16[3];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED17[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED18[113];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004D0) Error source                                               */
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  PINSTATUS;                    /*!< (@ 0x000004D8) Returns state of signals reflecting the SDA and
                                                                    SCL line status. All fields will return
                                                                    a '0' if DEBUGENABLE is not Enabled.                       */
  __IM  uint32_t  RESERVED19[9];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIS                                                */
  __IM  uint32_t  RESERVED20;
  __IOM TWIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED21[9];
  __IOM TWIS_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIS_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED22[13];
  __IOM uint32_t  ADDRESS[2];                   /*!< (@ 0x00000588) Description collection: TWI slave address n                */
  __IM  uint32_t  RESERVED23;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED24[2];
  __IOM uint32_t  INPUTMODE;                    /*!< (@ 0x000005A0) Input mode                                                 */
  __IOM uint32_t  DEBUGENABLE;                  /*!< (@ 0x000005A4) Enable TWIS debug features (PINSTATUS register)            */
  __IM  uint32_t  RESERVED25[6];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
  __IM  uint32_t  RESERVED26[654];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWIS_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           QDEC0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder (QDEC0)
  */

typedef struct {                                /*!< (@ 0x40012000) QDEC0 Structure                                            */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the quadrature decoder                       */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
  __OM  uint32_t  TASKS_READCLRACC;             /*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
  __OM  uint32_t  TASKS_RDCLRACC;               /*!< (@ 0x0000000C) Read and clear ACC                                         */
  __OM  uint32_t  TASKS_RDCLRDBL;               /*!< (@ 0x00000010) Read and clear ACCDBL                                      */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_READCLRACC;         /*!< (@ 0x00000088) Subscribe configuration for task READCLRACC                */
  __IOM uint32_t  SUBSCRIBE_RDCLRACC;           /*!< (@ 0x0000008C) Subscribe configuration for task RDCLRACC                  */
  __IOM uint32_t  SUBSCRIBE_RDCLRDBL;           /*!< (@ 0x00000090) Subscribe configuration for task RDCLRDBL                  */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;             /*!< (@ 0x00000104) Non-null report ready                                      */
  __IOM uint32_t  EVENTS_ACCOF;                 /*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
  __IOM uint32_t  EVENTS_DBLRDY;                /*!< (@ 0x0000010C) Double displacement(s) detected                            */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000110) QDEC has been stopped                                      */
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  PUBLISH_SAMPLERDY;            /*!< (@ 0x00000180) Publish configuration for event SAMPLERDY                  */
  __IOM uint32_t  PUBLISH_REPORTRDY;            /*!< (@ 0x00000184) Publish configuration for event REPORTRDY                  */
  __IOM uint32_t  PUBLISH_ACCOF;                /*!< (@ 0x00000188) Publish configuration for event ACCOF                      */
  __IOM uint32_t  PUBLISH_DBLRDY;               /*!< (@ 0x0000018C) Publish configuration for event DBLRDY                     */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000190) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED3[27];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable the quadrature decoder                              */
  __IOM uint32_t  LEDPOL;                       /*!< (@ 0x00000504) LED output pin polarity                                    */
  __IOM uint32_t  SAMPLEPER;                    /*!< (@ 0x00000508) Sample period                                              */
  __IM  int32_t   SAMPLE;                       /*!< (@ 0x0000050C) Motion sample value                                        */
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
                                                                    and DBLRDY events can be generated                         */
  __IM  int32_t   ACC;                          /*!< (@ 0x00000514) Register accumulating the valid transitions                */
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC or RDCLRACC task                                */
  __IOM QDEC_PSEL_Type PSEL;                    /*!< (@ 0x0000051C) Unspecified                                                */
  __IOM uint32_t  DBFEN;                        /*!< (@ 0x00000528) Enable input debounce filters                              */
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  LEDPRE;                       /*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    or RDCLRDBL task                                           */
  __IM  uint32_t  RESERVED7[684];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_QDEC_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SAADC                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter (SAADC)
  */

typedef struct {                                /*!< (@ 0x40014000) SAADC Structure                                            */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the ADC and prepare the result buffer in
                                                                    RAM                                                        */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Take one ADC sample, if scan is enabled all channels
                                                                    are sampled                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop the ADC and terminate any on-going conversion         */
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;        /*!< (@ 0x0000000C) Starts offset auto-calibration                             */
  __OM  uint32_t  TASKS_CALIBRATEGAIN;          /*!< (@ 0x00000010) Starts gain auto-calibration                               */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_SAMPLE;             /*!< (@ 0x00000084) Subscribe configuration for task SAMPLE                    */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000088) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_CALIBRATEOFFSET;    /*!< (@ 0x0000008C) Subscribe configuration for task CALIBRATEOFFSET           */
  __IOM uint32_t  SUBSCRIBE_CALIBRATEGAIN;      /*!< (@ 0x00000090) Subscribe configuration for task CALIBRATEGAIN             */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) The ADC has started                                        */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) The ADC has filled up the Result buffer                    */
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the mode, multiple conversions might
                                                                    be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;            /*!< (@ 0x0000010C) A result is ready to get transferred to RAM.
                                                                    Result is available in REGRESULT register                  */
  __IOM uint32_t  EVENTS_CALIBRATEDONE;         /*!< (@ 0x00000110) Calibration is complete                                    */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000114) The ADC has stopped                                        */
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];      /*!< (@ 0x00000118) Peripheral events.                                         */
  __IM  uint32_t  RESERVED2[10];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x00000180) Publish configuration for event STARTED                    */
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000184) Publish configuration for event END                        */
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x00000188) Publish configuration for event DONE                       */
  __IOM uint32_t  PUBLISH_RESULTDONE;           /*!< (@ 0x0000018C) Publish configuration for event RESULTDONE                 */
  __IOM uint32_t  PUBLISH_CALIBRATEDONE;        /*!< (@ 0x00000190) Publish configuration for event CALIBRATEDONE              */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000194) Publish configuration for event STOPPED                    */
  __IOM SAADC_PUBLISH_CH_Type PUBLISH_CH[8];    /*!< (@ 0x00000198) Publish configuration for events                           */
  __IM  uint32_t  RESERVED3[10];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Status                                                     */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable or disable ADC                                      */
  __IM  uint32_t  RESERVED7[3];
  __IOM SAADC_CH_Type CH[8];                    /*!< (@ 0x00000510) Unspecified                                                */
  __IM  uint32_t  RESERVED8[23];
  __IM  uint32_t  REGRESULT;                    /*!< (@ 0x000005EC) Last conversion result                                     */
  __IOM uint32_t  RESOLUTION;                   /*!< (@ 0x000005F0) Resolution configuration                                   */
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. OVERSAMPLE should
                                                                    not be combined with SCAN. The RESOLUTION
                                                                    is applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;                   /*!< (@ 0x000005F8) Controls normal or continuous sample rate                  */
  __IM  uint32_t  RESERVED9[12];
  __IOM SAADC_RESULT_Type RESULT;               /*!< (@ 0x0000062C) RESULT EasyDMA channel                                     */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  TESTCTRL;                     /*!< (@ 0x0000063C) Control signals used during test of ADC                    */
  __IOM uint32_t  CALOFFSET;                    /*!< (@ 0x00000640) Calibration control for offset error                       */
  __IOM uint32_t  CALGAIN;                      /*!< (@ 0x00000644) Calibration control for gain error                         */
  __IOM uint32_t  CALVREF;                      /*!< (@ 0x00000648) Calibration control for reference voltage                  */
  __IM  uint32_t  RESERVED11[620];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SAADC_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           EGU0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit (EGU0)
  */

typedef struct {                                /*!< (@ 0x40017000) EGU0 Structure                                             */
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_TRIGGER[16];        /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task TRIGGER[n]                                        */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_TRIGGERED[16];        /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event TRIGGERED[n]                                     */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
} NRF_EGU_Type;                                 /*!< Size = 780 (0x30c)                                                        */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_FICR_BASE               0x10000000UL
#define NRF_UICR_BASE               0x10001000UL
#define NRF_PAMLI_BASE              0x40020000UL
#define NRF_VMC_BASE                0x40022000UL
#define NRF_NVMC_BASE               0x40023000UL
#define NRF_BPROT_BASE              0x40024000UL
#define NRF_RAMBIST0_BASE           0x40025000UL
#define NRF_RCOSC32K_BASE           0x40027000UL
#define NRF_PCGCSLAVE_AMLI_BASE     0x41000000UL
#define NRF_PCGCMASTER0_BASE        0x41001000UL
#define NRF_CLOCK_BASE              0x40000000UL
#define NRF_POWER_BASE              0x40000000UL
#define NRF_RESET_BASE              0x40000000UL
#define NRF_AMLI_BASE               0x41000000UL
#define NRF_P0_BASE                 0x50000000UL
#define NRF_P1_BASE                 0x50000300UL
#define NRF_OSCILLATORS_BASE        0x40001000UL
#define NRF_REGULATORS_BASE         0x40001000UL
#define NRF_RADIO_BASE              0x40002000UL
#define NRF_RNG_BASE                0x40003000UL
#define NRF_GPIOTE_BASE             0x40004000UL
#define NRF_WDT_BASE                0x40005000UL
#define NRF_TIMER0_BASE             0x40006000UL
#define NRF_TIMER1_BASE             0x40007000UL
#define NRF_TIMER2_BASE             0x40008000UL
#define NRF_ECB_BASE                0x40009000UL
#define NRF_AAR_BASE                0x4000A000UL
#define NRF_CCM_BASE                0x4000A000UL
#define NRF_DPPIC_BASE              0x4000B000UL
#define NRF_RTC0_BASE               0x4000C000UL
#define NRF_RTC1_BASE               0x4000D000UL
#define NRF_SPIM0_BASE              0x4000E000UL
#define NRF_SPIS0_BASE              0x4000E000UL
#define NRF_UARTE0_BASE             0x4000E000UL
#define NRF_TWIM1_BASE              0x4000F000UL
#define NRF_TWIS1_BASE              0x4000F000UL
#define NRF_QDEC0_BASE              0x40012000UL
#define NRF_SAADC_BASE              0x40014000UL
#define NRF_EGU0_BASE               0x40017000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
#define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
#define NRF_PAMLI                   ((NRF_PAMLI_Type*)         NRF_PAMLI_BASE)
#define NRF_VMC                     ((NRF_VMC_Type*)           NRF_VMC_BASE)
#define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
#define NRF_BPROT                   ((NRF_BPROT_Type*)         NRF_BPROT_BASE)
#define NRF_RAMBIST0                ((NRF_RAMBIST_Type*)       NRF_RAMBIST0_BASE)
#define NRF_RCOSC32K                ((NRF_RCOSC32K_Type*)      NRF_RCOSC32K_BASE)
#define NRF_PCGCSLAVE_AMLI          ((NRF_PCGCSLAVE_Type*)     NRF_PCGCSLAVE_AMLI_BASE)
#define NRF_PCGCMASTER0             ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER0_BASE)
#define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
#define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
#define NRF_RESET                   ((NRF_RESET_Type*)         NRF_RESET_BASE)
#define NRF_AMLI                    ((NRF_AMLI_Type*)          NRF_AMLI_BASE)
#define NRF_P0                      ((NRF_GPIO_Type*)          NRF_P0_BASE)
#define NRF_P1                      ((NRF_GPIO_Type*)          NRF_P1_BASE)
#define NRF_OSCILLATORS             ((NRF_OSCILLATORS_Type*)   NRF_OSCILLATORS_BASE)
#define NRF_REGULATORS              ((NRF_REGULATORS_Type*)    NRF_REGULATORS_BASE)
#define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
#define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
#define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
#define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
#define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
#define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
#define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
#define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
#define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
#define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
#define NRF_DPPIC                   ((NRF_DPPIC_Type*)         NRF_DPPIC_BASE)
#define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
#define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
#define NRF_SPIM0                   ((NRF_SPIM_Type*)          NRF_SPIM0_BASE)
#define NRF_SPIS0                   ((NRF_SPIS_Type*)          NRF_SPIS0_BASE)
#define NRF_UARTE0                  ((NRF_UARTE_Type*)         NRF_UARTE0_BASE)
#define NRF_TWIM1                   ((NRF_TWIM_Type*)          NRF_TWIM1_BASE)
#define NRF_TWIS1                   ((NRF_TWIS_Type*)          NRF_TWIS1_BASE)
#define NRF_QDEC0                   ((NRF_QDEC_Type*)          NRF_QDEC0_BASE)
#define NRF_SAADC                   ((NRF_SAADC_Type*)         NRF_SAADC_BASE)
#define NRF_EGU0                    ((NRF_EGU_Type*)           NRF_EGU0_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


#ifdef __cplusplus
}
#endif

#endif /* NRF5002_H */


/** @} */ /* End of group nrf5002 */

/** @} */ /* End of group Nordic Semiconductor */
