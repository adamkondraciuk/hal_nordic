/*
 * Copyright (c) 2010 - 2020, Nordic Semiconductor ASAAll rights reserved.Redistribution and use in sou
 * rce and binary forms, with or without modification,are permitted provided that the following conditi
 * ons are met:1. Redistributions of source code must retain the above copyright notice, this list of c
 * onditions and the following disclaimer.2. Redistributions in binary form, except as embedded into a 
 * Nordic Semiconductor ASA integrated circuit in a product or a software update for such product, must
 * reproduce the above copyright notice, this list of conditions and the following disclaimer in the d
 * ocumentation and/or other materials provided with the distribution.3. Neither the name of Nordic Sem
 * iconductor ASA nor the names of its contributors may be used to endorse or promote products derived 
 * from this software without specific prior written permission.4. This software, with or without modif
 * ication, must only be used with a Nordic Semiconductor ASA integrated circuit.5. Any software provid
 * ed in binary form under this license must not be reverse engineered, decompiled, modified and/or dis
 * assembled.THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESSOR IMPLIED WA
 * RRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIESOF MERCHANTABILITY, NONINFRINGEMENT, 
 * AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CO
 * NTRIBUTORS BELIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGE
 * S (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTEGOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT
 * , STRICTLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUTOF THE USE OF T
 * HIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf5340_application.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     01. October 2020
 * @note     Generated by SVDConv V3.3.35 on Thursday, 01.10.2020 15:17:37
 *           from File 'nrf5340_application.svd',
 *           last modified on Thursday, 01.10.2020 13:17:18
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf5340_application
  * @{
  */


#ifndef NRF5340_APPLICATION_H
#define NRF5340_APPLICATION_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M33 Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SecureFault_IRQn          =  -9,              /*!< -9 Secure Fault Handler                                                   */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ====================================  nrf5340_application Specific Interrupt Numbers  ===================================== */
  FPU_IRQn                  =   0,              /*!< 0  FPU                                                                    */
  CACHE_IRQn                =   1,              /*!< 1  CACHE                                                                  */
  SPU_IRQn                  =   3,              /*!< 3  SPU                                                                    */
  CLOCK_POWER_IRQn          =   5,              /*!< 5  CLOCK_POWER                                                            */
  SPIM0_SPIS0_TWIM0_TWIS0_UARTE0_IRQn=   8,     /*!< 8  SPIM0_SPIS0_TWIM0_TWIS0_UARTE0                                         */
  SPIM1_SPIS1_TWIM1_TWIS1_UARTE1_IRQn=   9,     /*!< 9  SPIM1_SPIS1_TWIM1_TWIS1_UARTE1                                         */
  SPIM4_IRQn                =  10,              /*!< 10 SPIM4                                                                  */
  SPIM2_SPIS2_TWIM2_TWIS2_UARTE2_IRQn=  11,     /*!< 11 SPIM2_SPIS2_TWIM2_TWIS2_UARTE2                                         */
  SPIM3_SPIS3_TWIM3_TWIS3_UARTE3_IRQn=  12,     /*!< 12 SPIM3_SPIS3_TWIM3_TWIS3_UARTE3                                         */
  GPIOTE0_IRQn              =  13,              /*!< 13 GPIOTE0                                                                */
  SAADC_IRQn                =  14,              /*!< 14 SAADC                                                                  */
  TIMER0_IRQn               =  15,              /*!< 15 TIMER0                                                                 */
  TIMER1_IRQn               =  16,              /*!< 16 TIMER1                                                                 */
  TIMER2_IRQn               =  17,              /*!< 17 TIMER2                                                                 */
  RTC0_IRQn                 =  20,              /*!< 20 RTC0                                                                   */
  RTC1_IRQn                 =  21,              /*!< 21 RTC1                                                                   */
  WDT0_IRQn                 =  24,              /*!< 24 WDT0                                                                   */
  WDT1_IRQn                 =  25,              /*!< 25 WDT1                                                                   */
  COMP_LPCOMP_IRQn          =  26,              /*!< 26 COMP_LPCOMP                                                            */
  EGU0_IRQn                 =  27,              /*!< 27 EGU0                                                                   */
  EGU1_IRQn                 =  28,              /*!< 28 EGU1                                                                   */
  EGU2_IRQn                 =  29,              /*!< 29 EGU2                                                                   */
  EGU3_IRQn                 =  30,              /*!< 30 EGU3                                                                   */
  EGU4_IRQn                 =  31,              /*!< 31 EGU4                                                                   */
  EGU5_IRQn                 =  32,              /*!< 32 EGU5                                                                   */
  PWM0_IRQn                 =  33,              /*!< 33 PWM0                                                                   */
  PWM1_IRQn                 =  34,              /*!< 34 PWM1                                                                   */
  PWM2_IRQn                 =  35,              /*!< 35 PWM2                                                                   */
  PWM3_IRQn                 =  36,              /*!< 36 PWM3                                                                   */
  PDM0_IRQn                 =  38,              /*!< 38 PDM0                                                                   */
  I2S0_IRQn                 =  40,              /*!< 40 I2S0                                                                   */
  IPC_IRQn                  =  42,              /*!< 42 IPC                                                                    */
  QSPI_IRQn                 =  43,              /*!< 43 QSPI                                                                   */
  NFCT_IRQn                 =  45,              /*!< 45 NFCT                                                                   */
  GPIOTE1_IRQn              =  47,              /*!< 47 GPIOTE1                                                                */
  QDEC0_IRQn                =  51,              /*!< 51 QDEC0                                                                  */
  QDEC1_IRQn                =  52,              /*!< 52 QDEC1                                                                  */
  USBD_IRQn                 =  54,              /*!< 54 USBD                                                                   */
  USBREGULATOR_IRQn         =  55,              /*!< 55 USBREGULATOR                                                           */
  KMU_IRQn                  =  57,              /*!< 57 KMU                                                                    */
  CRYPTOCELL_IRQn           =  68               /*!< 68 CRYPTOCELL                                                             */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M33 Processor and Core Peripherals  =========================== */
#define __CM33_REV                 0x0004U      /*!< CM33 Core Revision                                                        */
#define __DSP_PRESENT                  1        /*!< DSP present or not                                                        */
#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  1        /*!< FPU present                                                               */
#define __FPU_DP                       0        /*!< Double Precision FPU                                                      */
#define __SAUREGION_PRESENT            0        /*!< SAU region present                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm33.h"                          /*!< ARM Cortex-M33 processor and core peripherals                             */
#include "system_nrf5340_application.h"         /*!< nrf5340_application System                                                */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief CACHEDATA_SET_WAY [WAY] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DATA0;                        /*!< (@ 0x00000000) Description cluster: Cache data bits [31:0] of
                                                                    SET[n], WAY[o].                                            */
  __IOM uint32_t  DATA1;                        /*!< (@ 0x00000004) Description cluster: Cache data bits [63:32]
                                                                    of SET[n], WAY[o].                                         */
  __IOM uint32_t  DATA2;                        /*!< (@ 0x00000008) Description cluster: Cache data bits [95:64]
                                                                    of SET[n], WAY[o].                                         */
  __IOM uint32_t  DATA3;                        /*!< (@ 0x0000000C) Description cluster: Cache data bits [127:96]
                                                                    of SET[n], WAY[o].                                         */
} CACHEDATA_SET_WAY_Type;                       /*!< Size = 16 (0x10)                                                          */


/**
  * @brief CACHEDATA_SET [SET] (Unspecified)
  */
typedef struct {
  __IOM CACHEDATA_SET_WAY_Type WAY[2];          /*!< (@ 0x00000000) Unspecified                                                */
} CACHEDATA_SET_Type;                           /*!< Size = 32 (0x20)                                                          */


/**
  * @brief CACHEINFO_SET [SET] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  WAY[2];                       /*!< (@ 0x00000000) Description collection: Cache information for
                                                                    SET[n], WAY[o].                                            */
} CACHEINFO_SET_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief FICR_SOCINFO [SOCINFO] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  PARTNO;                       /*!< (@ 0x00000000) Part number of the device.                                 */
  __IM  uint32_t  HWREVISION;                   /*!< (@ 0x00000004) Hardware Revision of the device. Will be updated
                                                                    in production test.                                        */
  __IM  uint32_t  PRODUCTIONREVISION;           /*!< (@ 0x00000008) Production revision of the device. Will be updated
                                                                    in production test.                                        */
} FICR_SOCINFO_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  CONFIGID;                     /*!< (@ 0x00000000) Configuration identifier                                   */
  __IM  uint32_t  DEVICEID[2];                  /*!< (@ 0x00000004) Description collection: Device identifier                  */
  __IM  uint32_t  PART;                         /*!< (@ 0x0000000C) Part code                                                  */
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000010) Part Variant, Hardware version and Production
                                                                    configuration                                              */
  __IM  uint32_t  PACKAGE;                      /*!< (@ 0x00000014) Package option                                             */
  __IM  uint32_t  RAM;                          /*!< (@ 0x00000018) RAM variant                                                */
  __IM  uint32_t  FLASH;                        /*!< (@ 0x0000001C) Flash variant                                              */
  __IM  uint32_t  CODEPAGESIZE;                 /*!< (@ 0x00000020) Code memory page size in bytes                             */
  __IM  uint32_t  CODESIZE;                     /*!< (@ 0x00000024) Code memory size                                           */
  __IM  uint32_t  DEVICETYPE;                   /*!< (@ 0x00000028) Device type                                                */
} FICR_INFO_Type;                               /*!< Size = 44 (0x2c)                                                          */


/**
  * @brief FICR_SOCINFO1 [SOCINFO1] (These registers are a workaround for YOPAN-38 on Enga / Proto3)
  */
typedef struct {
  __IM  uint32_t  PARTNO;                       /*!< (@ 0x00000000) Part number of the device. These register is
                                                                    a workaround for YOPAN-38 on Enga / Proto3                 */
  __IM  uint32_t  HWREVISION;                   /*!< (@ 0x00000004) Hardware Revision of the device. Will be updated
                                                                    in production test. These register is a
                                                                    workaround for YOPAN-38 on Enga / Proto3                   */
  __IM  uint32_t  PRODUCTIONREVISION;           /*!< (@ 0x00000008) Production revision of the device. Will be updated
                                                                    in production test. These register is a
                                                                    workaround for YOPAN-38 on Enga / Proto3                   */
} FICR_SOCINFO1_Type;                           /*!< Size = 12 (0xc)                                                           */


/**
  * @brief FICR_TRIMCNF [TRIMCNF] (Unspecified)
  */
typedef struct {
  __IOM uint32_t* ADDR;                         /*!< (@ 0x00000000) Description cluster: Address of the PAR register
                                                                    which will be written                                      */
  __IM  uint32_t  DATA;                         /*!< (@ 0x00000004) Description cluster: Data                                  */
} FICR_TRIMCNF_Type;                            /*!< Size = 8 (0x8)                                                            */


/**
  * @brief FICR_NFC [NFC] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  TAGHEADER0;                   /*!< (@ 0x00000000) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER1;                   /*!< (@ 0x00000004) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER2;                   /*!< (@ 0x00000008) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER3;                   /*!< (@ 0x0000000C) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
} FICR_NFC_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
  */
typedef struct {
  __IM  uint32_t  BYTES;                        /*!< (@ 0x00000000) Amount of bytes for the required entropy bits              */
  __IM  uint32_t  RCCUTOFF;                     /*!< (@ 0x00000004) Repetition counter cutoff                                  */
  __IM  uint32_t  APCUTOFF;                     /*!< (@ 0x00000008) Adaptive proportion cutoff                                 */
  __IM  uint32_t  STARTUP;                      /*!< (@ 0x0000000C) Amount of bytes for the startup tests                      */
  __IM  uint32_t  ROSC1;                        /*!< (@ 0x00000010) Sample count for ring oscillator 1                         */
  __IM  uint32_t  ROSC2;                        /*!< (@ 0x00000014) Sample count for ring oscillator 2                         */
  __IM  uint32_t  ROSC3;                        /*!< (@ 0x00000018) Sample count for ring oscillator 3                         */
  __IM  uint32_t  ROSC4;                        /*!< (@ 0x0000001C) Sample count for ring oscillator 4                         */
} FICR_TRNG90B_Type;                            /*!< Size = 32 (0x20)                                                          */


/**
  * @brief UICR_KEYSLOT_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DEST;                         /*!< (@ 0x00000000) Description cluster: Destination address where
                                                                    content of the key value registers (KEYSLOT.KEYn.VALUE[0-3
                                                                    ) will be pushed by KMU. Note that this
                                                                    address must match that of a peripherals
                                                                    APB mapped write-only key registers, else
                                                                    the KMU can push this key value into an
                                                                    address range which the CPU can potentially
                                                                    read.                                                      */
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000004) Description cluster: Define permissions for the
                                                                    key slot. Bits 0-15 and 16-31 can only be
                                                                    written when equal to 0xFFFF.                              */
} UICR_KEYSLOT_CONFIG_Type;                     /*!< Size = 8 (0x8)                                                            */


/**
  * @brief UICR_KEYSLOT_KEY [KEY] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VALUE[4];                     /*!< (@ 0x00000000) Description collection: Define bits [31+o*32:0+o*32]
                                                                    of value assigned to KMU key slot.                         */
} UICR_KEYSLOT_KEY_Type;                        /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UICR_KEYSLOT [KEYSLOT] (Unspecified)
  */
typedef struct {
  __IOM UICR_KEYSLOT_CONFIG_Type CONFIG[128];   /*!< (@ 0x00000000) Unspecified                                                */
  __IOM UICR_KEYSLOT_KEY_Type KEY[128];         /*!< (@ 0x00000400) Unspecified                                                */
} UICR_KEYSLOT_Type;                            /*!< Size = 3072 (0xc00)                                                       */


/**
  * @brief TAD_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  TRACECLK;                     /*!< (@ 0x00000000) Pin configuration for TRACECLK                             */
  __IOM uint32_t  TRACEDATA0;                   /*!< (@ 0x00000004) Pin configuration for TRACEDATA[0] and SWO                 */
  __IOM uint32_t  TRACEDATA1;                   /*!< (@ 0x00000008) Pin configuration for TRACEDATA[1]                         */
  __IOM uint32_t  TRACEDATA2;                   /*!< (@ 0x0000000C) Pin configuration for TRACEDATA[2]                         */
  __IOM uint32_t  TRACEDATA3;                   /*!< (@ 0x00000010) Pin configuration for TRACEDATA[3]                         */
} TAD_PSEL_Type;                                /*!< Size = 20 (0x14)                                                          */


/**
  * @brief AMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  CPU;                          /*!< (@ 0x00000000) AHB bus master priority register for CPU                   */
  __IOM uint32_t  EXTRAM[1];                    /*!< (@ 0x00000004) Description collection: AHB bus master priority
                                                                    register for external RAM slave port (EXTRAMs)             */
} AMLI_RAMPRI_Type;                             /*!< Size = 8 (0x8)                                                            */


/**
  * @brief DCNF_EXTPERI [EXTPERI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access for master
                                                                    connected to AMLI master port EXTPERI[n]                   */
} DCNF_EXTPERI_Type;                            /*!< Size = 4 (0x4)                                                            */


/**
  * @brief DCNF_EXTRAM [EXTRAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access from master
                                                                    connected to AMLI master port EXTRAM[n]                    */
} DCNF_EXTRAM_Type;                             /*!< Size = 4 (0x4)                                                            */


/**
  * @brief DCNF_EXTCODE [EXTCODE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access from master
                                                                    connected to AMLI master port EXTCODE[n]                   */
} DCNF_EXTCODE_Type;                            /*!< Size = 4 (0x4)                                                            */


/**
  * @brief DCNF_EXTCODESYNC [EXTCODESYNC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access from master
                                                                    connected to AMLI master port EXTCODESYNC[n]               */
} DCNF_EXTCODESYNC_Type;                        /*!< Size = 4 (0x4)                                                            */


/**
  * @brief DCNF_FPGAINFO [FPGAINFO] (Exists only on the FPGA nightly build)
  */
typedef struct {
  __IM  uint32_t  SVNREVISION;                  /*!< (@ 0x00000000) SVN revision                                               */
  __IM  uint32_t  OFFICIAL;                     /*!< (@ 0x00000004) Official release                                           */
  __IM  uint8_t*  RELEASEID[8];                 /*!< (@ 0x00000008) Description collection: Release ID string                  */
  __IM  uint32_t  JOBNUMBER;                    /*!< (@ 0x00000010) Jenkins job number                                         */
} DCNF_FPGAINFO_Type;                           /*!< Size = 20 (0x14)                                                          */


/**
  * @brief CACHE_PROFILING [PROFILING] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  IHIT;                         /*!< (@ 0x00000000) Description cluster: Instruction fetch cache
                                                                    hit counter for cache region n, where n=0
                                                                    means Flash and n=1 means XIP.                             */
  __IM  uint32_t  IMISS;                        /*!< (@ 0x00000004) Description cluster: Instruction fetch cache
                                                                    miss counter for cache region n, where n=0
                                                                    means Flash and n=1 means XIP.                             */
  __IM  uint32_t  DHIT;                         /*!< (@ 0x00000008) Description cluster: Data fetch cache hit counter
                                                                    for cache region n, where n=0 means Flash
                                                                    and n=1 means XIP.                                         */
  __IM  uint32_t  DMISS;                        /*!< (@ 0x0000000C) Description cluster: Data fetch cache miss counter
                                                                    for cache region n, where n=0 means Flash
                                                                    and n=1 means XIP.                                         */
  __IM  uint32_t  TAGLOOKUPCNT;                 /*!< (@ 0x00000010) Description cluster: Tag lookup count for cache
                                                                    region n, where n=0 means Flash and n=1
                                                                    means XIP.                                                 */
  __IM  uint32_t  RESERVED[3];
} CACHE_PROFILING_Type;                         /*!< Size = 32 (0x20)                                                          */


/**
  * @brief SPU_EXTDOMAIN [EXTDOMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access for bus access generated
                                                                    from the external domain n List capabilities
                                                                    of the external domain n                                   */
} SPU_EXTDOMAIN_Type;                           /*!< Size = 4 (0x4)                                                            */


/**
  * @brief SPU_DPPI [DPPI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for the DPPI channels.                */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_DPPI_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPU_GPIOPORT [GPIOPORT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for pins 0 to 31 of
                                                                    port n.                                                    */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_GPIOPORT_Type;                            /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPU_FLASHNSC [FLASHNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which flash region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_FLASHNSC_Type;                            /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPU_RAMNSC [RAMNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which RAM region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_RAMNSC_Type;                              /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPU_FLASHREGION [FLASHREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for flash
                                                                    region n                                                   */
} SPU_FLASHREGION_Type;                         /*!< Size = 4 (0x4)                                                            */


/**
  * @brief SPU_RAMREGION [RAMREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for RAM
                                                                    region n                                                   */
} SPU_RAMREGION_Type;                           /*!< Size = 4 (0x4)                                                            */


/**
  * @brief SPU_PERIPHID [PERIPHID] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: List capabilities and access
                                                                    permissions for the peripheral with ID n                   */
} SPU_PERIPHID_Type;                            /*!< Size = 4 (0x4)                                                            */


/**
  * @brief OSCILLATORS_AUDIOPLL [AUDIOPLL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) AUDIO PLL bypass control                                   */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x00000004) Mute the AUDIO PLL                                         */
  __IOM uint32_t  CTRL;                         /*!< (@ 0x00000008) Collection of test/debug signals                           */
  __IOM uint32_t  VCOTRIM;                      /*!< (@ 0x0000000C) VCO trim value for the AUDIO PLL                           */
  __IOM uint32_t  VCOTRIMOVERRIDE;              /*!< (@ 0x00000010) Control overriding of the VCO trim values                  */
} OSCILLATORS_AUDIOPLL_Type;                    /*!< Size = 20 (0x14)                                                          */


/**
  * @brief OSCILLATORS_CPUPLL [CPUPLL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) CPU PLL bypass control                                     */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x00000004) Mute the CPU PLL                                           */
  __IOM uint32_t  CTRL;                         /*!< (@ 0x00000008) Control the behavior of the PFD                            */
  __IOM uint32_t  PROGCHPUMP;                   /*!< (@ 0x0000000C) Program charge pump current                                */
  __IOM uint32_t  VCOTRIM;                      /*!< (@ 0x00000010) VCO trim value for the CPU PLL                             */
  __IOM uint32_t  VCOTRIMOVERRIDE;              /*!< (@ 0x00000014) Control overriding of the VCO trim values                  */
} OSCILLATORS_CPUPLL_Type;                      /*!< Size = 24 (0x18)                                                          */


/**
  * @brief OSCILLATORS_PLL64M [PLL64M] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) PLL64M bypass control                                      */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x00000004) Mute the PLL64M                                            */
  __IOM uint32_t  PROGCHPUMP;                   /*!< (@ 0x00000008) Program charge pump current                                */
  __IOM uint32_t  VCOTRIM;                      /*!< (@ 0x0000000C) VCO trim value for the 64 MHz PLL                          */
  __IOM uint32_t  VCOTRIMOVERRIDE;              /*!< (@ 0x00000010) Control overriding of the VCO trim values                  */
} OSCILLATORS_PLL64M_Type;                      /*!< Size = 20 (0x14)                                                          */


/**
  * @brief OSCILLATORS_PLL192M [PLL192M] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) 192 MHz PLL bypass control                                 */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x00000004) Mute the 192 MHz PLL                                       */
  __IOM uint32_t  FREQ;                         /*!< (@ 0x00000008) Frequency selection                                        */
  __IOM uint32_t  CTRL;                         /*!< (@ 0x0000000C) Control the behavior of the PFD                            */
  __IOM uint32_t  PROGCHPUMP;                   /*!< (@ 0x00000010) Program charge pump current                                */
  __IOM uint32_t  VCOTRIM;                      /*!< (@ 0x00000014) VCO trim value for the 192 MHz PLL                         */
  __IOM uint32_t  VCOTRIMOVERRIDE;              /*!< (@ 0x00000018) Control overriding of the VCO trim values                  */
} OSCILLATORS_PLL192M_Type;                     /*!< Size = 28 (0x1c)                                                          */


/**
  * @brief OSCILLATORS_XOSC32KI [XOSC32KI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) Enable or disable bypass of LFCLK crystal oscillator
                                                                    with external clock source                                 */
  __IOM uint32_t  POWERDOWN;                    /*!< (@ 0x00000004) Power-up or power-down of LFCLK crystal oscillator         */
  __IOM uint32_t  EXTBIAS;                      /*!< (@ 0x00000008) Control the use of a external bias current                 */
  __IOM uint32_t  MUTE;                         /*!< (@ 0x0000000C) Disable clock output                                       */
  __IOM uint32_t  INTCAP;                       /*!< (@ 0x00000010) Control usage of internal load capacitors                  */
  __IOM uint32_t  CAPTRIM;                      /*!< (@ 0x00000014) On-chip capacitance trimming                               */
  __IOM uint32_t  CONSTCURR;                    /*!< (@ 0x00000018) Control pierce inverter bias current                       */
  __IOM uint32_t  CONSTCURRTRIM;                /*!< (@ 0x0000001C) Control current bias when CONSTCURR == 1                   */
  __IOM uint32_t  AREGHIGHCURR;                 /*!< (@ 0x00000020) Increase current in amplitude regulator                    */
} OSCILLATORS_XOSC32KI_Type;                    /*!< Size = 36 (0x24)                                                          */


/**
  * @brief REGULATORS_VREGUSB [VREGUSB] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  USBVREGDELAY;                 /*!< (@ 0x00000000) Control of the delay from USB VREG turned on
                                                                    to USBPWRRDY event                                         */
  __IOM uint32_t  USBVDETFILTER;                /*!< (@ 0x00000004) Control of the VBUS detection filter                       */
  __IOM uint32_t  FORCEVBUSDET;                 /*!< (@ 0x00000008) Force VBUS detection indication                            */
  __IOM uint32_t  FORCEPHY0V9;                  /*!< (@ 0x0000000C) Force USB PHY 0V9 supply switch                            */
  __IOM uint32_t  VREGUSBCFG;                   /*!< (@ 0x00000010) Spare configuration signals                                */
  __IOM uint32_t  VREGUSBTRIM;                  /*!< (@ 0x00000014) Output voltage fine trimming                               */
} REGULATORS_VREGUSB_Type;                      /*!< Size = 24 (0x18)                                                          */


/**
  * @brief REGULATORS_VREGMAIN [VREGMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000000) DC/DC enable register for VREGMAIN                         */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x00000004) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IOM uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x00000008) Set threshold value of power regulator                     */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x0000000C) Enable forcing of power mode in power regulator            */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000010) Current mode in the power regulator                        */
  __IOM uint32_t  DISABLEPFM;                   /*!< (@ 0x00000014) Disable PFM                                                */
  __IOM uint32_t  LDOTESTLOAD;                  /*!< (@ 0x00000018) Test load setting for VREGMAIN                             */
  __IOM uint32_t  LDOCAL;                       /*!< (@ 0x0000001C) Calibration register for the VREGMAIN LDO regulator        */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  AVOIDULP;                     /*!< (@ 0x00000024) Backdoor to avoid ULP mode                                 */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  BUCKPWMCAL;                   /*!< (@ 0x0000002C) Calibration of BUCK_LP_PWM (Step size: TBD).
                                                                    2's complement form                                        */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  BUCKPFMICMPCAL;               /*!< (@ 0x00000034) Calibrate load current detector in PFM mode.
                                                                    Default=2'b00.                                             */
  __IOM uint32_t  BUCKMAXILIMCAL;               /*!< (@ 0x00000038) Max coil current limit calibration                         */
  __IOM uint32_t  ULPRESCTRL;                   /*!< (@ 0x0000003C) Switched resistor control                                  */
  __IOM uint32_t  BUCKPFMCAL;                   /*!< (@ 0x00000040) Calibration of BUCK_LP_PFM, step size: TBD, 2's
                                                                    complement form                                            */
  __IOM uint32_t  VCORECTRL;                    /*!< (@ 0x00000044) Spare digital signals                                      */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  BUCKDEBUG;                    /*!< (@ 0x0000004C) Debug signals for BUCK_VCORE_LP. Default = 6'b000000.      */
  __IOM uint32_t  VOUT;                         /*!< (@ 0x00000050) Selects output voltage from DVDD BUCK and LDO              */
  __IOM uint32_t  VOUTREQH;                     /*!< (@ 0x00000054) Selects output voltage from DVDD BUCK and LDO              */
  __IOM uint32_t  BUCKPFMICMPCOUNT;             /*!< (@ 0x00000058) Programmable timer value for PFM ICMP trigger
                                                                    timer                                                      */
} REGULATORS_VREGMAIN_Type;                     /*!< Size = 92 (0x5c)                                                          */


/**
  * @brief REGULATORS_VREGANA [VREGANA] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x00000000) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000004) Enable forcing of power mode in power regulator            */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000008) Current mode in the power regulator                        */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  LDOTESTLOAD;                  /*!< (@ 0x00000010) Test load setting for VREGANA                              */
  __IOM uint32_t  LDOCAL;                       /*!< (@ 0x00000014) Configuration register for the VREGANA LDO regulator       */
  __IOM uint32_t  ULPCAL;                       /*!< (@ 0x00000018) Calibration register for VREGANA ULP regulator             */
} REGULATORS_VREGANA_Type;                      /*!< Size = 28 (0x1c)                                                          */


/**
  * @brief REGULATORS_VREGRADIO [VREGRADIO] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VOUT;                         /*!< (@ 0x00000000) Control the output voltage for RVDD_1V3. Note:
                                                                    This is overridden by VOUTREQH when VREQH
                                                                    is requested by the network core.                          */
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000004) DC/DC enable register for VREGRADIO                        */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000008) Enable forcing of power mode in power regulator            */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x0000000C) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000010) Current mode in the power regulator                        */
  __IOM uint32_t  TESTLOAD;                     /*!< (@ 0x00000014) Test load setting for VREGRADIO                            */
  __IOM uint32_t  ULPCAL;                       /*!< (@ 0x00000018) Calibration VREGRADIO ULP regulator                        */
  __IOM uint32_t  DEBUGLVLP;                    /*!< (@ 0x0000001C) Debug register - control spare signals in POWER_LVLP       */
  __IOM uint32_t  VOUTREQH;                     /*!< (@ 0x00000020) Control the output voltage for RVDD_1V3 when
                                                                    VREQH is asserted. VREQH can be asserted
                                                                    through the network core.                                  */
  __IOM uint32_t  BUCKCALMAXILIM;               /*!< (@ 0x00000024) TBD                                                        */
  __IOM uint32_t  BUCKCALPWM;                   /*!< (@ 0x00000028) TBD                                                        */
  __IOM uint32_t  BUCKPFMEN;                    /*!< (@ 0x0000002C) PFM enable register for VREGRADIO regulator                */
  __IOM uint32_t  BUCKPFMCAL;                   /*!< (@ 0x00000030) TBD                                                        */
  __IOM uint32_t  BUCKPFMICMPCAL;               /*!< (@ 0x00000034) TBD                                                        */
  __IOM uint32_t  BUCKPFMICMPCOUNT;             /*!< (@ 0x00000038) TBD                                                        */
  __IOM uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x0000003C) Set threshold value of power regulator                     */
  __IOM uint32_t  AVOIDULP;                     /*!< (@ 0x00000040) Backdoor to avoid ULP mode                                 */
} REGULATORS_VREGRADIO_Type;                    /*!< Size = 68 (0x44)                                                          */


/**
  * @brief REGULATORS_VREGNETWORK [VREGNETWORK] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VOUT;                         /*!< (@ 0x00000000) Control the output voltage for DVDD_0V9                    */
  __IOM uint32_t  ULPALWAYSON;                  /*!< (@ 0x00000004) Keep DVDD_0V9 ULP regulator on at all times                */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000008) Enable forcing of power mode in power regulator            */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x0000000C) Backdoor register for manual selection of power
                                                                    mode                                                       */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000010) Current mode in the power regulator                        */
  __IOM uint32_t  PWRREGICMPTIMER;              /*!< (@ 0x00000014) Control the stay-alive time for the VREGNETWORK
                                                                    current comparator                                         */
  __IOM uint32_t  TESTLOAD;                     /*!< (@ 0x00000018) Test load setting for VREGNETWORK                          */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  ULPCAL;                       /*!< (@ 0x00000020) Calibration VREGNETWORK ULP regulator                      */
  __IOM uint32_t  ULPICMPCAL;                   /*!< (@ 0x00000024) Calibration of current comparator on DVDD_0V9
                                                                    ULP regulator                                              */
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000028) Bypass control for VREGNETWORK                             */
} REGULATORS_VREGNETWORK_Type;                  /*!< Size = 44 (0x2c)                                                          */


/**
  * @brief REGULATORS_VREGH [VREGH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000000) DC/DC enable register for VREGH                            */
  __IOM uint32_t  BUCKCAL;                      /*!< (@ 0x00000004) BUCK_VIO output voltage fine calibration                   */
  __IOM uint32_t  ULPICMPTRIM;                  /*!< (@ 0x00000008) Trimming of VREG_VIO_ULP load current measurement          */
  __IOM uint32_t  VREGICMPTRIM;                 /*!< (@ 0x0000000C) Trimming of VREG_VIO load current measurement              */
  __IOM uint32_t  BUCKCALILIM;                  /*!< (@ 0x00000010) BUCK_VIO output current limit calibration                  */
  __IOM uint32_t  EXTSUPPLY;                    /*!< (@ 0x00000014) Enable external circuitry to be supplied from
                                                                    VDD pin)                                                   */
  __IOM uint32_t  RFSHBUCKCAL;                  /*!< (@ 0x00000018) Refresh mode trim register                                 */
  __IOM uint32_t  RFSHTRIMULP;                  /*!< (@ 0x0000001C) Trimmed value for refresh mode counter for automatic
                                                                    mode change to ULP                                         */
  __IOM uint32_t  RFSHTRIMPWM;                  /*!< (@ 0x00000020) Trimmed value for refresh mode counter for automatic
                                                                    mode change to PWM                                         */
  __IOM uint32_t  RFSHPOLLSEL;                  /*!< (@ 0x00000024) Programmable value for counter for poller in
                                                                    PWM mode                                                   */
  __IOM uint32_t  BUCKCKDIV2;                   /*!< (@ 0x00000028) Sets BUCK_VIO switching frequency                          */
  __IOM uint32_t  POWERCFG;                     /*!< (@ 0x0000002C) Spare configuration signals for POWER_VIO                  */
  __IOM uint32_t  LDO2ULPOVERLAPTRIM;           /*!< (@ 0x00000030) Programmable value for VREGH LDO to ULP overlay
                                                                    counter                                                    */
  __IOM uint32_t  ULPDISABLE;                   /*!< (@ 0x00000034) VREGH ULP mode                                             */
  __IM  uint32_t  CURRENTPWRREGMODE;            /*!< (@ 0x00000038) Current mode in the VREGH power regulator                  */
  __IM  uint32_t  VDDHDETECTED;                 /*!< (@ 0x0000003C) VDDH is detected                                           */
  __IOM uint32_t  EXTSILENTEN;                  /*!< (@ 0x00000040) Enable silent external DC/DC supply. This register
                                                                    only applies when DC/DC is enabled in the
                                                                    VREGHDCDCEN register. Entering silent mode
                                                                    forbids the use of DC/DC refresh mode internally
                                                                    in VREGH.                                                  */
  __IOM uint32_t  ENFORCEPWRREGMODE;            /*!< (@ 0x00000044) Enable forcing of power mode in power regulator            */
  __IOM uint32_t  FORCEREGMODE;                 /*!< (@ 0x00000048) Force a specific power mode for VREGH                      */
  __IOM uint32_t  PWRREGTHRESHOLD;              /*!< (@ 0x0000004C) Set threshold value of power regulator                     */
} REGULATORS_VREGH_Type;                        /*!< Size = 80 (0x50)                                                          */


/**
  * @brief CLOCK_HFCLKAUDIO [HFCLKAUDIO] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000000) Audio PLL frequency in 11.176 MHz - 11.402 MHz
                                                                    or 12.165 MHz - 12.411 MHz frequency bands                 */
  __IOM uint32_t  FREQINC;                      /*!< (@ 0x00000004) Frequency increment                                        */
  __IOM uint32_t  FREQINCPERIOD;                /*!< (@ 0x00000008) Frequency increment period 1 us steps                      */
  __IOM uint32_t  FREQINCENABLE;                /*!< (@ 0x0000000C) Frequency increment enable                                 */
} CLOCK_HFCLKAUDIO_Type;                        /*!< Size = 16 (0x10)                                                          */


/**
  * @brief RESET_POWERSTATUS [POWERSTATUS] (Core power status)
  */
typedef struct {
  __IM  uint32_t  NETWORK;                      /*!< (@ 0x00000000) Network core power status                                  */
} RESET_POWERSTATUS_Type;                       /*!< Size = 4 (0x4)                                                            */


/**
  * @brief RESET_NETWORK [NETWORK] (ULP network core control)
  */
typedef struct {
  __IOM uint32_t  RESETCPU;                     /*!< (@ 0x00000000) Reset network CPU                                          */
  __IOM uint32_t  FORCEOFF;                     /*!< (@ 0x00000004) Force network core off                                     */
  __IOM uint32_t  FORCEON;                      /*!< (@ 0x00000008) Force on network core                                      */
} RESET_NETWORK_Type;                           /*!< Size = 12 (0xc)                                                           */


/**
  * @brief CTRLAPPERI_MAILBOX [MAILBOX] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  RXDATA;                       /*!< (@ 0x00000000) Data sent from the debugger to the CPU.                    */
  __IM  uint32_t  RXSTATUS;                     /*!< (@ 0x00000004) This register shows a status that indicates if
                                                                    data sent from the debugger to the CPU has
                                                                    been read.                                                 */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  TXDATA;                       /*!< (@ 0x00000080) Data sent from the CPU to the debugger.                    */
  __IM  uint32_t  TXSTATUS;                     /*!< (@ 0x00000084) This register shows a status that indicates if
                                                                    the data sent from the CPU to the debugger
                                                                    has been read.                                             */
} CTRLAPPERI_MAILBOX_Type;                      /*!< Size = 136 (0x88)                                                         */


/**
  * @brief CTRLAPPERI_ERASEPROTECT [ERASEPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the ERASEPROTECT.DISABLE
                                                                    register from being written until next reset.              */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the ERASEPROTECT register
                                                                    and performs an ERASEALL operation.                        */
} CTRLAPPERI_ERASEPROTECT_Type;                 /*!< Size = 8 (0x8)                                                            */


/**
  * @brief CTRLAPPERI_APPROTECT [APPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the APPROTECT.DISABLE register
                                                                    from being written to until next reset.                    */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the APPROTECT register
                                                                    and enables debug access to non-secure mode.               */
} CTRLAPPERI_APPROTECT_Type;                    /*!< Size = 8 (0x8)                                                            */


/**
  * @brief CTRLAPPERI_SECUREAPPROTECT [SECUREAPPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the SECUREAPPROTECT.DISABLE
                                                                    register from being written until next reset.              */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the SECUREAPPROTECT register
                                                                    and enables debug access to secure mode.                   */
} CTRLAPPERI_SECUREAPPROTECT_Type;              /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PAMLI_RAMPRI [RAMPRI] (RAM configurable priority configuration structure)
  */
typedef struct {
  __IOM uint32_t  SERIAL0;                      /*!< (@ 0x00000000) AHB bus master priority register for SPIM0, SPIS0,
                                                                    TWIM0, TWIS0 and UARTE0                                    */
  __IOM uint32_t  SERIAL1;                      /*!< (@ 0x00000004) AHB bus master priority register for SPIM1, SPIS1,
                                                                    TWIM1, TWIS1 and UARTE1                                    */
  __IOM uint32_t  SERIAL2;                      /*!< (@ 0x00000008) AHB bus master priority register for SPIM2, SPIS2,
                                                                    TWIM2, TWIS2 and UARTE2                                    */
  __IOM uint32_t  SERIAL3;                      /*!< (@ 0x0000000C) AHB bus master priority register for SPIM3, SPIS3,
                                                                    TWIM3, TWIS3 and UARTE3                                    */
  __IOM uint32_t  I2S0;                         /*!< (@ 0x00000010) AHB bus master priority register for I2S0                  */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  PDM;                          /*!< (@ 0x00000018) AHB bus master priority register for PDM                   */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  PWM0;                         /*!< (@ 0x00000020) AHB bus master priority register for PWM0                  */
  __IOM uint32_t  PWM1;                         /*!< (@ 0x00000024) AHB bus master priority register for PWM1                  */
  __IOM uint32_t  PWM2;                         /*!< (@ 0x00000028) AHB bus master priority register for PWM2                  */
  __IOM uint32_t  PWM3;                         /*!< (@ 0x0000002C) AHB bus master priority register for PWM2                  */
  __IOM uint32_t  SAADC;                        /*!< (@ 0x00000030) AHB bus master priority register for SAADC                 */
  __IOM uint32_t  SPIM4;                        /*!< (@ 0x00000034) AHB bus master priority register for high-speed
                                                                    SPIM4                                                      */
  __IOM uint32_t  NFCT;                         /*!< (@ 0x00000038) AHB bus master priority register for NFCT                  */
} PAMLI_RAMPRI_Type;                            /*!< Size = 60 (0x3c)                                                          */


/**
  * @brief SPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
} SPI_PSEL_Type;                                /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN                                         */
} SPIM_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of bytes in transmit buffer                         */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RXDELAY;                      /*!< (@ 0x00000000) Sample delay for input serial data on MISO                 */
  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
                                                                    of SCK and minimum duration CSN must stay
                                                                    high between transactions                                  */
} SPIM_IFTIMING_Type;                           /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
  __IOM uint32_t  MISO;                         /*!< (@ 0x00000004) Pin select for MISO signal                                 */
  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000008) Pin select for MOSI signal                                 */
  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN signal                                  */
} SPIS_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes received in last granted transaction       */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transmitted in last granted transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} SPIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL                                         */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA                                         */
} TWI_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIM_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
} TWIS_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in RXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last RXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD Data pointer                                           */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in TXD buffer                      */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last TXD transaction    */
  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
} TWIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UART_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS                                         */
  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD                                         */
  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS                                         */
  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD                                         */
} UART_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS signal                                  */
  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD signal                                  */
  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS signal                                  */
  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD signal                                  */
} UARTE_PSEL_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_RXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
} UARTE_TXD_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last results is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last results is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_PUBLISH_CH [PUBLISH_CH] (Publish configuration for events)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITH                                         */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITL                                         */
} SAADC_PUBLISH_CH_Type;                        /*!< Size = 8 (0x8)                                                            */


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring a channel                                       */
} SAADC_CH_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of buffer words to transfer                 */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of buffer words transferred since last
                                                                    START                                                      */
} SAADC_RESULT_Type;                            /*!< Size = 12 (0xc)                                                           */


/**
  * @brief DPPIC_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Enable channel group n                */
  __OM  uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Disable channel group n               */
} DPPIC_TASKS_CHG_Type;                         /*!< Size = 8 (0x8)                                                            */


/**
  * @brief DPPIC_SUBSCRIBE_CHG [SUBSCRIBE_CHG] (Subscribe configuration for tasks)
  */
typedef struct {
  __IOM uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Subscribe configuration
                                                                    for task CHG[n].EN                                         */
  __IOM uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Subscribe configuration
                                                                    for task CHG[n].DIS                                        */
} DPPIC_SUBSCRIBE_CHG_Type;                     /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PWM_SEQ [SEQ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
                                                                    of this sequence                                           */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
                                                                    in this sequence                                           */
  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
                                                                    periods between samples loaded into compare
                                                                    register                                                   */
  __IOM uint32_t  ENDDELAY;                     /*!< (@ 0x0000000C) Description cluster: Time added after the sequence         */
  __IM  uint32_t  RESERVED[4];
} PWM_SEQ_Type;                                 /*!< Size = 32 (0x20)                                                          */


/**
  * @brief PWM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
                                                                    PWM channel n                                              */
} PWM_PSEL_Type;                                /*!< Size = 16 (0x10)                                                          */


/**
  * @brief PDM_FILTER [FILTER] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  HPPOLE;                       /*!< (@ 0x00000000) Settings for the high-pass filter                          */
  __IOM uint32_t  HPDISABLE;                    /*!< (@ 0x00000004) High pass filter disable                                   */
  __IOM uint32_t  SOFTMUTE;                     /*!< (@ 0x00000008) Soft mute function                                         */
  __IOM uint32_t  SOFTCYCLES;                   /*!< (@ 0x0000000C) Soft mute settings                                         */
  __IOM uint32_t  SAMPLEDELAY;                  /*!< (@ 0x00000010) Input Data Sampling with Number of PDM_CLK Clock
                                                                    Cycle Delay                                                */
} PDM_FILTER_Type;                              /*!< Size = 20 (0x14)                                                          */


/**
  * @brief PDM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLK;                          /*!< (@ 0x00000000) Pin number configuration for PDM CLK signal                */
  __IOM uint32_t  DIN;                          /*!< (@ 0x00000004) Pin number configuration for PDM DIN signal                */
} PDM_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
                                                                    EasyDMA                                                    */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
                                                                    mode                                                       */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of samples transferred into Data RAM since
                                                                    last START task                                            */
} PDM_SAMPLE_Type;                              /*!< Size = 12 (0xc)                                                           */


/**
  * @brief I2S_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000000) I2S mode                                                   */
  __IOM uint32_t  RXEN;                         /*!< (@ 0x00000004) Reception (RX) enable                                      */
  __IOM uint32_t  TXEN;                         /*!< (@ 0x00000008) Transmission (TX) enable                                   */
  __IOM uint32_t  MCKEN;                        /*!< (@ 0x0000000C) Master clock generator enable                              */
  __IOM uint32_t  MCKFREQ;                      /*!< (@ 0x00000010) I2S clock generator control                                */
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000014) MCK / LRCK ratio                                           */
  __IOM uint32_t  SWIDTH;                       /*!< (@ 0x00000018) Sample width                                               */
  __IOM uint32_t  ALIGN;                        /*!< (@ 0x0000001C) Alignment of sample within a frame                         */
  __IOM uint32_t  FORMAT;                       /*!< (@ 0x00000020) Frame format                                               */
  __IOM uint32_t  CHANNELS;                     /*!< (@ 0x00000024) Enable channels                                            */
  __IOM uint32_t  CLKCONFIG;                    /*!< (@ 0x00000028) Clock source selection for the I2S module                  */
} I2S_CONFIG_Type;                              /*!< Size = 44 (0x2c)                                                          */


/**
  * @brief I2S_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Receive buffer RAM start address.                          */
} I2S_RXD_Type;                                 /*!< Size = 4 (0x4)                                                            */


/**
  * @brief I2S_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Transmit buffer RAM start address                          */
} I2S_TXD_Type;                                 /*!< Size = 4 (0x4)                                                            */


/**
  * @brief I2S_RXTXD [RXTXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000000) Size of RXD and TXD buffers                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Number of 32 bit words sent and received since
                                                                    the previous END event. Nice to have only.
                                                                    TBD.                                                       */
} I2S_RXTXD_Type;                               /*!< Size = 8 (0x8)                                                            */


/**
  * @brief I2S_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MCK;                          /*!< (@ 0x00000000) Pin select for MCK signal                                  */
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000004) Pin select for SCK signal                                  */
  __IOM uint32_t  LRCK;                         /*!< (@ 0x00000008) Pin select for LRCK signal                                 */
  __IOM uint32_t  SDIN;                         /*!< (@ 0x0000000C) Pin select for SDIN signal                                 */
  __IOM uint32_t  SDOUT;                        /*!< (@ 0x00000010) Pin select for SDOUT signal                                */
} I2S_PSEL_Type;                                /*!< Size = 20 (0x14)                                                          */


/**
  * @brief QSPI_READ [READ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SRC;                          /*!< (@ 0x00000000) Flash memory source address                                */
  __IOM uint32_t  DST;                          /*!< (@ 0x00000004) RAM destination address                                    */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Read transfer length                                       */
} QSPI_READ_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief QSPI_WRITE [WRITE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DST;                          /*!< (@ 0x00000000) Flash destination address                                  */
  __IOM uint32_t  SRC;                          /*!< (@ 0x00000004) RAM source address                                         */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Write transfer length                                      */
} QSPI_WRITE_Type;                              /*!< Size = 12 (0xc)                                                           */


/**
  * @brief QSPI_ERASE [ERASE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Start address of flash block to be erased                  */
  __IOM uint32_t  LEN;                          /*!< (@ 0x00000004) Size of block to be erased.                                */
} QSPI_ERASE_Type;                              /*!< Size = 8 (0x8)                                                            */


/**
  * @brief QSPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for serial clock SCK Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
  __IOM uint32_t  CSN;                          /*!< (@ 0x00000004) Pin select for chip select signal CSN. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL.                     */
  __IOM uint32_t  CSN1;                         /*!< (@ 0x00000008) Pin select for chip select signal CSN1. Not implemented!.  */
  __IOM uint32_t  IO0;                          /*!< (@ 0x0000000C) Pin select for serial data MOSI/IO0. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL                      */
  __IOM uint32_t  IO1;                          /*!< (@ 0x00000010) Pin select for serial data MISO/IO1. Connected
                                                                    to SPI interface pins of SPI-MEM-CTRL.                     */
  __IOM uint32_t  IO2;                          /*!< (@ 0x00000014) Pin select for serial data IO2. Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
  __IOM uint32_t  IO3;                          /*!< (@ 0x00000018) Pin select for serial data IO3. Connected to
                                                                    SPI interface pins of SPI-MEM-CTRL.                        */
} QSPI_PSEL_Type;                               /*!< Size = 28 (0x1c)                                                          */


/**
  * @brief QSPI_XIP_ENC [XIP_ENC] (Unspecified)
  */
typedef struct {
  __OM  uint32_t  KEY0;                         /*!< (@ 0x00000000) Bits 31:0 of XIP AES KEY                                   */
  __OM  uint32_t  KEY1;                         /*!< (@ 0x00000004) Bits 63:32 of XIP AES KEY                                  */
  __OM  uint32_t  KEY2;                         /*!< (@ 0x00000008) Bits 95:64 of XIP AES KEY                                  */
  __OM  uint32_t  KEY3;                         /*!< (@ 0x0000000C) Bits 127:96 of XIP AES KEY                                 */
  __OM  uint32_t  NONCE0;                       /*!< (@ 0x00000010) Bits 31:0 of XIP NONCE                                     */
  __OM  uint32_t  NONCE1;                       /*!< (@ 0x00000014) Bits 63:32 of XIP NONCE                                    */
  __OM  uint32_t  NONCE2;                       /*!< (@ 0x00000018) Bits 95:64 of XIP NONCE                                    */
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x0000001C) Enable stream cipher for XIP                               */
} QSPI_XIP_ENC_Type;                            /*!< Size = 32 (0x20)                                                          */


/**
  * @brief QSPI_DMA_ENC [DMA_ENC] (Unspecified)
  */
typedef struct {
  __OM  uint32_t  KEY0;                         /*!< (@ 0x00000000) Bits 31:0 of DMA AES KEY                                   */
  __OM  uint32_t  KEY1;                         /*!< (@ 0x00000004) Bits 63:32 of DMA AES KEY                                  */
  __OM  uint32_t  KEY2;                         /*!< (@ 0x00000008) Bits 95:64 of DMA AES KEY                                  */
  __OM  uint32_t  KEY3;                         /*!< (@ 0x0000000C) Bits 127:96 of DMA AES KEY                                 */
  __OM  uint32_t  NONCE0;                       /*!< (@ 0x00000010) Bits 31:0 of DMA NONCE                                     */
  __OM  uint32_t  NONCE1;                       /*!< (@ 0x00000014) Bits 63:32 of DMA NONCE                                    */
  __OM  uint32_t  NONCE2;                       /*!< (@ 0x00000018) Bits 95:64 of DMA NONCE                                    */
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x0000001C) Enable stream cipher for EasyDMA                           */
} QSPI_DMA_ENC_Type;                            /*!< Size = 32 (0x20)                                                          */


/**
  * @brief NFCT_FRAMESTATUS [FRAMESTATUS] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RX;                           /*!< (@ 0x00000000) Result of last incoming frame                              */
} NFCT_FRAMESTATUS_Type;                        /*!< Size = 4 (0x4)                                                            */


/**
  * @brief NFCT_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of outgoing frames                           */
  __IOM uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of outgoing frame                                     */
} NFCT_TXD_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief NFCT_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of incoming frames                           */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of last incoming frame                                */
} NFCT_RXD_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief QDEC_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LED;                          /*!< (@ 0x00000000) Pin select for LED signal                                  */
  __IOM uint32_t  A;                            /*!< (@ 0x00000004) Pin select for A signal                                    */
  __IOM uint32_t  B;                            /*!< (@ 0x00000008) Pin select for B signal                                    */
} QDEC_PSEL_Type;                               /*!< Size = 12 (0xc)                                                           */


/**
  * @brief USBD_HALTED [HALTED] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  EPIN[8];                      /*!< (@ 0x00000000) Description collection: IN endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  EPOUT[8];                     /*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
} USBD_HALTED_Type;                             /*!< Size = 68 (0x44)                                                          */


/**
  * @brief USBD_SIZE [SIZE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  EPOUT[8];                     /*!< (@ 0x00000000) Description collection: Number of bytes received
                                                                    last in the data stage of this OUT endpoint                */
  __IM  uint32_t  ISOOUT;                       /*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
                                                                    data endpoint                                              */
} USBD_SIZE_Type;                               /*!< Size = 36 (0x24)                                                          */


/**
  * @brief USBD_EPIN [EPIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Description cluster: Endpoint EasyDMA configuration        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x00000010) Description cluster: EasyDMA list type                     */
} USBD_EPIN_Type;                               /*!< Size = 20 (0x14)                                                          */


/**
  * @brief USBD_ISOIN [ISOIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Isochronous endpoint EasyDMA configuration                 */
} USBD_ISOIN_Type;                              /*!< Size = 16 (0x10)                                                          */


/**
  * @brief USBD_EPOUT [EPOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Description cluster: Endpoint EasyDMA configuration        */
  __IOM uint32_t  LIST;                         /*!< (@ 0x00000010) Description cluster: EasyDMA list type                     */
} USBD_EPOUT_Type;                              /*!< Size = 20 (0x14)                                                          */


/**
  * @brief USBD_ISOOUT [ISOOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000000C) Isochronous endpoint EasyDMA configuration                 */
} USBD_ISOOUT_Type;                             /*!< Size = 16 (0x10)                                                          */


/**
  * @brief GPIO_PIN [PIN] (Pin n direct access)
  */
typedef struct {
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000000) Description cluster: Pin n direct access output
                                                                    register                                                   */
  __IOM uint32_t  IN;                           /*!< (@ 0x00000004) Description cluster: Pin n direct access input
                                                                    register                                                   */
} GPIO_PIN_Type;                                /*!< Size = 8 (0x8)                                                            */


/**
  * @brief VMC_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000000) Description cluster: RAM[n] power control register         */
  __IOM uint32_t  POWERSET;                     /*!< (@ 0x00000004) Description cluster: RAM[n] power control set
                                                                    register                                                   */
  __IOM uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAM[n] power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} VMC_RAM_Type;                                 /*!< Size = 16 (0x10)                                                          */


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                        CACHEDATA_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CACHEDATA (CACHEDATA_S)
  */

typedef struct {                                /*!< (@ 0x00F00000) CACHEDATA_S Structure                                      */
  __IOM CACHEDATA_SET_Type SET[256];            /*!< (@ 0x00000000) Unspecified                                                */
} NRF_CACHEDATA_Type;                           /*!< Size = 8192 (0x2000)                                                      */



/* =========================================================================================================================== */
/* ================                                        CACHEINFO_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CACHEINFO (CACHEINFO_S)
  */

typedef struct {                                /*!< (@ 0x00F08000) CACHEINFO_S Structure                                      */
  __IOM CACHEINFO_SET_Type SET[256];            /*!< (@ 0x00000000) Unspecified                                                */
} NRF_CACHEINFO_Type;                           /*!< Size = 2048 (0x800)                                                       */



/* =========================================================================================================================== */
/* ================                                          FICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory Information Configuration Registers (FICR_S)
  */

typedef struct {                                /*!< (@ 0x00FF0000) FICR_S Structure                                           */
  __IM  uint32_t  CHIPCONF00;                   /*!< (@ 0x00000000) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF01;                   /*!< (@ 0x00000004) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF02;                   /*!< (@ 0x00000008) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF03;                   /*!< (@ 0x0000000C) Miscellaneous analog configuration. Will be set
                                                                    during production test.                                    */
  __IM  uint32_t  CHIPCONF04;                   /*!< (@ 0x00000010) Configuration for VREGMAIN. Will be set during
                                                                    production test.                                           */
  __IM  uint32_t  CHIPCONF05;                   /*!< (@ 0x00000014) Configuration for VREGANA. Will be set during
                                                                    production test.                                           */
  __IM  uint32_t  CHIPCONF06;                   /*!< (@ 0x00000018) Configuration for VREGRADIO and VREGNETWORK.
                                                                    Will be set during production test.                        */
  __IM  uint32_t  CHIPCONF07;                   /*!< (@ 0x0000001C) ICMP timer configuration for VREGRADIO and VREGNETWORK.
                                                                    Will be set during production test.                        */
  __IM  uint32_t  CHIPCONF08;                   /*!< (@ 0x00000020) Configuration for VREGH. Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  CHIPCONF09;                   /*!< (@ 0x00000024) Configuration for VREGH. Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  CHIPCONF10;                   /*!< (@ 0x00000028) Configuration for Application, Audio and 192M
                                                                    PLLs,                                                      */
  __IM  uint32_t  CHIPCONF11;                   /*!< (@ 0x0000002C) RAM redundancy configuration                               */
  __IOM uint32_t  CHIPCONF12;                   /*!< (@ 0x00000030) Backdoor trim values for Application RAM, CPUCACHE
                                                                    and CC312                                                  */
  __IOM uint32_t  CHIPCONF13;                   /*!< (@ 0x00000034) RCOSC32K trim values                                       */
  __IOM uint32_t  CHIPCONF14;                   /*!< (@ 0x00000038) Trim values for Application and Audio PLL                  */
  __IOM uint32_t  CHIPCONF15;                   /*!< (@ 0x0000003C) Trim values for the 192M PLL                               */
  __IM  uint32_t  RESERVED[48];
  __IM  uint32_t  TESTSTATUS;                   /*!< (@ 0x00000100) Code memory test status. Will be set during production
                                                                    test.                                                      */
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CPTEST0;                      /*!< (@ 0x00000110) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST00;                     /*!< (@ 0x00000114) Result from Circuit Probe test                             */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  CPTEST1;                      /*!< (@ 0x00000120) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST2;                      /*!< (@ 0x00000124) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST3;                      /*!< (@ 0x00000128) Result from Circuit Probe test                             */
  __IM  uint32_t  CPTEST4;                      /*!< (@ 0x0000012C) Result from Circuit Probe test                             */
  __IOM FICR_SOCINFO_Type SOCINFO;              /*!< (@ 0x00000130) Unspecified                                                */
  __IM  uint32_t  RESERVED3[17];
  __IM  uint32_t  CPTEST5;                      /*!< (@ 0x00000180) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST6;                      /*!< (@ 0x00000184) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST7;                      /*!< (@ 0x00000188) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  CPTEST8;                      /*!< (@ 0x0000018C) Result from Circuit Probe test, flash repair
                                                                    information                                                */
  __IM  uint32_t  RESERVED4[28];
  __IOM FICR_INFO_Type INFO;                    /*!< (@ 0x00000200) Device info                                                */
  __IM  uint32_t  RESERVED5;
  __IOM FICR_SOCINFO1_Type SOCINFO1;            /*!< (@ 0x00000230) These registers are a workaround for YOPAN-38
                                                                    on Enga / Proto3                                           */
  __IM  uint32_t  RESERVED6[17];
  __IM  uint32_t  FLASHPWRUP0;                  /*!< (@ 0x00000280) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP1;                  /*!< (@ 0x00000284) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP2;                  /*!< (@ 0x00000288) Power-up pattern for flash                                 */
  __IM  uint32_t  FLASHPWRUP3;                  /*!< (@ 0x0000028C) Power-up pattern for flash                                 */
  __IM  uint32_t  RESERVED7[28];
  __IOM FICR_TRIMCNF_Type TRIMCNF[32];          /*!< (@ 0x00000300) Unspecified                                                */
  __IM  uint32_t  RESERVED8[20];
  __IOM FICR_NFC_Type NFC;                      /*!< (@ 0x00000450) Unspecified                                                */
  __IM  uint32_t  RESERVED9[232];
  __IM  uint32_t  PRODTEST[3];                  /*!< (@ 0x00000800) Description collection: Production test signature
                                                                    n                                                          */
  __IM  uint32_t  RESERVED10[5];
  __IM  uint32_t  CPVBGTRIM;                    /*!< (@ 0x00000820) VBG TRIM in CP flow. Reserved for CP                       */
  __IM  uint32_t  RESERVED11[247];
  __IOM FICR_TRNG90B_Type TRNG90B;              /*!< (@ 0x00000C00) NIST800-90B RNG calibration data                           */
  __IM  uint32_t  XOSC32MTRIM;                  /*!< (@ 0x00000C20) XOSC32M capacitor selection trim values                    */
} NRF_FICR_Type;                                /*!< Size = 3108 (0xc24)                                                       */



/* =========================================================================================================================== */
/* ================                                          UICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief User Information Configuration Registers User information configuration registers (UICR_S)
  */

typedef struct {                                /*!< (@ 0x00FF8000) UICR_S Structure                                           */
  __IOM uint32_t  APPROTECT;                    /*!< (@ 0x00000000) Access port protection                                     */
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  EXTSUPPLY;                    /*!< (@ 0x0000000C) Enable external circuitry to be supplied from
                                                                    VDD pin. Applicable in 'High voltage mode'
                                                                    only.                                                      */
  __IOM uint32_t  VREGHVOUT;                    /*!< (@ 0x00000010) GPIO reference voltage / external output supply
                                                                    voltage in 'High voltage mode'.                            */
  __IOM uint32_t  HFXOCNT;                      /*!< (@ 0x00000014) HFXO startup counter                                       */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  SECUREAPPROTECT;              /*!< (@ 0x0000001C) Secure access port protection                              */
  __IOM uint32_t  ERASEPROTECT;                 /*!< (@ 0x00000020) Erase protection                                           */
  __IOM uint32_t  TINSTANCE;                    /*!< (@ 0x00000024) SW-DP Target instance                                      */
  __IOM uint32_t  NFCPINS;                      /*!< (@ 0x00000028) Setting of pins dedicated to NFC functionality:
                                                                    NFC antenna or GPIO                                        */
  __IM  uint32_t  RESERVED2[53];
  __IOM uint32_t  OTP[192];                     /*!< (@ 0x00000100) Description collection: One time programmable
                                                                    memory                                                     */
  __IOM UICR_KEYSLOT_Type KEYSLOT;              /*!< (@ 0x00000400) Unspecified                                                */
} NRF_UICR_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                    PCGCMASTER_CM4SS_S                                     ================ */
/* =========================================================================================================================== */


/**
  * @brief PCGC Master 0 (PCGCMASTER_CM4SS_S)
  */

typedef struct {                                /*!< (@ 0x50002000) PCGCMASTER_CM4SS_S Structure                               */
  __IM  uint32_t  RESERVED[56];
  __IM  uint32_t  SETPWRCONTHRESHOLDBASE[3];    /*!< (@ 0x000000E0) Description collection: Set power consumption
                                                                    threshold base for power source / regulator
                                                                    n                                                          */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  SETPOWERCONSUMPTIONBASE[2];   /*!< (@ 0x00000100) Description collection: Set power consumption
                                                                    base for power/clock pair n                                */
  __IM  uint32_t  RESERVED2[702];
  __IM  uint32_t  UNLOCKBACKDOORS;              /*!< (@ 0x00000C00) Unlock backdoors                                           */
  __IM  uint32_t  ENABLEPOWERREGFORCE;          /*!< (@ 0x00000C04) Enable power reg force                                     */
  __IM  uint32_t  POWERREGFORCE;                /*!< (@ 0x00000C08) Force reg                                                  */
  __IM  uint32_t  RESERVED3;
  __IM  uint32_t  MASTERFORCEREG;               /*!< (@ 0x00000C10) Force reg                                                  */
  __IM  uint32_t  RESERVED4[59];
  __IM  uint32_t  CLOCKFORCEREG[5];             /*!< (@ 0x00000D00) Description collection: Force clock n                      */
} NRF_PCGCMASTER_Type;                          /*!< Size = 3348 (0xd14)                                                       */



/* =========================================================================================================================== */
/* ================                                       GPIOCONFIG_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief PCGCSlave 0 (GPIOCONFIG_S)
  */

typedef struct {                                /*!< (@ 0x50042000) GPIOCONFIG_S Structure                                     */
  __IM  uint32_t  RESERVED[30];
  __IM  uint32_t  TRIGZEROPENALTY;              /*!< (@ 0x00000078) Trigger zero penalty                                       */
  __IM  uint32_t  TRIGFULLPENALTY;              /*!< (@ 0x0000007C) Trigger full penalty                                       */
  __IM  uint32_t  RESERVED1[736];
  __IM  uint32_t  PENALTY[2];                   /*!< (@ 0x00000C00) Description collection: Penalty level for power/clock
                                                                    pair n                                                     */
  __IM  uint32_t  RESERVED2[30];
  __IM  uint32_t  FORCEOVERRIDE[2];             /*!< (@ 0x00000C80) Description collection: Force override of power/clock
                                                                    pair n                                                     */
} NRF_PCGCSLAVE_Type;                           /*!< Size = 3208 (0xc88)                                                       */



/* =========================================================================================================================== */
/* ================                                       RAMBISTHUB_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief RAM BIST Hub (RAMBISTHUB_S)
  */

typedef struct {                                /*!< (@ 0x50108000) RAMBISTHUB_S Structure                                     */
  __IOM uint32_t  RUN;                          /*!< (@ 0x00000000) RUN BIST                                                   */
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  SLEEP;                        /*!< (@ 0x00000100) BIST SLEEP EVENT                                           */
  __IOM uint32_t  FINISHED;                     /*!< (@ 0x00000104) BIST FINISHED EVENT                                        */
  __IM  uint32_t  RESERVED1[254];
  __IOM uint32_t  HUBENABLE;                    /*!< (@ 0x00000500) RAM BIST Hub enable                                        */
  __IOM uint32_t  SELECTBIST;                   /*!< (@ 0x00000504) Select bits for the individual BISTs to run                */
  __IOM uint32_t  BISTSTATUS;                   /*!< (@ 0x00000508) BIST status                                                */
  __IOM uint32_t  TESTTYPE;                     /*!< (@ 0x0000050C) RAM BIST test type                                         */
  __OM  uint32_t  FORCEONRETENTION;             /*!< (@ 0x00000510) Power request override to force RAM retention
                                                                    on                                                         */
  __IM  uint32_t  RESERVED2[59];
  __IOM uint32_t  CLAMP0[32];                   /*!< (@ 0x00000600) Description collection: Block clamping register
                                                                    0                                                          */
  __IOM uint32_t  CLAMP1[32];                   /*!< (@ 0x00000680) Description collection: Block clamping register
                                                                    1                                                          */
  __IM  uint32_t  FAULTY0[32];                  /*!< (@ 0x00000700) Description collection: Faulty RAM block indication
                                                                    register0 for RamBist n                                    */
  __IM  uint32_t  FAULTY1[32];                  /*!< (@ 0x00000780) Description collection: Faulty RAM block indication
                                                                    register1 for RamBist n                                    */
} NRF_RAMBISTHUB_Type;                          /*!< Size = 2048 (0x800)                                                       */



/* =========================================================================================================================== */
/* ================                                           CTI_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Cross-Trigger Interface control. NOTE: this is not a separate peripheral, but describes CM33 functionality. (CTI_S)
  */

typedef struct {                                /*!< (@ 0xE0042000) CTI_S Structure                                            */
  __IOM uint32_t  CTICONTROL;                   /*!< (@ 0x00000000) CTI Control register                                       */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  CTIINTACK;                    /*!< (@ 0x00000010) CTI Interrupt Acknowledge register                         */
  __IOM uint32_t  CTIAPPSET;                    /*!< (@ 0x00000014) CTI Application Trigger Set register                       */
  __OM  uint32_t  CTIAPPCLEAR;                  /*!< (@ 0x00000018) CTI Application Trigger Clear register                     */
  __OM  uint32_t  CTIAPPPULSE;                  /*!< (@ 0x0000001C) CTI Application Pulse register                             */
  __IOM uint32_t  CTIINEN[8];                   /*!< (@ 0x00000020) Description collection: CTI Trigger input                  */
  __IM  uint32_t  RESERVED1[24];
  __IOM uint32_t  CTIOUTEN[8];                  /*!< (@ 0x000000A0) Description collection: CTI Trigger output                 */
  __IM  uint32_t  RESERVED2[28];
  __IM  uint32_t  CTITRIGINSTATUS;              /*!< (@ 0x00000130) CTI Trigger In Status register Because the register
                                                                    provides a view of the raw ctitrigin inputs,
                                                                    the reset value is UNKNOWN.                                */
  __IM  uint32_t  CTITRIGOUTSTATUS;             /*!< (@ 0x00000134) CTI Trigger Out Status register                            */
  __IM  uint32_t  CTICHINSTATUS;                /*!< (@ 0x00000138) CTI Channel In Status register Because the register
                                                                    provides a view of the raw ctichin inputs,
                                                                    the reset value is UNKNOWN.                                */
  __IM  uint32_t  CTICHOUTSTATUS;               /*!< (@ 0x0000013C) CTI Channel Out Status register                            */
  __IOM uint32_t  CTIGATE;                      /*!< (@ 0x00000140) Enable CTI Channel Gate register                           */
  __IOM uint32_t  ASICCTL;                      /*!< (@ 0x00000144) External Multiplexer Control register                      */
  __IM  uint32_t  RESERVED3[869];
  __OM  uint32_t  ITCHINACK;                    /*!< (@ 0x00000EDC) Integration Test Channel Input Acknowledge register        */
  __OM  uint32_t  ITTRIGINACK;                  /*!< (@ 0x00000EE0) Integration Test Trigger Input Acknowledge register        */
  __OM  uint32_t  ITCHOUT;                      /*!< (@ 0x00000EE4) Integration Test Channel Output register                   */
  __OM  uint32_t  ITTRIGOUT;                    /*!< (@ 0x00000EE8) Integration Test Trigger Output register                   */
  __IM  uint32_t  ITCHOUTACK;                   /*!< (@ 0x00000EEC) Integration Test Channel Output Acknowledge register       */
  __IM  uint32_t  ITTRIGOUTACK;                 /*!< (@ 0x00000EF0) Integration Test Trigger Output Acknowledge register       */
  __IM  uint32_t  ITCHIN;                       /*!< (@ 0x00000EF4) Integration Test Channel Input register                    */
  __IM  uint32_t  ITTRIGIN;                     /*!< (@ 0x00000EF8) Integration Test Trigger input register                    */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  ITCTRL;                       /*!< (@ 0x00000F00) Integration Mode Control register                          */
  __IM  uint32_t  RESERVED5[39];
  __IOM uint32_t  CLAIMSET;                     /*!< (@ 0x00000FA0) Claim Tag Set register                                     */
  __IOM uint32_t  CLAIMCLR;                     /*!< (@ 0x00000FA4) Claim Tag Clear register                                   */
  __IM  uint32_t  RESERVED6[2];
  __OM  uint32_t  LAR;                          /*!< (@ 0x00000FB0) Lock Address Register                                      */
  __IM  uint32_t  LSR;                          /*!< (@ 0x00000FB4) Lock Status Register                                       */
  __IM  uint32_t  AUTHSTATUS;                   /*!< (@ 0x00000FB8) Authentication Status Register                             */
  __IM  uint32_t  DEVARCH;                      /*!< (@ 0x00000FBC) Device Architecture register                               */
  __IM  uint32_t  RESERVED7[2];
  __IM  uint32_t  DEVID;                        /*!< (@ 0x00000FC8) Device Configuration register                              */
  __IM  uint32_t  DEVTYPE;                      /*!< (@ 0x00000FCC) Device Type Identifier register                            */
  __IM  uint32_t  PIDR4;                        /*!< (@ 0x00000FD0) Peripheral ID4 Register                                    */
  __IM  uint32_t  PIDR5;                        /*!< (@ 0x00000FD4) Peripheral ID5 register                                    */
  __IM  uint32_t  PIDR6;                        /*!< (@ 0x00000FD8) Peripheral ID6 register                                    */
  __IM  uint32_t  PIDR7;                        /*!< (@ 0x00000FDC) Peripheral ID7 register                                    */
  __IM  uint32_t  PIDR0;                        /*!< (@ 0x00000FE0) Peripheral ID0 Register                                    */
  __IM  uint32_t  PIDR1;                        /*!< (@ 0x00000FE4) Peripheral ID1 Register                                    */
  __IM  uint32_t  PIDR2;                        /*!< (@ 0x00000FE8) Peripheral ID2 Register                                    */
  __IM  uint32_t  PIDR3;                        /*!< (@ 0x00000FEC) Peripheral ID3 Register                                    */
  __IM  uint32_t  CIDR0;                        /*!< (@ 0x00000FF0) Component ID0 Register                                     */
  __IM  uint32_t  CIDR1;                        /*!< (@ 0x00000FF4) Component ID1 Register                                     */
  __IM  uint32_t  CIDR2;                        /*!< (@ 0x00000FF8) Component ID2 Register                                     */
  __IM  uint32_t  CIDR3;                        /*!< (@ 0x00000FFC) Component ID3 Register                                     */
} NRF_CTI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           TAD_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Trace and debug control (TAD_S)
  */

typedef struct {                                /*!< (@ 0xE0080000) TAD_S Structure                                            */
  __IOM uint32_t  FORCEON;                      /*!< (@ 0x00000000) Force on debug domain                                      */
  __OM  uint32_t  CLOCKSTART;                   /*!< (@ 0x00000004) Start all trace and debug clocks.                          */
  __OM  uint32_t  CLOCKSTOP;                    /*!< (@ 0x00000008) Stop all trace and debug clocks.                           */
  __IM  uint32_t  RESERVED[317];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable debug domain and aquire selected GPIOs              */
  __IOM TAD_PSEL_Type PSEL;                     /*!< (@ 0x00000504) Unspecified                                                */
  __IOM uint32_t  TRACEPORTSPEED;               /*!< (@ 0x00000518) Clocking options for the Trace Port debug interface.       */
} NRF_TAD_Type;                                 /*!< Size = 1308 (0x51c)                                                       */



/* =========================================================================================================================== */
/* ================                                          AMLI_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief AHB Multi-Layer Interface 0 (AMLI_NS)
  */

typedef struct {                                /*!< (@ 0x40000000) AMLI_NS Structure                                          */
  __IM  uint32_t  RESERVED[896];
  __IOM AMLI_RAMPRI_Type RAMPRI;                /*!< (@ 0x00000E00) RAM configurable priority configuration structure          */
} NRF_AMLI_Type;                                /*!< Size = 3592 (0xe08)                                                       */



/* =========================================================================================================================== */
/* ================                                          DCNF_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Domain configuration management 0 (DCNF_NS)
  */

typedef struct {                                /*!< (@ 0x40000000) DCNF_NS Structure                                          */
  __IM  uint32_t  RESERVED[264];
  __IM  uint32_t  CPUID;                        /*!< (@ 0x00000420) CPU ID of this subsystem                                   */
  __IM  uint32_t  RESERVED1[7];
  __IOM DCNF_EXTPERI_Type EXTPERI[1];           /*!< (@ 0x00000440) Unspecified                                                */
  __IM  uint32_t  RESERVED2[7];
  __IOM DCNF_EXTRAM_Type EXTRAM[1];             /*!< (@ 0x00000460) Unspecified                                                */
  __IM  uint32_t  RESERVED3[7];
  __IOM DCNF_EXTCODE_Type EXTCODE[1];           /*!< (@ 0x00000480) Unspecified                                                */
  __IM  uint32_t  RESERVED4[31];
  __IOM DCNF_EXTCODESYNC_Type EXTCODESYNC[1];   /*!< (@ 0x00000500) Unspecified                                                */
  __IM  uint32_t  RESERVED5[319];
  __IOM DCNF_FPGAINFO_Type FPGAINFO;            /*!< (@ 0x00000A00) Exists only on the FPGA nightly build                      */
  __IM  uint32_t  RESERVED6[3];
  __IOM uint32_t  AMLICLOCKDELAY;               /*!< (@ 0x00000A20) Trim value for AMLI clock delay                            */
} NRF_DCNF_Type;                                /*!< Size = 2596 (0xa24)                                                       */



/* =========================================================================================================================== */
/* ================                                          FPU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief FPU control peripheral 0 (FPU_NS)
  */

typedef struct {                                /*!< (@ 0x40000000) FPU_NS Structure                                           */
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_INVALIDOPERATION;      /*!< (@ 0x00000100) An FPUIOC exception triggered by an invalid operation
                                                                    has occurred in the FPU                                    */
  __IOM uint32_t  EVENTS_DIVIDEBYZERO;          /*!< (@ 0x00000104) An FPUDZC exception triggered by a floating-point
                                                                    divide-by-zero operation has occurred in
                                                                    the FPU                                                    */
  __IOM uint32_t  EVENTS_OVERFLOW;              /*!< (@ 0x00000108) An FPUOFC exception triggered by a floating-point
                                                                    overflow has occurred in the FPU                           */
  __IOM uint32_t  EVENTS_UNDERFLOW;             /*!< (@ 0x0000010C) An FPUUFC exception triggered by a floating-point
                                                                    underflow has occurred in the FPU                          */
  __IOM uint32_t  EVENTS_INEXACT;               /*!< (@ 0x00000110) An FPUIXC exception triggered by an inexact floating-point
                                                                    operation has occurred in the FPU                          */
  __IOM uint32_t  EVENTS_DENORMALINPUT;         /*!< (@ 0x00000114) An FPUIDC exception triggered by a denormal floating-point
                                                                    input has occurred in the FPU                              */
  __IM  uint32_t  RESERVED1[122];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
} NRF_FPU_Type;                                 /*!< Size = 780 (0x30c)                                                        */



/* =========================================================================================================================== */
/* ================                                          CACHE_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Cache (CACHE_S)
  */

typedef struct {                                /*!< (@ 0x50001000) CACHE_S Structure                                          */
  __IM  uint32_t  RESERVED[256];
  __IOM CACHE_PROFILING_Type PROFILING[2];      /*!< (@ 0x00000400) Unspecified                                                */
  __IM  uint32_t  RESERVED1[48];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable cache                                               */
  __OM  uint32_t  INVALIDATE;                   /*!< (@ 0x00000504) Invalidate the cache                                       */
  __OM  uint32_t  ERASE;                        /*!< (@ 0x00000508) Erase the cache                                            */
  __IOM uint32_t  PROFILINGENABLE;              /*!< (@ 0x0000050C) Enable the profiling counters                              */
  __OM  uint32_t  PROFILINGCLEAR;               /*!< (@ 0x00000510) Clear the profiling counters                               */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000514) Cache mode. Switching from Cache to RAM mode
                                                                    causes the RAM to be cleared. Switching
                                                                    from RAM to Cache mode causes the cache
                                                                    to be invalidated.                                         */
  __IOM uint32_t  DEBUGLOCK;                    /*!< (@ 0x00000518) Lock debug mode Ignored in RAM mode.                       */
  __IOM uint32_t  ERASESTATUS;                  /*!< (@ 0x0000051C) Cache erase status                                         */
  __IOM uint32_t  WRITELOCK;                    /*!< (@ 0x00000520) Lock cache updates. Prevents updating of cache
                                                                    content on cache misses, but will continue
                                                                    to lookup instruction/data fetches in content
                                                                    already present in the cache. Ignored in
                                                                    RAM mode.                                                  */
  __IOM uint32_t  PREFETCHHINT;                 /*!< (@ 0x00000524) Enable the cache to utilize hint signals in the
                                                                    instruction prefect strategy. Each of the
                                                                    bits enables/disables the corresponding
                                                                    hint signal. Ignored in RAM mode.                          */
} NRF_CACHE_Type;                               /*!< Size = 1320 (0x528)                                                       */



/* =========================================================================================================================== */
/* ================                                           SPU_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System protection unit (SPU_S)
  */

typedef struct {                                /*!< (@ 0x50003000) SPU_S Structure                                            */
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_RAMACCERR;             /*!< (@ 0x00000100) A security violation has been detected for the
                                                                    RAM memory space                                           */
  __IOM uint32_t  EVENTS_FLASHACCERR;           /*!< (@ 0x00000104) A security violation has been detected for the
                                                                    flash memory space                                         */
  __IOM uint32_t  EVENTS_PERIPHACCERR;          /*!< (@ 0x00000108) A security violation has been detected on one
                                                                    or several peripherals                                     */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  PUBLISH_RAMACCERR;            /*!< (@ 0x00000180) Publish configuration for event RAMACCERR                  */
  __IOM uint32_t  PUBLISH_FLASHACCERR;          /*!< (@ 0x00000184) Publish configuration for event FLASHACCERR                */
  __IOM uint32_t  PUBLISH_PERIPHACCERR;         /*!< (@ 0x00000188) Publish configuration for event PERIPHACCERR               */
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  CAP;                          /*!< (@ 0x00000400) Show implemented features for the current device           */
  __IOM uint32_t  CPULOCK;                      /*!< (@ 0x00000404) Configure bits to lock down CPU features at runtime        */
  __IM  uint32_t  RESERVED4[14];
  __IOM SPU_EXTDOMAIN_Type EXTDOMAIN[1];        /*!< (@ 0x00000440) Unspecified                                                */
  __IM  uint32_t  RESERVED5[15];
  __IOM SPU_DPPI_Type DPPI[1];                  /*!< (@ 0x00000480) Unspecified                                                */
  __IM  uint32_t  RESERVED6[14];
  __IOM SPU_GPIOPORT_Type GPIOPORT[2];          /*!< (@ 0x000004C0) Unspecified                                                */
  __IM  uint32_t  RESERVED7[12];
  __IOM SPU_FLASHNSC_Type FLASHNSC[2];          /*!< (@ 0x00000500) Unspecified                                                */
  __IM  uint32_t  RESERVED8[12];
  __IOM SPU_RAMNSC_Type RAMNSC[2];              /*!< (@ 0x00000540) Unspecified                                                */
  __IM  uint32_t  RESERVED9[44];
  __IOM SPU_FLASHREGION_Type FLASHREGION[64];   /*!< (@ 0x00000600) Unspecified                                                */
  __IOM SPU_RAMREGION_Type RAMREGION[64];       /*!< (@ 0x00000700) Unspecified                                                */
  __IOM SPU_PERIPHID_Type PERIPHID[256];        /*!< (@ 0x00000800) Unspecified                                                */
} NRF_SPU_Type;                                 /*!< Size = 3072 (0xc00)                                                       */



/* =========================================================================================================================== */
/* ================                                      OSCILLATORS_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Oscillator control 0 (OSCILLATORS_NS)
  */

typedef struct {                                /*!< (@ 0x40004000) OSCILLATORS_NS Structure                                   */
  __IM  uint32_t  RESERVED[353];
  __IOM uint32_t  ATECLOCK;                     /*!< (@ 0x00000584) Analog test bus control for clock modules                  */
  __IM  uint32_t  RESERVED1[15];
  __IOM uint32_t  XOSC32MCAPS;                  /*!< (@ 0x000005C4) Programmable capacitance of XC1 and XC2                    */
  __IM  uint32_t  RESERVED2[14];
  __IOM uint32_t  BYPASSHFXOSC;                 /*!< (@ 0x00000600) Enable or disable bypass of HFCLK crystal oscillator
                                                                    with external clock source                                 */
  __IOM uint32_t  GPIOBYPASS;                   /*!< (@ 0x00000604) Enable bypass from GPIO                                    */
  __IM  uint32_t  RESERVED3[14];
  __IOM OSCILLATORS_AUDIOPLL_Type AUDIOPLL;     /*!< (@ 0x00000640) Unspecified                                                */
  __IM  uint32_t  RESERVED4[3];
  __IOM OSCILLATORS_CPUPLL_Type CPUPLL;         /*!< (@ 0x00000660) Unspecified                                                */
  __IM  uint32_t  RESERVED5[2];
  __IOM OSCILLATORS_PLL64M_Type PLL64M;         /*!< (@ 0x00000680) Unspecified                                                */
  __IM  uint32_t  RESERVED6[3];
  __IOM OSCILLATORS_PLL192M_Type PLL192M;       /*!< (@ 0x000006A0) Unspecified                                                */
  __IM  uint32_t  RESERVED7;
  __IOM OSCILLATORS_XOSC32KI_Type XOSC32KI;     /*!< (@ 0x000006C0) Unspecified                                                */
} NRF_OSCILLATORS_Type;                         /*!< Size = 1764 (0x6e4)                                                       */



/* =========================================================================================================================== */
/* ================                                       REGULATORS_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Voltage regulators 0 (REGULATORS_NS)
  */

typedef struct {                                /*!< (@ 0x40004000) REGULATORS_NS Structure                                    */
  __IM  uint32_t  RESERVED[266];
  __IM  uint32_t  MAINREGSTATUS;                /*!< (@ 0x00000428) Main supply status                                         */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  DISABLEHPBOR;                 /*!< (@ 0x00000434) Enable or disable HPBOR                                    */
  __IM  uint32_t  RESERVED2[50];
  __OM  uint32_t  SYSTEMOFF;                    /*!< (@ 0x00000500) System OFF register                                        */
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  POFCON;                       /*!< (@ 0x00000510) Power-fail comparator configuration                        */
  __OM  uint32_t  IGNOREDAPCPWRREGMODE;         /*!< (@ 0x00000514) Ignore DAPCP power mode                                    */
  __IOM uint32_t  RSTVTHTRIM;                   /*!< (@ 0x00000518) Threshold trim, power-on reset                             */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  BGREFTRIM;                    /*!< (@ 0x00000520) Master bias bandgap trim                                   */
  __IM  uint32_t  RESERVED5[9];
  __IOM uint32_t  FORCEOFFNVM;                  /*!< (@ 0x00000548) Force off NVM supply. See also the internal section
                                                                    in the NVMC chapter.                                       */
  __IM  uint32_t  RESERVED6[15];
  __IOM uint32_t  ATEPOWER;                     /*!< (@ 0x00000588) Analog test bus control for power modules                  */
  __IOM uint32_t  VREFULPTRIM;                  /*!< (@ 0x0000058C) Trim value of VREF_ULP                                     */
  __IM  uint32_t  RESERVED7[20];
  __IOM REGULATORS_VREGUSB_Type VREGUSB;        /*!< (@ 0x000005E0) Unspecified                                                */
  __IM  uint32_t  RESERVED8[67];
  __IOM REGULATORS_VREGMAIN_Type VREGMAIN;      /*!< (@ 0x00000704) Unspecified                                                */
  __IM  uint32_t  RESERVED9[40];
  __IOM REGULATORS_VREGANA_Type VREGANA;        /*!< (@ 0x00000800) Unspecified                                                */
  __IM  uint32_t  RESERVED10[57];
  __IOM REGULATORS_VREGRADIO_Type VREGRADIO;    /*!< (@ 0x00000900) Unspecified                                                */
  __IM  uint32_t  RESERVED11[47];
  __IOM REGULATORS_VREGNETWORK_Type VREGNETWORK;/*!< (@ 0x00000A00) Unspecified                                                */
  __IM  uint32_t  RESERVED12[53];
  __IOM REGULATORS_VREGH_Type VREGH;            /*!< (@ 0x00000B00) Unspecified                                                */
  __IM  uint32_t  RESERVED13[229];
  __OM  uint32_t  DISABLEPACSYSTEMOFFACK;       /*!< (@ 0x00000EE4) Enable or disable System OFF ack from PAC                  */
  __OM  uint32_t  DISABLESRAMSYSTEMOFFACK;      /*!< (@ 0x00000EE8) Enable or disable System OFF ack from SRAM                 */
  __OM  uint32_t  DISABLENVMSYSTEMOFFACK;       /*!< (@ 0x00000EEC) Enable or disable System OFF ack from NVM                  */
} NRF_REGULATORS_Type;                          /*!< Size = 3824 (0xef0)                                                       */



/* =========================================================================================================================== */
/* ================                                         CLOCK_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock management 0 (CLOCK_NS)
  */

typedef struct {                                /*!< (@ 0x40005000) CLOCK_NS Structure                                         */
  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFCLK128M/HFCLK64M source as selected in
                                                                    HFCLKSRC                                                   */
  __OM  uint32_t  TASKS_HFCLKSTOP;              /*!< (@ 0x00000004) Stop HFCLK128M/HFCLK64M source                             */
  __OM  uint32_t  TASKS_LFCLKSTART;             /*!< (@ 0x00000008) Start LFCLK source as selected in LFCLKSRC                 */
  __OM  uint32_t  TASKS_LFCLKSTOP;              /*!< (@ 0x0000000C) Stop LFCLK source                                          */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000010) Start calibration of LFRC oscillator                       */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_HFCLKAUDIOSTART;        /*!< (@ 0x00000018) Start HFCLKAUDIO source                                    */
  __OM  uint32_t  TASKS_HFCLKAUDIOSTOP;         /*!< (@ 0x0000001C) Stop HFCLKAUDIO source                                     */
  __OM  uint32_t  TASKS_HFCLK192MSTART;         /*!< (@ 0x00000020) Start HFCLK192M source as selected in HFCLK192MSRC         */
  __OM  uint32_t  TASKS_HFCLK192MSTOP;          /*!< (@ 0x00000024) Stop HFCLK192M source                                      */
  __IM  uint32_t  RESERVED1[22];
  __IOM uint32_t  SUBSCRIBE_HFCLKSTART;         /*!< (@ 0x00000080) Subscribe configuration for task HFCLKSTART                */
  __IOM uint32_t  SUBSCRIBE_HFCLKSTOP;          /*!< (@ 0x00000084) Subscribe configuration for task HFCLKSTOP                 */
  __IOM uint32_t  SUBSCRIBE_LFCLKSTART;         /*!< (@ 0x00000088) Subscribe configuration for task LFCLKSTART                */
  __IOM uint32_t  SUBSCRIBE_LFCLKSTOP;          /*!< (@ 0x0000008C) Subscribe configuration for task LFCLKSTOP                 */
  __IOM uint32_t  SUBSCRIBE_CAL;                /*!< (@ 0x00000090) Subscribe configuration for task CAL                       */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  SUBSCRIBE_HFCLKAUDIOSTART;    /*!< (@ 0x00000098) Subscribe configuration for task HFCLKAUDIOSTART           */
  __IOM uint32_t  SUBSCRIBE_HFCLKAUDIOSTOP;     /*!< (@ 0x0000009C) Subscribe configuration for task HFCLKAUDIOSTOP            */
  __IOM uint32_t  SUBSCRIBE_HFCLK192MSTART;     /*!< (@ 0x000000A0) Subscribe configuration for task HFCLK192MSTART            */
  __IOM uint32_t  SUBSCRIBE_HFCLK192MSTOP;      /*!< (@ 0x000000A4) Subscribe configuration for task HFCLK192MSTOP             */
  __IM  uint32_t  RESERVED3[22];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;          /*!< (@ 0x00000100) HFCLK128M/HFCLK64M source started                          */
  __IOM uint32_t  EVENTS_LFCLKSTARTED;          /*!< (@ 0x00000104) LFCLK source started                                       */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x0000011C) Calibration of LFRC oscillator complete event              */
  __IOM uint32_t  EVENTS_HFCLKAUDIOSTARTED;     /*!< (@ 0x00000120) HFCLKAUDIO source started                                  */
  __IOM uint32_t  EVENTS_HFCLK192MSTARTED;      /*!< (@ 0x00000124) HFCLK192M source started                                   */
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_HFCLKSTARTED;         /*!< (@ 0x00000180) Publish configuration for event HFCLKSTARTED               */
  __IOM uint32_t  PUBLISH_LFCLKSTARTED;         /*!< (@ 0x00000184) Publish configuration for event LFCLKSTARTED               */
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x0000019C) Publish configuration for event DONE                       */
  __IOM uint32_t  PUBLISH_HFCLKAUDIOSTARTED;    /*!< (@ 0x000001A0) Publish configuration for event HFCLKAUDIOSTARTED          */
  __IOM uint32_t  PUBLISH_HFCLK192MSTARTED;     /*!< (@ 0x000001A4) Publish configuration for event HFCLK192MSTARTED           */
  __IM  uint32_t  RESERVED7[86];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  INTPEND;                      /*!< (@ 0x0000030C) Pending interrupts                                         */
  __IM  uint32_t  RESERVED8[62];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) Status indicating which HFCLK128M/HFCLK64M source
                                                                    is running This register value in any CLOCK
                                                                    instance reflects status only due to configurations/action
                                                                    in that CLOCK instance.                                    */
  __IM  uint32_t  RESERVED9;
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) Status indicating which LFCLK source is running
                                                                    This register value in any CLOCK instance
                                                                    reflects status only due to configurations/actions
                                                                    in that CLOCK instance.                                    */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  HFCLKCURRFREQ;                /*!< (@ 0x00000430) Current frequency of HFCLK                                 */
  __IOM uint32_t  HFCLK192MCURRFREQ;            /*!< (@ 0x00000434) Current frequency of HFCLK192M                             */
  __IM  uint32_t  RESERVED11[6];
  __IM  uint32_t  HFCLKAUDIORUN;                /*!< (@ 0x00000450) Status indicating that HFCLKAUDIOSTART task has
                                                                    been triggered                                             */
  __IM  uint32_t  HFCLKAUDIOSTAT;               /*!< (@ 0x00000454) Status indicating which HFCLKAUDIO source is
                                                                    running                                                    */
  __IM  uint32_t  HFCLK192MRUN;                 /*!< (@ 0x00000458) Status indicating that HFCLK192MSTART task has
                                                                    been triggered                                             */
  __IM  uint32_t  HFCLK192MSTAT;                /*!< (@ 0x0000045C) Status indicating which HFCLK192M source is running        */
  __IM  uint32_t  RESERVED12[45];
  __IOM uint32_t  HFCLKSRC;                     /*!< (@ 0x00000514) Clock source for HFCLK128M/HFCLK64M                        */
  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for LFCLK                                     */
  __IM  uint32_t  RESERVED13[15];
  __IOM uint32_t  HFCLKCTRL;                    /*!< (@ 0x00000558) HFCLK128M frequency configuration                          */
  __IOM CLOCK_HFCLKAUDIO_Type HFCLKAUDIO;       /*!< (@ 0x0000055C) Unspecified                                                */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  HFCLKALWAYSRUN;               /*!< (@ 0x00000570) Automatic or manual control of HFCLK128M/HFCLK64M          */
  __IOM uint32_t  LFCLKALWAYSRUN;               /*!< (@ 0x00000574) Automatic or manual control of LFCLK                       */
  __IOM uint32_t  HFCLKAUDIOSRC;                /*!< (@ 0x00000578) Clock source for the HFCLKAUDIO oscillator                 */
  __IOM uint32_t  HFCLKAUDIOALWAYSRUN;          /*!< (@ 0x0000057C) Automatic or manual control of HFCLKAUDIO                  */
  __IOM uint32_t  HFCLK192MSRC;                 /*!< (@ 0x00000580) Clock source for HFCLK192M                                 */
  __IOM uint32_t  HFCLK192MALWAYSRUN;           /*!< (@ 0x00000584) Automatic or manual control of HFCLK192M                   */
  __IM  uint32_t  RESERVED15[12];
  __IOM uint32_t  HFCLK192MCTRL;                /*!< (@ 0x000005B8) HFCLK192M frequency configuration                          */
} NRF_CLOCK_Type;                               /*!< Size = 1468 (0x5bc)                                                       */



/* =========================================================================================================================== */
/* ================                                         POWER_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control 0 (POWER_NS)
  */

typedef struct {                                /*!< (@ 0x40005000) POWER_NS Structure                                         */
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;               /*!< (@ 0x00000078) Enable Constant Latency mode When going to sleep:
                                                                    CPU is clock gated, but regulators, oscillators
                                                                    and clock tree is kept on.                                 */
  __OM  uint32_t  TASKS_LOWPWR;                 /*!< (@ 0x0000007C) Enable Low-Power mode (variable latency) When
                                                                    going to sleep: Oscillators are switched
                                                                    off (if nothing else is requesting clocks).
                                                                    Regulators are switched off (if nothing
                                                                    else is requesting power).                                 */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_CONSTLAT;           /*!< (@ 0x000000F8) Subscribe configuration for task CONSTLAT                  */
  __IOM uint32_t  SUBSCRIBE_LOWPWR;             /*!< (@ 0x000000FC) Subscribe configuration for task LOWPWR                    */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_POFWARN;               /*!< (@ 0x00000108) Power failure warning                                      */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;            /*!< (@ 0x00000114) CPU entered WFI/WFE sleep                                  */
  __IOM uint32_t  EVENTS_SLEEPEXIT;             /*!< (@ 0x00000118) CPU exited WFI/WFE sleep                                   */
  __IM  uint32_t  RESERVED4[27];
  __IOM uint32_t  PUBLISH_POFWARN;              /*!< (@ 0x00000188) Publish configuration for event POFWARN                    */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  PUBLISH_SLEEPENTER;           /*!< (@ 0x00000194) Publish configuration for event SLEEPENTER                 */
  __IOM uint32_t  PUBLISH_SLEEPEXIT;            /*!< (@ 0x00000198) Publish configuration for event SLEEPEXIT                  */
  __IM  uint32_t  RESERVED6[89];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[132];
  __IOM uint32_t  GPREGRET[2];                  /*!< (@ 0x0000051C) Description collection: General purpose retention
                                                                    register                                                   */
} NRF_POWER_Type;                               /*!< Size = 1316 (0x524)                                                       */



/* =========================================================================================================================== */
/* ================                                         RESET_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset control 0 (RESET_NS)
  */

typedef struct {                                /*!< (@ 0x40005000) RESET_NS Structure                                         */
  __IM  uint32_t  RESERVED[256];
  __IOM uint32_t  RESETREAS;                    /*!< (@ 0x00000400) Reset reason                                               */
  __IM  uint32_t  RESERVED1[15];
  __IOM RESET_POWERSTATUS_Type POWERSTATUS;     /*!< (@ 0x00000440) Core power status                                          */
  __IM  uint32_t  RESERVED2[115];
  __IOM RESET_NETWORK_Type NETWORK;             /*!< (@ 0x00000610) ULP network core control                                   */
} NRF_RESET_Type;                               /*!< Size = 1564 (0x61c)                                                       */



/* =========================================================================================================================== */
/* ================                                         CTRLAP_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Control access port 0 (CTRLAP_NS)
  */

typedef struct {                                /*!< (@ 0x40006000) CTRLAP_NS Structure                                        */
  __IM  uint32_t  RESERVED[256];
  __IOM CTRLAPPERI_MAILBOX_Type MAILBOX;        /*!< (@ 0x00000400) Unspecified                                                */
  __IM  uint32_t  RESERVED1[30];
  __IOM CTRLAPPERI_ERASEPROTECT_Type ERASEPROTECT;/*!< (@ 0x00000500) Unspecified                                              */
  __IM  uint32_t  RESERVED2[14];
  __IOM CTRLAPPERI_APPROTECT_Type APPROTECT;    /*!< (@ 0x00000540) Unspecified                                                */
  __IOM CTRLAPPERI_SECUREAPPROTECT_Type SECUREAPPROTECT;/*!< (@ 0x00000548) Unspecified                                        */
  __IM  uint32_t  RESERVED3[44];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000600) Status bits for CTRL-AP peripheral                         */
} NRF_CTRLAPPERI_Type;                          /*!< Size = 1540 (0x604)                                                       */



/* =========================================================================================================================== */
/* ================                                         PAMLI_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Peripheral AHB Multi-Layer Interface 0 (PAMLI_NS)
  */

typedef struct {                                /*!< (@ 0x40007000) PAMLI_NS Structure                                         */
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  DMAMODESET;                   /*!< (@ 0x00000070) Set all bits in DMAMODE register                           */
  __IOM uint32_t  DMAMODECLEAR;                 /*!< (@ 0x00000074) Clear all bits in DMAMODE register                         */
  __IM  uint32_t  RESERVED1[739];
  __IOM uint32_t  DMAMODE;                      /*!< (@ 0x00000C04) DMA mode configuration                                     */
  __IM  uint32_t  RESERVED2[126];
  __IOM PAMLI_RAMPRI_Type RAMPRI;               /*!< (@ 0x00000E00) RAM configurable priority configuration structure          */
} NRF_PAMLI_Type;                               /*!< Size = 3644 (0xe3c)                                                       */



/* =========================================================================================================================== */
/* ================                                          SPI0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface 0 (SPI0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) SPI0_NS Structure                                          */
  __IM  uint32_t  RESERVED[66];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000108) TXD byte sent and RXD byte received                        */
  __IM  uint32_t  RESERVED1[31];
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000188) Publish configuration for event READY                      */
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI                                                 */
  __IM  uint32_t  RESERVED4;
  __IOM SPI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED7[11];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED8[681];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_SPI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         SPIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) SPIM0_NS Structure                                         */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000010) Start SPI transaction                                      */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop SPI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend SPI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume SPI transaction                                     */
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000090) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) SPI transaction has stopped                                */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000118) End of RXD buffer and TXD buffer reached                   */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) End of TXD buffer reached                                  */
  __IM  uint32_t  RESERVED8[10];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x0000014C) Transaction started                                        */
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000198) Publish configuration for event END                        */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IM  uint32_t  RESERVED13[10];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x000001CC) Publish configuration for event STARTED                    */
  __IM  uint32_t  RESERVED14[12];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED15[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED16[61];
  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
                                                                    in this register is set to STALL by hardware
                                                                    whenever a stall occurres and can be cleared
                                                                    (set to NOSTALL) by the CPU.                               */
  __IM  uint32_t  RESERVED17[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPIM                                                */
  __IM  uint32_t  RESERVED18;
  __IOM SPIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RXDDATA;                      /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXDDATA;                      /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED19;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED20[3];
  __IOM SPIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM SPIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED21[2];
  __IOM SPIM_IFTIMING_Type IFTIMING;            /*!< (@ 0x00000560) Unspecified                                                */
  __IOM uint32_t  CSNPOL;                       /*!< (@ 0x00000568) Polarity of CSN output                                     */
  __IOM uint32_t  PSELDCX;                      /*!< (@ 0x0000056C) Pin select for DCX signal                                  */
  __IOM uint32_t  DCXCNT;                       /*!< (@ 0x00000570) DCX configuration                                          */
  __IM  uint32_t  RESERVED22[19];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
                                                                    been transmitted in the case when RXD.MAXCNT
                                                                    is greater than TXD.MAXCNT                                 */
} NRF_SPIM_Type;                                /*!< Size = 1476 (0x5c4)                                                       */



/* =========================================================================================================================== */
/* ================                                         SPIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 0 (SPIS0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) SPIS0_NS Structure                                         */
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;                /*!< (@ 0x00000024) Acquire SPI semaphore                                      */
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_ACQUIRE;            /*!< (@ 0x000000A4) Subscribe configuration for task ACQUIRE                   */
  __IOM uint32_t  SUBSCRIBE_RELEASE;            /*!< (@ 0x000000A8) Subscribe configuration for task RELEASE                   */
  __IM  uint32_t  RESERVED2[22];
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) Granted transaction completed                              */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_ACQUIRED;              /*!< (@ 0x00000128) Semaphore acquired                                         */
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000184) Publish configuration for event END                        */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED7[5];
  __IOM uint32_t  PUBLISH_ACQUIRED;             /*!< (@ 0x000001A8) Publish configuration for event ACQUIRED                   */
  __IM  uint32_t  RESERVED8[21];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED9[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED10[61];
  __IM  uint32_t  SEMSTAT;                      /*!< (@ 0x00000400) Semaphore status register                                  */
  __IM  uint32_t  RESERVED11[15];
  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000440) Status from last transaction                               */
  __IM  uint32_t  RESERVED12[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI slave                                           */
  __IM  uint32_t  RESERVED13;
  __IOM SPIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED14[7];
  __IOM SPIS_RXD_Type RXD;                      /*!< (@ 0x00000534) Unspecified                                                */
  __IOM SPIS_TXD_Type TXD;                      /*!< (@ 0x00000544) Unspecified                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED16[24];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character                                        */
} NRF_SPIS_Type;                                /*!< Size = 1476 (0x5c4)                                                       */



/* =========================================================================================================================== */
/* ================                                          TWI0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Interface 0 (TWI0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) TWI0_NS Structure                                          */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IOM uint32_t  EVENTS_RXDREADY;              /*!< (@ 0x00000108) TWI RXD byte received                                      */
  __IM  uint32_t  RESERVED8[4];
  __IOM uint32_t  EVENTS_TXDSENT;               /*!< (@ 0x0000011C) TWI TXD byte sent                                          */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED11[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) TWI entered the suspended state                            */
  __IM  uint32_t  RESERVED12[14];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IOM uint32_t  PUBLISH_RXDREADY;             /*!< (@ 0x00000188) Publish configuration for event RXDREADY                   */
  __IM  uint32_t  RESERVED13[4];
  __IOM uint32_t  PUBLISH_TXDSENT;              /*!< (@ 0x0000019C) Publish configuration for event TXDSENT                    */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED15[4];
  __IOM uint32_t  PUBLISH_BB;                   /*!< (@ 0x000001B8) Publish configuration for event BB                         */
  __IM  uint32_t  RESERVED16[3];
  __IOM uint32_t  PUBLISH_SUSPENDED;            /*!< (@ 0x000001C8) Publish configuration for event SUSPENDED                  */
  __IM  uint32_t  RESERVED17[13];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED18[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED19[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED20[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWI                                                 */
  __IM  uint32_t  RESERVED21;
  __IOM TWI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED22[2];
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED23;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED24[24];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
  __IM  uint32_t  RESERVED25[668];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_TWI_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         TWIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) TWIM0_NS Structure                                         */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer access by EasyDMA                        */
  __IM  uint32_t  RESERVED9[3];
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) END of TXD buffer access by EasyDMA                        */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED11[3];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
                                                                    now suspended.                                             */
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED12[2];
  __IOM uint32_t  EVENTS_LASTRX;                /*!< (@ 0x0000015C) Byte boundary, starting to receive the last byte           */
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED13[8];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED14[2];
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED15[3];
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED16[4];
  __IOM uint32_t  PUBLISH_BB;                   /*!< (@ 0x000001B8) Publish configuration for event BB                         */
  __IM  uint32_t  RESERVED17[3];
  __IOM uint32_t  PUBLISH_SUSPENDED;            /*!< (@ 0x000001C8) Publish configuration for event SUSPENDED                  */
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IM  uint32_t  RESERVED18[2];
  __IOM uint32_t  PUBLISH_LASTRX;               /*!< (@ 0x000001DC) Publish configuration for event LASTRX                     */
  __IOM uint32_t  PUBLISH_LASTTX;               /*!< (@ 0x000001E0) Publish configuration for event LASTTX                     */
  __IM  uint32_t  RESERVED19[7];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED20[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED21[110];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
  __IM  uint32_t  RESERVED22[14];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIM                                                */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IOM TWIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED23[4];
  __IOM uint32_t  FMPLUS_THRESHOLD;             /*!< (@ 0x00000520) FREQUENCY threshold for switch from regular mode
                                                                    to to FastMode+                                            */
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED24[3];
  __IOM TWIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED25[13];
  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
} NRF_TWIM_Type;                                /*!< Size = 1420 (0x58c)                                                       */



/* =========================================================================================================================== */
/* ================                                         TWIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) TWIS0_NS Structure                                         */
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;              /*!< (@ 0x00000030) Prepare the TWI slave to respond to a write command        */
  __OM  uint32_t  TASKS_PREPARETX;              /*!< (@ 0x00000034) Prepare the TWI slave to respond to a read command         */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000094) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  SUBSCRIBE_PREPARERX;          /*!< (@ 0x000000B0) Subscribe configuration for task PREPARERX                 */
  __IOM uint32_t  SUBSCRIBE_PREPARETX;          /*!< (@ 0x000000B4) Subscribe configuration for task PREPARETX                 */
  __IM  uint32_t  RESERVED6[19];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  EVENTS_NACKTX;                /*!< (@ 0x00000134) NACK on TX                                                 */
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED9[4];
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
  __IM  uint32_t  RESERVED10[4];
  __IOM uint32_t  EVENTS_WRITE;                 /*!< (@ 0x00000164) Write command received                                     */
  __IOM uint32_t  EVENTS_READ;                  /*!< (@ 0x00000168) Read command received                                      */
  __IOM uint32_t  EVENTS_CSSTARTED;             /*!< (@ 0x0000016C) TWI started stretching the clock                           */
  __IOM uint32_t  EVENTS_CSSTOPPED;             /*!< (@ 0x00000170) TWI stopped stretching the clock                           */
  __IM  uint32_t  RESERVED11[4];
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED13[3];
  __IOM uint32_t  PUBLISH_NACKTX;               /*!< (@ 0x000001B4) Publish configuration for event NACKTX                     */
  __IOM uint32_t  PUBLISH_BB;                   /*!< (@ 0x000001B8) Publish configuration for event BB                         */
  __IM  uint32_t  RESERVED14[4];
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IM  uint32_t  RESERVED15[4];
  __IOM uint32_t  PUBLISH_WRITE;                /*!< (@ 0x000001E4) Publish configuration for event WRITE                      */
  __IOM uint32_t  PUBLISH_READ;                 /*!< (@ 0x000001E8) Publish configuration for event READ                       */
  __IOM uint32_t  PUBLISH_CSSTARTED;            /*!< (@ 0x000001EC) Publish configuration for event CSSTARTED                  */
  __IOM uint32_t  PUBLISH_CSSTOPPED;            /*!< (@ 0x000001F0) Publish configuration for event CSSTOPPED                  */
  __IM  uint32_t  RESERVED16[3];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED17[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED18[113];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004D0) Error source                                               */
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  PINSTATUS;                    /*!< (@ 0x000004D8) Returns state of signals reflecting the SDA and
                                                                    SCL line status. All fields will return
                                                                    a '0' if DEBUGENABLE is not Enabled.                       */
  __IM  uint32_t  RESERVED19[9];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIS                                                */
  __IM  uint32_t  RESERVED20;
  __IOM TWIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED21[9];
  __IOM TWIS_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IOM TWIS_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED22[13];
  __IOM uint32_t  ADDRESS[2];                   /*!< (@ 0x00000588) Description collection: TWI slave address n                */
  __IM  uint32_t  RESERVED23;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED24[2];
  __IOM uint32_t  INPUTMODE;                    /*!< (@ 0x000005A0) Input mode                                                 */
  __IOM uint32_t  DEBUGENABLE;                  /*!< (@ 0x000005A4) Enable TWIS debug features (PINSTATUS register)            */
  __IM  uint32_t  RESERVED25[6];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
} NRF_TWIS_Type;                                /*!< Size = 1476 (0x5c4)                                                       */



/* =========================================================================================================================== */
/* ================                                         UART0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter 0 (UART0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) UART0_NS Structure                                         */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART                                               */
  __IM  uint32_t  RESERVED1[24];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IOM uint32_t  SUBSCRIBE_STOPRX;             /*!< (@ 0x00000084) Subscribe configuration for task STOPRX                    */
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IOM uint32_t  SUBSCRIBE_STOPTX;             /*!< (@ 0x0000008C) Subscribe configuration for task STOPTX                    */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IM  uint32_t  RESERVED3[24];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD                                       */
  __IM  uint32_t  RESERVED4[4];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED6[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED7[14];
  __IOM uint32_t  PUBLISH_CTS;                  /*!< (@ 0x00000180) Publish configuration for event CTS                        */
  __IOM uint32_t  PUBLISH_NCTS;                 /*!< (@ 0x00000184) Publish configuration for event NCTS                       */
  __IOM uint32_t  PUBLISH_RXDRDY;               /*!< (@ 0x00000188) Publish configuration for event RXDRDY                     */
  __IM  uint32_t  RESERVED8[4];
  __IOM uint32_t  PUBLISH_TXDRDY;               /*!< (@ 0x0000019C) Publish configuration for event TXDRDY                     */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED10[7];
  __IOM uint32_t  PUBLISH_RXTO;                 /*!< (@ 0x000001C4) Publish configuration for event RXTO                       */
  __IM  uint32_t  RESERVED11[14];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED12[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED13[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source                                               */
  __IM  uint32_t  RESERVED14[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED15;
  __IOM UART_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
  __OM  uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
  __IM  uint32_t  RESERVED16;
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED17[17];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
  __IM  uint32_t  RESERVED18[675];
  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
} NRF_UART_Type;                                /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         UARTE0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA 0 (UARTE0_NS)
  */

typedef struct {                                /*!< (@ 0x40008000) UARTE0_NS Structure                                        */
  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART transaction                                   */
  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume UART transaction                                    */
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_FLUSHRX;                /*!< (@ 0x0000002C) Flush RX FIFO into RX buffer                               */
  __IM  uint32_t  RESERVED2[20];
  __IOM uint32_t  SUBSCRIBE_STARTRX;            /*!< (@ 0x00000080) Subscribe configuration for task STARTRX                   */
  __IOM uint32_t  SUBSCRIBE_STOPRX;             /*!< (@ 0x00000084) Subscribe configuration for task STOPRX                    */
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x00000088) Subscribe configuration for task STARTTX                   */
  __IOM uint32_t  SUBSCRIBE_STOPTX;             /*!< (@ 0x0000008C) Subscribe configuration for task STOPTX                    */
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  SUBSCRIBE_SUSPEND;            /*!< (@ 0x0000009C) Subscribe configuration for task SUSPEND                   */
  __IOM uint32_t  SUBSCRIBE_RESUME;             /*!< (@ 0x000000A0) Subscribe configuration for task RESUME                    */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  SUBSCRIBE_FLUSHRX;            /*!< (@ 0x000000AC) Subscribe configuration for task FLUSHRX                   */
  __IM  uint32_t  RESERVED5[20];
  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) Receive buffer is filled up                                */
  __IM  uint32_t  RESERVED7[2];
  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) Last TX byte transmitted                                   */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
  __IM  uint32_t  RESERVED8[7];
  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) UART receiver has started                                  */
  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) UART transmitter has started                               */
  __IOM uint32_t  EVENTS_RTS;                   /*!< (@ 0x00000154) RX FIFO has only room for four more bytes before
                                                                    it overflows                                               */
  __IOM uint32_t  EVENTS_TXSTOPPED;             /*!< (@ 0x00000158) Transmitter stopped                                        */
  __IM  uint32_t  RESERVED10[9];
  __IOM uint32_t  PUBLISH_CTS;                  /*!< (@ 0x00000180) Publish configuration for event CTS                        */
  __IOM uint32_t  PUBLISH_NCTS;                 /*!< (@ 0x00000184) Publish configuration for event NCTS                       */
  __IOM uint32_t  PUBLISH_RXDRDY;               /*!< (@ 0x00000188) Publish configuration for event RXDRDY                     */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x00000190) Publish configuration for event ENDRX                      */
  __IM  uint32_t  RESERVED12[2];
  __IOM uint32_t  PUBLISH_TXDRDY;               /*!< (@ 0x0000019C) Publish configuration for event TXDRDY                     */
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001A0) Publish configuration for event ENDTX                      */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x000001A4) Publish configuration for event ERROR                      */
  __IM  uint32_t  RESERVED13[7];
  __IOM uint32_t  PUBLISH_RXTO;                 /*!< (@ 0x000001C4) Publish configuration for event RXTO                       */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  PUBLISH_RXSTARTED;            /*!< (@ 0x000001CC) Publish configuration for event RXSTARTED                  */
  __IOM uint32_t  PUBLISH_TXSTARTED;            /*!< (@ 0x000001D0) Publish configuration for event TXSTARTED                  */
  __IOM uint32_t  PUBLISH_RTS;                  /*!< (@ 0x000001D4) Publish configuration for event RTS                        */
  __IOM uint32_t  PUBLISH_TXSTOPPED;            /*!< (@ 0x000001D8) Publish configuration for event TXSTOPPED                  */
  __IM  uint32_t  RESERVED15[9];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED17[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source Note : this register is read / write
                                                                    one to clear.                                              */
  __IM  uint32_t  RESERVED18[31];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
  __IM  uint32_t  RESERVED19;
  __IOM UARTE_PSEL_Type PSEL;                   /*!< (@ 0x00000508) Unspecified                                                */
  __IM  uint32_t  RESERVED20[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED21[3];
  __IOM UARTE_RXD_Type RXD;                     /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED22;
  __IOM UARTE_TXD_Type TXD;                     /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
  __IM  uint32_t  RESERVED23[7];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
} NRF_UARTE_Type;                               /*!< Size = 1392 (0x570)                                                       */



/* =========================================================================================================================== */
/* ================                                         GPIOTE0_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events 0 (GPIOTE0_S)
  */

typedef struct {                                /*!< (@ 0x5000D000) GPIOTE0_S Structure                                        */
  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IOM uint32_t  SUBSCRIBE_OUT[8];             /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task OUT[n]                                            */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  SUBSCRIBE_SET[8];             /*!< (@ 0x000000B0) Description collection: Subscribe configuration
                                                                    for task SET[n]                                            */
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  SUBSCRIBE_CLR[8];             /*!< (@ 0x000000E0) Description collection: Subscribe configuration
                                                                    for task CLR[n]                                            */
  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED4[23];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IOM uint32_t  PUBLISH_IN[8];                /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event IN[n]                                            */
  __IM  uint32_t  RESERVED5[23];
  __IOM uint32_t  PUBLISH_PORT;                 /*!< (@ 0x000001FC) Publish configuration for event PORT                       */
  __IM  uint32_t  RESERVED6[64];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  LATENCY;                      /*!< (@ 0x00000504) Latency selection for Event mode (MODE=Event)
                                                                    with rising or falling edge detection on
                                                                    the pin.                                                   */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
  __IM  uint32_t  RESERVED9[52];
  __IOM uint32_t  DEBOUNCE[8];                  /*!< (@ 0x00000600) Description collection: Debounce mode for GPIOTE
                                                                    channel n                                                  */
} NRF_GPIOTE_Type;                              /*!< Size = 1568 (0x620)                                                       */



/* =========================================================================================================================== */
/* ================                                         SAADC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter 0 (SAADC_NS)
  */

typedef struct {                                /*!< (@ 0x4000E000) SAADC_NS Structure                                         */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the ADC and prepare the result buffer in
                                                                    RAM                                                        */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Take one ADC sample, if scan is enabled all channels
                                                                    are sampled                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop the ADC and terminate any on-going conversion         */
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;        /*!< (@ 0x0000000C) Starts offset auto-calibration                             */
  __OM  uint32_t  TASKS_CALIBRATEGAIN;          /*!< (@ 0x00000010) Starts gain auto-calibration                               */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_SAMPLE;             /*!< (@ 0x00000084) Subscribe configuration for task SAMPLE                    */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000088) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_CALIBRATEOFFSET;    /*!< (@ 0x0000008C) Subscribe configuration for task CALIBRATEOFFSET           */
  __IOM uint32_t  SUBSCRIBE_CALIBRATEGAIN;      /*!< (@ 0x00000090) Subscribe configuration for task CALIBRATEGAIN             */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) The ADC has started                                        */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) The ADC has filled up the Result buffer                    */
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the mode, multiple conversions might
                                                                    be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;            /*!< (@ 0x0000010C) A result is ready to get transferred to RAM.
                                                                    Result is available in REGRESULT register                  */
  __IOM uint32_t  EVENTS_CALIBRATEDONE;         /*!< (@ 0x00000110) Calibration is complete                                    */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000114) The ADC has stopped                                        */
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];      /*!< (@ 0x00000118) Peripheral events.                                         */
  __IM  uint32_t  RESERVED2[10];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x00000180) Publish configuration for event STARTED                    */
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000184) Publish configuration for event END                        */
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x00000188) Publish configuration for event DONE                       */
  __IOM uint32_t  PUBLISH_RESULTDONE;           /*!< (@ 0x0000018C) Publish configuration for event RESULTDONE                 */
  __IOM uint32_t  PUBLISH_CALIBRATEDONE;        /*!< (@ 0x00000190) Publish configuration for event CALIBRATEDONE              */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000194) Publish configuration for event STOPPED                    */
  __IOM SAADC_PUBLISH_CH_Type PUBLISH_CH[8];    /*!< (@ 0x00000198) Publish configuration for events                           */
  __IM  uint32_t  RESERVED3[10];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Status                                                     */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable or disable ADC                                      */
  __IM  uint32_t  RESERVED7[3];
  __IOM SAADC_CH_Type CH[8];                    /*!< (@ 0x00000510) Unspecified                                                */
  __IM  uint32_t  RESERVED8[23];
  __IM  uint32_t  REGRESULT;                    /*!< (@ 0x000005EC) Last conversion result                                     */
  __IOM uint32_t  RESOLUTION;                   /*!< (@ 0x000005F0) Resolution configuration                                   */
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. OVERSAMPLE should
                                                                    not be combined with SCAN. The RESOLUTION
                                                                    is applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;                   /*!< (@ 0x000005F8) Controls normal or continuous sample rate                  */
  __IM  uint32_t  RESERVED9[12];
  __IOM SAADC_RESULT_Type RESULT;               /*!< (@ 0x0000062C) RESULT EasyDMA channel                                     */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  TESTCTRL;                     /*!< (@ 0x0000063C) Control signals used during test of ADC                    */
  __IOM uint32_t  CALOFFSET;                    /*!< (@ 0x00000640) Calibration control for offset error                       */
  __IOM uint32_t  CALGAIN;                      /*!< (@ 0x00000644) Calibration control for gain error                         */
  __IOM uint32_t  CALVREF;                      /*!< (@ 0x00000648) Calibration control for reference voltage                  */
  __IOM uint32_t  LPOP;                         /*!< (@ 0x0000064C) Enable low-power operation                                 */
} NRF_SAADC_Type;                               /*!< Size = 1616 (0x650)                                                       */



/* =========================================================================================================================== */
/* ================                                         TIMER0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0_NS)
  */

typedef struct {                                /*!< (@ 0x4000F000) TIMER0_NS Structure                                        */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start Timer                                                */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop Timer                                                 */
  __OM  uint32_t  TASKS_COUNT;                  /*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x0000000C) Clear time                                                 */
  __OM  uint32_t  TASKS_SHUTDOWN;               /*!< (@ 0x00000010) Deprecated register - Shut down timer                      */
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[10];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_COUNT;              /*!< (@ 0x00000088) Subscribe configuration for task COUNT                     */
  __IOM uint32_t  SUBSCRIBE_CLEAR;              /*!< (@ 0x0000008C) Subscribe configuration for task CLEAR                     */
  __IOM uint32_t  SUBSCRIBE_SHUTDOWN;           /*!< (@ 0x00000090) Deprecated register - Subscribe configuration
                                                                    for task SHUTDOWN                                          */
  __IM  uint32_t  RESERVED2[11];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[6];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[26];
  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED4[26];
  __IOM uint32_t  PUBLISH_COMPARE[6];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[10];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Timer mode selection                                       */
  __IOM uint32_t  BITMODE;                      /*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000510) Timer prescaler register                                   */
  __IM  uint32_t  RESERVED9[11];
  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
  __IM  uint32_t  RESERVED10[10];
  __IOM uint32_t  ONESHOTEN[6];                 /*!< (@ 0x00000580) Description collection: Enable one-shot operation
                                                                    for Capture/Compare channel n                              */
} NRF_TIMER_Type;                               /*!< Size = 1432 (0x598)                                                       */



/* =========================================================================================================================== */
/* ================                                          RTC0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Real-time counter 0 (RTC0_NS)
  */

typedef struct {                                /*!< (@ 0x40014000) RTC0_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start RTC counter                                          */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop RTC counter                                           */
  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x00000008) Clear RTC counter                                          */
  __OM  uint32_t  TASKS_TRIGOVRFLW;             /*!< (@ 0x0000000C) Set counter to 0xFFFFF0                                    */
  __IM  uint32_t  RESERVED[12];
  __OM  uint32_t  TASKS_CAPTURE[4];             /*!< (@ 0x00000040) Description collection: Capture RTC counter to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[12];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_CLEAR;              /*!< (@ 0x00000088) Subscribe configuration for task CLEAR                     */
  __IOM uint32_t  SUBSCRIBE_TRIGOVRFLW;         /*!< (@ 0x0000008C) Subscribe configuration for task TRIGOVRFLW                */
  __IM  uint32_t  RESERVED2[12];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[4];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[12];
  __IOM uint32_t  EVENTS_TICK;                  /*!< (@ 0x00000100) Event on counter increment                                 */
  __IOM uint32_t  EVENTS_OVRFLW;                /*!< (@ 0x00000104) Event on counter overflow                                  */
  __IM  uint32_t  RESERVED4[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED5[12];
  __IOM uint32_t  PUBLISH_TICK;                 /*!< (@ 0x00000180) Publish configuration for event TICK                       */
  __IOM uint32_t  PUBLISH_OVRFLW;               /*!< (@ 0x00000184) Publish configuration for event OVRFLW                     */
  __IM  uint32_t  RESERVED6[14];
  __IOM uint32_t  PUBLISH_COMPARE[4];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED7[12];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  EVTEN;                        /*!< (@ 0x00000340) Enable or disable event routing                            */
  __IOM uint32_t  EVTENSET;                     /*!< (@ 0x00000344) Enable event routing                                       */
  __IOM uint32_t  EVTENCLR;                     /*!< (@ 0x00000348) Disable event routing                                      */
  __IM  uint32_t  RESERVED10[110];
  __IM  uint32_t  COUNTER;                      /*!< (@ 0x00000504) Current counter value                                      */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12-bit prescaler for counter frequency (32768/(PRESCALER+1)).
                                                                    Must be written when RTC is stopped.                       */
  __IM  uint32_t  RESERVED11[13];
  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection: Compare register n                 */
} NRF_RTC_Type;                                 /*!< Size = 1360 (0x550)                                                       */



/* =========================================================================================================================== */
/* ================                                         DPPIC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Distributed programmable peripheral interconnect controller 0 (DPPIC_NS)
  */

typedef struct {                                /*!< (@ 0x40017000) DPPIC_NS Structure                                         */
  __OM  DPPIC_TASKS_CHG_Type TASKS_CHG[6];      /*!< (@ 0x00000000) Channel group tasks                                        */
  __IM  uint32_t  RESERVED[20];
  __IOM DPPIC_SUBSCRIBE_CHG_Type SUBSCRIBE_CHG[6];/*!< (@ 0x00000080) Subscribe configuration for tasks                        */
  __IM  uint32_t  RESERVED1[276];
  __IOM uint32_t  CHEN;                         /*!< (@ 0x00000500) Channel enable register                                    */
  __IOM uint32_t  CHENSET;                      /*!< (@ 0x00000504) Channel enable set register                                */
  __IOM uint32_t  CHENCLR;                      /*!< (@ 0x00000508) Channel enable clear register                              */
  __IM  uint32_t  RESERVED2[189];
  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n Note:
                                                                    Writes to this register are ignored if either
                                                                    SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS
                                                                    is enabled                                                 */
} NRF_DPPIC_Type;                               /*!< Size = 2072 (0x818)                                                       */



/* =========================================================================================================================== */
/* ================                                          WDT0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer 0 (WDT0_NS)
  */

typedef struct {                                /*!< (@ 0x40018000) WDT0_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the watchdog                                         */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop the watchdog timer.                                   */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_TIMEOUT;               /*!< (@ 0x00000100) Watchdog timeout                                           */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Watchdog stopped                                           */
  __IM  uint32_t  RESERVED2[30];
  __IOM uint32_t  PUBLISH_TIMEOUT;              /*!< (@ 0x00000180) Publish configuration for event TIMEOUT                    */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[6];
  __IOM uint32_t  NMIENSET;                     /*!< (@ 0x00000324) Enable interrupt                                           */
  __IOM uint32_t  NMIENCLR;                     /*!< (@ 0x00000328) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[53];
  __IM  uint32_t  RUNSTATUS;                    /*!< (@ 0x00000400) Run status                                                 */
  __IM  uint32_t  REQSTATUS;                    /*!< (@ 0x00000404) Request status                                             */
  __IM  uint32_t  RCNT;                         /*!< (@ 0x00000408) Reload count                                               */
  __IM  uint32_t  RESERVED6[62];
  __IOM uint32_t  CRV;                          /*!< (@ 0x00000504) Counter reload value                                       */
  __IOM uint32_t  RREN;                         /*!< (@ 0x00000508) Enable register for reload request registers               */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000050C) Configuration register                                     */
  __IOM uint32_t  RRKEY;                        /*!< (@ 0x00000510) Reload request key                                         */
  __IOM uint32_t  TSKEY;                        /*!< (@ 0x00000514) Task stop key                                              */
  __IM  uint32_t  RESERVED7[2];
  __OM  uint32_t  TSEN;                         /*!< (@ 0x00000520) Task Stop Enable                                           */
  __IM  uint32_t  RESERVED8[55];
  __OM  uint32_t  RR[8];                        /*!< (@ 0x00000600) Description collection: Reload request n                   */
} NRF_WDT_Type;                                 /*!< Size = 1568 (0x620)                                                       */



/* =========================================================================================================================== */
/* ================                                          COMP_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Comparator 0 (COMP_NS)
  */

typedef struct {                                /*!< (@ 0x4001A000) COMP_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_SAMPLE;             /*!< (@ 0x00000088) Subscribe configuration for task SAMPLE                    */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) COMP is ready and output is valid                          */
  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000180) Publish configuration for event READY                      */
  __IOM uint32_t  PUBLISH_DOWN;                 /*!< (@ 0x00000184) Publish configuration for event DOWN                       */
  __IOM uint32_t  PUBLISH_UP;                   /*!< (@ 0x00000188) Publish configuration for event UP                         */
  __IOM uint32_t  PUBLISH_CROSS;                /*!< (@ 0x0000018C) Publish configuration for event CROSS                      */
  __IM  uint32_t  RESERVED3[28];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
  __IM  uint32_t  BGREADY;                      /*!< (@ 0x00000404) COMP module is ready                                       */
  __IM  uint32_t  RESERVED6[62];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) COMP enable                                                */
  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Pin select                                                 */
  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference source select for single-ended mode              */
  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
  __IM  uint32_t  RESERVED7[8];
  __IOM uint32_t  TH;                           /*!< (@ 0x00000530) Threshold configuration for hysteresis unit                */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000534) Mode configuration                                         */
  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
  __IOM uint32_t  ISOURCE;                      /*!< (@ 0x0000053C) Current source select on analog input                      */
  __IOM uint32_t  REFTRIM;                      /*!< (@ 0x00000540) Trim internal band gap reference, copied from
                                                                    FICR (COMPREFTRIM register) at reset                       */
  __IOM uint32_t  ATECOMP;                      /*!< (@ 0x00000544) Analog test bus control for comparator                     */
} NRF_COMP_Type;                                /*!< Size = 1352 (0x548)                                                       */



/* =========================================================================================================================== */
/* ================                                         LPCOMP_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power comparator 0 (LPCOMP_NS)
  */

typedef struct {                                /*!< (@ 0x4001A000) LPCOMP_NS Structure                                        */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_SAMPLE;             /*!< (@ 0x00000088) Subscribe configuration for task SAMPLE                    */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) LPCOMP is ready and output is valid                        */
  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000180) Publish configuration for event READY                      */
  __IOM uint32_t  PUBLISH_DOWN;                 /*!< (@ 0x00000184) Publish configuration for event DOWN                       */
  __IOM uint32_t  PUBLISH_UP;                   /*!< (@ 0x00000188) Publish configuration for event UP                         */
  __IOM uint32_t  PUBLISH_CROSS;                /*!< (@ 0x0000018C) Publish configuration for event CROSS                      */
  __IM  uint32_t  RESERVED3[28];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable LPCOMP                                              */
  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Input pin select                                           */
  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference select                                           */
  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
  __IM  uint32_t  RESERVED7[4];
  __IOM uint32_t  ANADETECT;                    /*!< (@ 0x00000520) Analog detect configuration                                */
  __IM  uint32_t  RESERVED8[5];
  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
} NRF_LPCOMP_Type;                              /*!< Size = 1340 (0x53c)                                                       */



/* =========================================================================================================================== */
/* ================                                          EGU0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit 0 (EGU0_NS)
  */

typedef struct {                                /*!< (@ 0x4001B000) EGU0_NS Structure                                          */
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_TRIGGER[16];        /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task TRIGGER[n]                                        */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_TRIGGERED[16];        /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event TRIGGERED[n]                                     */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
} NRF_EGU_Type;                                 /*!< Size = 780 (0x30c)                                                        */



/* =========================================================================================================================== */
/* ================                                          PWM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse width modulation unit 0 (PWM0_NS)
  */

typedef struct {                                /*!< (@ 0x40021000) PWM0_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts PWM pulse generation with the last loaded
                                                                    values                                                     */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
                                                                    the end of current PWM period, and stops
                                                                    sequence playback                                          */
  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
                                                                    on all enabled channels from sequence n,
                                                                    and starts playing that sequence at the
                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
                                                                    Causes PWM generation to start if not running.
                                                                    Triggering a SEQSTART[n] task while a sequence
                                                                    is already playing back will gracefully
                                                                    (i.e. glitch-free) abort that sequence at
                                                                    the earliest opportunity and start sequence
                                                                    n.                                                         */
  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
                                                                    all enabled channels if DECODER.MODE=NextStep.
                                                                    Does not cause PWM generation to start if
                                                                    not running.                                               */
  __OM  uint32_t  TASKS_SEQABORT;               /*!< (@ 0x00000014) (Gracefully) aborts the playback of the current
                                                                    sequence or the current end delay                          */
  __IM  uint32_t  RESERVED[26];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_SEQSTART[2];        /*!< (@ 0x00000088) Description collection: Subscribe configuration
                                                                    for task SEQSTART[n]                                       */
  __IOM uint32_t  SUBSCRIBE_NEXTSTEP;           /*!< (@ 0x00000090) Subscribe configuration for task NEXTSTEP                  */
  __IOM uint32_t  SUBSCRIBE_SEQABORT;           /*!< (@ 0x00000094) Subscribe configuration for task SEQABORT                  */
  __IM  uint32_t  RESERVED1[26];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) Response to START task, emitted when the PWM
                                                                    pulse generation starts                                    */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
                                                                    are no longer generated                                    */
  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
                                                                    on sequence n                                              */
  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
                                                                    sequence n, when last value from RAM has
                                                                    been applied to wave counter                               */
  __IOM uint32_t  EVENTS_PWMPERIODEND;          /*!< (@ 0x00000118) Emitted at the end of each PWM period                      */
  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
                                                                    of times defined in LOOP.CNT                               */
  __IOM uint32_t  EVENTS_RAMUNDERFLOW;          /*!< (@ 0x00000120) Emitted when retrieving from RAM does not complete
                                                                    in time for the PWM module                                 */
  __IOM uint32_t  EVENTS_DMAREADY[2];           /*!< (@ 0x00000124) Description collection: Emitted when EasyDMA
                                                                    has retrieved the .PTR and .CNT registers
                                                                    for sequence n (they can be prepared for
                                                                    the next sequence)                                         */
  __IOM uint32_t  EVENTS_DMAEND[2];             /*!< (@ 0x0000012C) Description collection: Emitted when EasyDMA
                                                                    has completed retrieving the values of sequence
                                                                    n from RAM buffer                                          */
  __IM  uint32_t  RESERVED2[19];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x00000180) Publish configuration for event STARTED                    */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IOM uint32_t  PUBLISH_SEQSTARTED[2];        /*!< (@ 0x00000188) Description collection: Publish configuration
                                                                    for event SEQSTARTED[n]                                    */
  __IOM uint32_t  PUBLISH_SEQEND[2];            /*!< (@ 0x00000190) Description collection: Publish configuration
                                                                    for event SEQEND[n]                                        */
  __IOM uint32_t  PUBLISH_PWMPERIODEND;         /*!< (@ 0x00000198) Publish configuration for event PWMPERIODEND               */
  __IOM uint32_t  PUBLISH_LOOPSDONE;            /*!< (@ 0x0000019C) Publish configuration for event LOOPSDONE                  */
  __IOM uint32_t  PUBLISH_RAMUNDERFLOW;         /*!< (@ 0x000001A0) Publish configuration for event RAMUNDERFLOW               */
  __IOM uint32_t  PUBLISH_DMAREADY[2];          /*!< (@ 0x000001A4) Description collection: Publish configuration
                                                                    for event DMAREADY[n]                                      */
  __IOM uint32_t  PUBLISH_DMAEND[2];            /*!< (@ 0x000001AC) Description collection: Publish configuration
                                                                    for event DMAEND[n]                                        */
  __IM  uint32_t  RESERVED3[19];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PWM module enable register                                 */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Selects operating mode of the wave counter                 */
  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
                                                                    counts                                                     */
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x0000050C) Configuration for PWM_CLK                                  */
  __IOM uint32_t  DECODER;                      /*!< (@ 0x00000510) Configuration of the decoder                               */
  __IOM uint32_t  LOOP;                         /*!< (@ 0x00000514) Number of playbacks of a loop                              */
  __IM  uint32_t  RESERVED6[2];
  __IOM PWM_SEQ_Type SEQ[2];                    /*!< (@ 0x00000520) Unspecified                                                */
  __IOM PWM_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
} NRF_PWM_Type;                                 /*!< Size = 1392 (0x570)                                                       */



/* =========================================================================================================================== */
/* ================                                          PDM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Density Modulation (Digital Microphone) Interface 0 (PDM0_NS)
  */

typedef struct {                                /*!< (@ 0x40026000) PDM0_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous PDM transfer                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PDM transfer                                         */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) PDM transfer has started                                   */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) PDM transfer has finished                                  */
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
                                                                    by SAMPLE.MAXCNT (or the last sample after
                                                                    a STOP task has been received) to Data RAM                 */
  __IOM uint32_t  EVENTS_OVERRUN;               /*!< (@ 0x0000010C) PDM samples lost due to DMA destination not available      */
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x00000180) Publish configuration for event STARTED                    */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000184) Publish configuration for event STOPPED                    */
  __IOM uint32_t  PUBLISH_END;                  /*!< (@ 0x00000188) Publish configuration for event END                        */
  __IOM uint32_t  PUBLISH_OVERRUN;              /*!< (@ 0x0000018C) Publish configuration for event OVERRUN                    */
  __IM  uint32_t  RESERVED3[92];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PDM module enable register                                 */
  __IOM uint32_t  PDMCLKCTRL;                   /*!< (@ 0x00000504) PDM clock generator control                                */
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
                                                                    signals                                                    */
  __IOM uint32_t  FDBYPASS;                     /*!< (@ 0x0000050C) Bypass the frequency doubler in the PDM clock
                                                                    generation                                                 */
  __IM  uint32_t  RXDLDATA;                     /*!< (@ 0x00000510) Left sample from filter output                             */
  __IM  uint32_t  RXDRDATA;                     /*!< (@ 0x00000514) Right sample from filter output                            */
  __IOM uint32_t  GAINL;                        /*!< (@ 0x00000518) Left output gain adjustment                                */
  __IOM uint32_t  GAINR;                        /*!< (@ 0x0000051C) Right output gain adjustment                               */
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
  __IM  uint32_t  RESERVED5;
  __IOM PDM_FILTER_Type FILTER;                 /*!< (@ 0x00000528) Unspecified                                                */
  __IOM uint32_t  PHASE;                        /*!< (@ 0x0000053C) Selection of delay on the clock line (to avoid
                                                                    potential setup&amp;hold timing violation
                                                                    on input data)                                             */
  __IOM PDM_PSEL_Type PSEL;                     /*!< (@ 0x00000540) Unspecified                                                */
  __IOM uint32_t  RAMCONFIG;                    /*!< (@ 0x00000548) Trim value for internal PDM RAM                            */
  __IOM uint32_t  MCLKCONFIG;                   /*!< (@ 0x0000054C) Master clock generator configuration                       */
  __IM  uint32_t  RESERVED6[4];
  __IOM PDM_SAMPLE_Type SAMPLE;                 /*!< (@ 0x00000560) Unspecified                                                */
} NRF_PDM_Type;                                 /*!< Size = 1388 (0x56c)                                                       */



/* =========================================================================================================================== */
/* ================                                          I2S0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter-IC Sound 0 (I2S0_NS)
  */

typedef struct {                                /*!< (@ 0x40028000) I2S0_NS Structure                                          */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
                                                                    generator when this is enabled                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer and MCK generator. Triggering
                                                                    this task will cause the event STOPPED to
                                                                    be generated.                                              */
  __IM  uint32_t  RESERVED[10];
  __OM  uint32_t  TASKS_DMA_START_TX;           /*!< (@ 0x00000030) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_START_TX */
  __OM  uint32_t  TASKS_DMA_START_RX;           /*!< (@ 0x00000034) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_START_RX */
  __OM  uint32_t  TASKS_DMA_STOP_TX;            /*!< (@ 0x00000038) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_STOP_TX  */
  __OM  uint32_t  TASKS_DMA_STOP_RX;            /*!< (@ 0x0000003C) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_TASK_TRIG_STOP_RX  */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IM  uint32_t  RESERVED2[10];
  __IOM uint32_t  SUBSCRIBE_DMA_START_TX;       /*!< (@ 0x000000B0) Subscribe configuration for task DMA_START_TX              */
  __IOM uint32_t  SUBSCRIBE_DMA_START_RX;       /*!< (@ 0x000000B4) Subscribe configuration for task DMA_START_RX              */
  __IOM uint32_t  SUBSCRIBE_DMA_STOP_TX;        /*!< (@ 0x000000B8) Subscribe configuration for task DMA_STOP_TX               */
  __IOM uint32_t  SUBSCRIBE_DMA_STOP_RX;        /*!< (@ 0x000000BC) Subscribe configuration for task DMA_STOP_RX               */
  __IM  uint32_t  RESERVED3[16];
  __IOM uint32_t  EVENTS_DMA_END_TX;            /*!< (@ 0x00000100) Equivalent to eventDmaEndTx                                */
  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and RX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words received on
                                                                    the SDIN pin. Equivalent to eventDmaReadyRx.               */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000108) I2S transfer stopped. There are no requirements
                                                                    to how graceful the I2S module shall be
                                                                    stopped. The reason for this is that we
                                                                    are talking about streaming audio data here,
                                                                    and thus loosing some data is not critical.
                                                                    Graceful stopping of stream can easily be
                                                                    done in FW. Equivalent to eventStopped                     */
  __IOM uint32_t  EVENTS_ERROR_TX;              /*!< (@ 0x0000010C) DMA read from memory failed. Equivalent to eventUnderflowTx */
  __IOM uint32_t  EVENTS_ERROR_RX;              /*!< (@ 0x00000110) DMA write to memory failed. Equivalent to eventOverflowRx  */
  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and TX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are sent
                                                                    on the SDOUT pin. Equivalent to eventDmaReadyTx.           */
  __IOM uint32_t  EVENTS_DMA_END_RX;            /*!< (@ 0x00000118) DMA write to memory failed. Equivalent to eventDmaEndRx    */
  __IOM uint32_t  EVENTS_FRAMESTART;            /*!< (@ 0x0000011C) Frame start event, generated on the active edge
                                                                    of LRCK                                                    */
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  PUBLISH_DMA_END_TX;           /*!< (@ 0x00000180) Publish configuration for event DMA_END_TX                 */
  __IOM uint32_t  PUBLISH_RXPTRUPD;             /*!< (@ 0x00000184) Publish configuration for event RXPTRUPD                   */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000188) Publish configuration for event STOPPED                    */
  __IOM uint32_t  PUBLISH_ERROR_TX;             /*!< (@ 0x0000018C) Publish configuration for event ERROR_TX                   */
  __IOM uint32_t  PUBLISH_ERROR_RX;             /*!< (@ 0x00000190) Publish configuration for event ERROR_RX                   */
  __IOM uint32_t  PUBLISH_TXPTRUPD;             /*!< (@ 0x00000194) Publish configuration for event TXPTRUPD                   */
  __IOM uint32_t  PUBLISH_DMA_END_RX;           /*!< (@ 0x00000198) Publish configuration for event DMA_END_RX                 */
  __IOM uint32_t  PUBLISH_FRAMESTART;           /*!< (@ 0x0000019C) Publish configuration for event FRAMESTART                 */
  __IM  uint32_t  RESERVED5[88];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable I2S module                                          */
  __IOM I2S_CONFIG_Type CONFIG;                 /*!< (@ 0x00000504) Unspecified                                                */
  __IM  uint32_t  RESERVED7[2];
  __IOM I2S_RXD_Type RXD;                       /*!< (@ 0x00000538) Unspecified                                                */
  __IM  uint32_t  RESERVED8;
  __IOM I2S_TXD_Type TXD;                       /*!< (@ 0x00000540) Unspecified                                                */
  __IM  uint32_t  RESERVED9[3];
  __IOM I2S_RXTXD_Type RXTXD;                   /*!< (@ 0x00000550) Unspecified                                                */
  __IM  uint32_t  RESERVED10[2];
  __IOM I2S_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
  __IM  uint32_t  RESERVED11[99];
  __IOM uint32_t  DMA_ENABLE_RX;                /*!< (@ 0x00000700) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_ENABLE_RX          */
  __IOM uint32_t  DMA_ENABLE_TX;                /*!< (@ 0x00000704) Equivalent to ID_DMA_CHANNEL_PERIPHERAL_ENABLE_TX          */
} NRF_I2S_Type;                                 /*!< Size = 1800 (0x708)                                                       */



/* =========================================================================================================================== */
/* ================                                          IPC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Interprocessor communication 0 (IPC_NS)
  */

typedef struct {                                /*!< (@ 0x4002A000) IPC_NS Structure                                           */
  __OM  uint32_t  TASKS_SEND[16];               /*!< (@ 0x00000000) Description collection: Trigger events on IPC
                                                                    channel enabled in SEND_CNF[n]                             */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_SEND[16];           /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task SEND[n]                                           */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_RECEIVE[16];           /*!< (@ 0x00000100) Description collection: Event received on one
                                                                    or more of the enabled IPC channels in RECEIVE_CNF[n]      */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_RECEIVE[16];          /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event RECEIVE[n]                                       */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  INTPEND;                      /*!< (@ 0x0000030C) Pending interrupts                                         */
  __IM  uint32_t  RESERVED4[128];
  __IOM uint32_t  SEND_CNF[16];                 /*!< (@ 0x00000510) Description collection: Send event configuration
                                                                    for TASKS_SEND[n]                                          */
  __IM  uint32_t  RESERVED5[16];
  __IOM uint32_t  RECEIVE_CNF[16];              /*!< (@ 0x00000590) Description collection: Receive event configuration
                                                                    for EVENTS_RECEIVE[n]                                      */
  __IM  uint32_t  RESERVED6[16];
  __IOM uint32_t  GPMEM[2];                     /*!< (@ 0x00000610) Description collection: General purpose memory             */
} NRF_IPC_Type;                                 /*!< Size = 1560 (0x618)                                                       */



/* =========================================================================================================================== */
/* ================                                          QSPI_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief External flash interface 0 (QSPI_NS)
  */

typedef struct {                                /*!< (@ 0x4002B000) QSPI_NS Structure                                          */
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate QSPI interface                                    */
  __OM  uint32_t  TASKS_READSTART;              /*!< (@ 0x00000004) Start transfer from external flash memory to
                                                                    internal RAM                                               */
  __OM  uint32_t  TASKS_WRITESTART;             /*!< (@ 0x00000008) Start transfer from internal RAM to external
                                                                    flash memory                                               */
  __OM  uint32_t  TASKS_ERASESTART;             /*!< (@ 0x0000000C) Start external flash memory erase operation                */
  __OM  uint32_t  TASKS_DEACTIVATE;             /*!< (@ 0x00000010) Deactivate QSPI interface                                  */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_ACTIVATE;           /*!< (@ 0x00000080) Subscribe configuration for task ACTIVATE                  */
  __IOM uint32_t  SUBSCRIBE_READSTART;          /*!< (@ 0x00000084) Subscribe configuration for task READSTART                 */
  __IOM uint32_t  SUBSCRIBE_WRITESTART;         /*!< (@ 0x00000088) Subscribe configuration for task WRITESTART                */
  __IOM uint32_t  SUBSCRIBE_ERASESTART;         /*!< (@ 0x0000008C) Subscribe configuration for task ERASESTART                */
  __IOM uint32_t  SUBSCRIBE_DEACTIVATE;         /*!< (@ 0x00000090) Subscribe configuration for task DEACTIVATE                */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) QSPI peripheral is ready. This event will be
                                                                    generated as a response to all QSPI tasks
                                                                    except DEACTIVATE.                                         */
  __IM  uint32_t  RESERVED2[31];
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000180) Publish configuration for event READY                      */
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable QSPI peripheral and acquire the pins selected
                                                                    in PSELn registers                                         */
  __IOM QSPI_READ_Type READ;                    /*!< (@ 0x00000504) Unspecified                                                */
  __IOM QSPI_WRITE_Type WRITE;                  /*!< (@ 0x00000510) Unspecified                                                */
  __IOM QSPI_ERASE_Type ERASE;                  /*!< (@ 0x0000051C) Unspecified                                                */
  __IOM QSPI_PSEL_Type PSEL;                    /*!< (@ 0x00000524) Unspecified                                                */
  __IOM uint32_t  XIPOFFSET;                    /*!< (@ 0x00000540) Address offset into the external memory for Execute
                                                                    in Place operation.                                        */
  __IOM uint32_t  IFCONFIG0;                    /*!< (@ 0x00000544) Interface configuration. SPI MEM CTRL Default
                                                                    Memory reg.                                                */
  __IOM uint32_t  FIFOTH;                       /*!< (@ 0x00000548) When writing to the IFCONFIG1 register the values
                                                                    for the FIFO thresholds are taken from this
                                                                    register. The DISABLE field can be set to
                                                                    ignore this register.                                      */
  __IOM uint32_t  XIPEN;                        /*!< (@ 0x0000054C) Enable Execute in Place operation.                         */
  __IM  uint32_t  RESERVED5[4];
  __IOM QSPI_XIP_ENC_Type XIP_ENC;              /*!< (@ 0x00000560) Unspecified                                                */
  __IOM QSPI_DMA_ENC_Type DMA_ENC;              /*!< (@ 0x00000580) Unspecified                                                */
  __IM  uint32_t  RESERVED6[24];
  __IOM uint32_t  IFCONFIG1;                    /*!< (@ 0x00000600) Interface configuration. SPI MEM CTRL Control
                                                                    reg.                                                       */
  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000604) Status register. SPI MEM CTRL Status reg.                  */
  __IOM uint32_t  ACCESSREQ0;                   /*!< (@ 0x00000608) Access request, word 0. SPI MEM CTRL Access Request
                                                                    reg. 0.                                                    */
  __IOM uint32_t  ACCESSREQ1;                   /*!< (@ 0x0000060C) Access request, word 1. SPI MEM CTRL Access Request
                                                                    reg. 1.                                                    */
  __IOM uint32_t  ACCESSREQ2;                   /*!< (@ 0x00000610) Access request, word 2. SPI MEM CTRL Access Request
                                                                    reg. 2.                                                    */
  __IOM uint32_t  DPMDUR;                       /*!< (@ 0x00000614) Set the duration required to enter/exit deep
                                                                    power-down mode (DPM). SPI MEM CTRL Duration
                                                                    DPM reg.                                                   */
  __IOM uint32_t  DATARW;                       /*!< (@ 0x00000618) Read data when read, write data when written.
                                                                    SPI MEM CTRL Read/Write Data reg.                          */
  __IM  uint32_t  FIFOSTAT;                     /*!< (@ 0x0000061C) The number of items in Read and Write FIFOs.
                                                                    SPI MEM CTRL FIFOs Status reg.                             */
  __IOM uint32_t  DEFMEM;                       /*!< (@ 0x00000620) Default memory register. SPI MEM Default memory
                                                                    register. Fields and content equivalent
                                                                    to IFCONFIG0.                                              */
  __IOM uint32_t  ADDRCONF;                     /*!< (@ 0x00000624) Extended address configuration. SPI MEM CTRL
                                                                    Extended Addressing Mode reg.                              */
  __IOM uint32_t  MEMSPEC;                      /*!< (@ 0x00000628) Byte specification: 1 byte manufacture ID, 1
                                                                    byte memory type, 1 byte density. SPI MEM
                                                                    CTRL Memory Specification reg.                             */
  __IOM uint32_t  IRQMSK;                       /*!< (@ 0x0000062C) Interrupts enable disable mask. SPI MEM CTRL
                                                                    Interrupt Mask reg.                                        */
  __IOM uint32_t  IRQREQ;                       /*!< (@ 0x00000630) Interrupt request register (reason for triggering
                                                                    interrupt signal). SPI MEM CTRL Interrupt
                                                                    Request reg.                                               */
  __IOM uint32_t  CINSTRCONF;                   /*!< (@ 0x00000634) Custom instruction configuration register. SPI
                                                                    MEM CTRL Custom Instruction Setup reg.                     */
  __IOM uint32_t  CINSTRDAT0;                   /*!< (@ 0x00000638) Custom instruction data register 0. SPI MEM CTRL
                                                                    Custom Instruction Data reg. 0.                            */
  __IOM uint32_t  CINSTRDAT1;                   /*!< (@ 0x0000063C) Custom instruction data register 1. SPI MEM CTRL
                                                                    Custom Instruction Data reg. 1.                            */
  __IOM uint32_t  IFTIMING;                     /*!< (@ 0x00000640) SPI interface timing. SPI MEM CTRL Read Dummy
                                                                    Cycles reg.                                                */
} NRF_QSPI_Type;                                /*!< Size = 1604 (0x644)                                                       */



/* =========================================================================================================================== */
/* ================                                          NFCT_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief NFC-A compatible radio 0 (NFCT_NS)
  */

typedef struct {                                /*!< (@ 0x4002D000) NFCT_NS Structure                                          */
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
                                                                    frames, change state to activated                          */
  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000004) Disable NFCT peripheral                                    */
  __OM  uint32_t  TASKS_SENSE;                  /*!< (@ 0x00000008) Enable NFC sense field mode, change state to
                                                                    sense mode                                                 */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
                                                                    state to transmit                                          */
  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x00000010) Stops an issued transmission of a frame                    */
  __OM  uint32_t  TASKS_START_ROSCCAL;          /*!< (@ 0x00000014) Starts calibration of ring oscillator                      */
  __OM  uint32_t  TASKS_FREQMEASURE;            /*!< (@ 0x00000018) Measures the 13.56 MHz clock frequency                     */
  __OM  uint32_t  TASKS_ENABLERXDATA;           /*!< (@ 0x0000001C) Initializes the EasyDMA for receive.                       */
  __OM  uint32_t  TASKS_DISABLERXDATA;          /*!< (@ 0x00000020) Ends current EasyDMA transfer and stops waiting
                                                                    for start of frame (SoF)                                   */
  __OM  uint32_t  TASKS_GOIDLE;                 /*!< (@ 0x00000024) Force state machine to IDLE state                          */
  __OM  uint32_t  TASKS_GOSLEEP;                /*!< (@ 0x00000028) Force state machine to SLEEP_A state                       */
  __IM  uint32_t  RESERVED[21];
  __IOM uint32_t  SUBSCRIBE_ACTIVATE;           /*!< (@ 0x00000080) Subscribe configuration for task ACTIVATE                  */
  __IOM uint32_t  SUBSCRIBE_DISABLE;            /*!< (@ 0x00000084) Subscribe configuration for task DISABLE                   */
  __IOM uint32_t  SUBSCRIBE_SENSE;              /*!< (@ 0x00000088) Subscribe configuration for task SENSE                     */
  __IOM uint32_t  SUBSCRIBE_STARTTX;            /*!< (@ 0x0000008C) Subscribe configuration for task STARTTX                   */
  __IOM uint32_t  SUBSCRIBE_STOPTX;             /*!< (@ 0x00000090) Subscribe configuration for task STOPTX                    */
  __IOM uint32_t  SUBSCRIBE_START_ROSCCAL;      /*!< (@ 0x00000094) Subscribe configuration for task START_ROSCCAL             */
  __IOM uint32_t  SUBSCRIBE_FREQMEASURE;        /*!< (@ 0x00000098) Subscribe configuration for task FREQMEASURE               */
  __IOM uint32_t  SUBSCRIBE_ENABLERXDATA;       /*!< (@ 0x0000009C) Subscribe configuration for task ENABLERXDATA              */
  __IOM uint32_t  SUBSCRIBE_DISABLERXDATA;      /*!< (@ 0x000000A0) Subscribe configuration for task DISABLERXDATA             */
  __IOM uint32_t  SUBSCRIBE_GOIDLE;             /*!< (@ 0x000000A4) Subscribe configuration for task GOIDLE                    */
  __IOM uint32_t  SUBSCRIBE_GOSLEEP;            /*!< (@ 0x000000A8) Subscribe configuration for task GOSLEEP                   */
  __IM  uint32_t  RESERVED1[21];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
                                                                    frames                                                     */
  __IOM uint32_t  EVENTS_FIELDDETECTED;         /*!< (@ 0x00000104) Remote NFC field detected                                  */
  __IOM uint32_t  EVENTS_FIELDLOST;             /*!< (@ 0x00000108) Remote NFC field lost                                      */
  __IOM uint32_t  EVENTS_TXFRAMESTART;          /*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_TXFRAMEEND;            /*!< (@ 0x00000110) Marks the end of the last transmitted on-air
                                                                    symbol of a frame data bit on the last positive
                                                                    edge ckTxNfc with nfcTransmit = 1                          */
  __IOM uint32_t  EVENTS_RXFRAMESTART;          /*!< (@ 0x00000114) Marks the end of the first symbol of a received
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_RXFRAMEEND;            /*!< (@ 0x00000118) Received data has been checked (CRC, parity)
                                                                    and transferred to RAM, and EasyDMA has
                                                                    ended accessing the RX buffer                              */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
                                                                    contains details on the source of the error.               */
  __IOM uint32_t  EVENTS_FREQMEASUREDONE;       /*!< (@ 0x00000120) Done with one frequency measurement, result available
                                                                    in the MEASUREDFREQ register. This event
                                                                    will fire several times during calibration.                */
  __IOM uint32_t  EVENTS_CALCOMPLETE;           /*!< (@ 0x00000124) NFC ring oscillator calibration complete.                  */
  __IOM uint32_t  EVENTS_RXERROR;               /*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
                                                                    register contains details on the source
                                                                    of the error.                                              */
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
                                                                    in Data RAM full.                                          */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
                                                                    has ended accessing the TX buffer                          */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;     /*!< (@ 0x00000138) Auto collision resolution process has started
                                                                    Event generated when ALL_REQ or SENS_REQ
                                                                    has been received while in IDLE state                      */
  __IOM uint32_t  EVENTS_AUTOCOLRES1;           /*!< (@ 0x0000013C) Auto collision resolution cascade level 1 succeeded        */
  __IOM uint32_t  EVENTS_AUTOCOLRES2;           /*!< (@ 0x00000140) Auto collision resolution cascade level 2 succeeded        */
  __IOM uint32_t  EVENTS_AUTOCOLRES3;           /*!< (@ 0x00000144) Auto collision resolution cascade level 3 succeeded        */
  __IOM uint32_t  EVENTS_COLLISION;             /*!< (@ 0x00000148) NFC auto collision resolution error reported.
                                                                    The AUTOCOLRESSTATUS register contains details
                                                                    on the source of the error.                                */
  __IOM uint32_t  EVENTS_SELECTED;              /*!< (@ 0x0000014C) NFC auto collision resolution successfully completed       */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000150) EasyDMA is ready to receive or send frames.                */
  __IM  uint32_t  RESERVED3[11];
  __IOM uint32_t  PUBLISH_READY;                /*!< (@ 0x00000180) Publish configuration for event READY                      */
  __IOM uint32_t  PUBLISH_FIELDDETECTED;        /*!< (@ 0x00000184) Publish configuration for event FIELDDETECTED              */
  __IOM uint32_t  PUBLISH_FIELDLOST;            /*!< (@ 0x00000188) Publish configuration for event FIELDLOST                  */
  __IOM uint32_t  PUBLISH_TXFRAMESTART;         /*!< (@ 0x0000018C) Publish configuration for event TXFRAMESTART               */
  __IOM uint32_t  PUBLISH_TXFRAMEEND;           /*!< (@ 0x00000190) Publish configuration for event TXFRAMEEND                 */
  __IOM uint32_t  PUBLISH_RXFRAMESTART;         /*!< (@ 0x00000194) Publish configuration for event RXFRAMESTART               */
  __IOM uint32_t  PUBLISH_RXFRAMEEND;           /*!< (@ 0x00000198) Publish configuration for event RXFRAMEEND                 */
  __IOM uint32_t  PUBLISH_ERROR;                /*!< (@ 0x0000019C) Publish configuration for event ERROR                      */
  __IOM uint32_t  PUBLISH_FREQMEASUREDONE;      /*!< (@ 0x000001A0) Publish configuration for event FREQMEASUREDONE            */
  __IOM uint32_t  PUBLISH_CALCOMPLETE;          /*!< (@ 0x000001A4) Publish configuration for event CALCOMPLETE                */
  __IOM uint32_t  PUBLISH_RXERROR;              /*!< (@ 0x000001A8) Publish configuration for event RXERROR                    */
  __IOM uint32_t  PUBLISH_ENDRX;                /*!< (@ 0x000001AC) Publish configuration for event ENDRX                      */
  __IOM uint32_t  PUBLISH_ENDTX;                /*!< (@ 0x000001B0) Publish configuration for event ENDTX                      */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  PUBLISH_AUTOCOLRESSTARTED;    /*!< (@ 0x000001B8) Publish configuration for event AUTOCOLRESSTARTED          */
  __IOM uint32_t  PUBLISH_AUTOCOLRES1;          /*!< (@ 0x000001BC) Publish configuration for event AUTOCOLRES1                */
  __IOM uint32_t  PUBLISH_AUTOCOLRES2;          /*!< (@ 0x000001C0) Publish configuration for event AUTOCOLRES2                */
  __IOM uint32_t  PUBLISH_AUTOCOLRES3;          /*!< (@ 0x000001C4) Publish configuration for event AUTOCOLRES3                */
  __IOM uint32_t  PUBLISH_COLLISION;            /*!< (@ 0x000001C8) Publish configuration for event COLLISION                  */
  __IOM uint32_t  PUBLISH_SELECTED;             /*!< (@ 0x000001CC) Publish configuration for event SELECTED                   */
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x000001D0) Publish configuration for event STARTED                    */
  __IM  uint32_t  RESERVED5[11];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED7[61];
  __IM  uint32_t  PWRUPSENSE;                   /*!< (@ 0x00000400) Tells if the NFCT peripheral is in SENSE mode              */
  __IOM uint32_t  ERRORSTATUS;                  /*!< (@ 0x00000404) NFC Error Status register                                  */
  __IOM uint32_t  AUTOCOLRESSTATUS;             /*!< (@ 0x00000408) NFC Auto collision resolution Error Status register        */
  __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;      /*!< (@ 0x0000040C) Unspecified                                                */
  __IM  uint32_t  NFCTAGSTATE;                  /*!< (@ 0x00000410) NfcTag state register                                      */
  __IM  uint32_t  RESERVED8[3];
  __IM  uint32_t  SLEEPSTATE;                   /*!< (@ 0x00000420) Sleep state during automatic collision resolution          */
  __IM  uint32_t  BYTESWRITTENTORAM;            /*!< (@ 0x00000424) Number of bytes written to RAM                             */
  __IM  uint32_t  NFCFRAMINGCORESTATE;          /*!< (@ 0x00000428) NFC Framing Core State                                     */
  __IOM uint32_t  NFCANTICOLRESSTATE;           /*!< (@ 0x0000042C) Automatic collision resolution (anti-collision)
                                                                    state                                                      */
  __IM  uint32_t  RESERVED9;
  __IM  uint32_t  MEASUREDFREQ;                 /*!< (@ 0x00000434) The frequency measured on the 13.56 MHz NFC carrier
                                                                    signal                                                     */
  __IM  uint32_t  ROSCCALVALUE;                 /*!< (@ 0x00000438) The current value used by the ring oscillator              */
  __IM  uint32_t  FIELDPRESENT;                 /*!< (@ 0x0000043C) Indicates the presence or not of a valid field             */
  __IM  uint32_t  CURRENTPEAKDETECTREF;         /*!< (@ 0x00000440) Current peak detect reference                              */
  __IM  uint32_t  RESERVED10[47];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Register to enable NFC functionality                       */
  __IOM uint32_t  FRAMEDELAYMIN;                /*!< (@ 0x00000504) Minimum frame delay                                        */
  __IOM uint32_t  FRAMEDELAYMAX;                /*!< (@ 0x00000508) Maximum frame delay                                        */
  __IOM uint32_t  FRAMEDELAYMODE;               /*!< (@ 0x0000050C) Configuration register for the Frame Delay Timer           */
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
                                                                    Data RAM                                                   */
  __IOM uint32_t  MAXLEN;                       /*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
                                                                    data storage each                                          */
  __IOM NFCT_TXD_Type TXD;                      /*!< (@ 0x00000518) Unspecified                                                */
  __IOM NFCT_RXD_Type RXD;                      /*!< (@ 0x00000520) Unspecified                                                */
  __IOM uint32_t  FRAMEDELAYSHIFT;              /*!< (@ 0x00000528) Correction for the frame delay reference                   */
  __IOM uint32_t  MODULATIONCTRL;               /*!< (@ 0x0000052C) Enables the modulation output to a GPIO pin which
                                                                    can be connected to a second external antenna.             */
  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000530) CRC polynomial                                             */
  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x00000534) CRC initial value                                          */
  __IOM uint32_t  MODULATIONPSEL;               /*!< (@ 0x00000538) Pin select for Modulation control.                         */
  __IM  uint32_t  RESERVED11[21];
  __IOM uint32_t  NFCID1_LAST;                  /*!< (@ 0x00000590) Last NFCID1 part (4, 7 or 10 bytes ID)                     */
  __IOM uint32_t  NFCID1_2ND_LAST;              /*!< (@ 0x00000594) Second last NFCID1 part (7 or 10 bytes ID)                 */
  __IOM uint32_t  NFCID1_3RD_LAST;              /*!< (@ 0x00000598) Third last NFCID1 part (10 bytes ID)                       */
  __IOM uint32_t  AUTOCOLRESCONFIG;             /*!< (@ 0x0000059C) Controls the auto collision resolution function.
                                                                    This setting must be done before the NFCT
                                                                    peripheral is activated.                                   */
  __IOM uint32_t  SENSRES;                      /*!< (@ 0x000005A0) NFC-A SENS_RES auto-response settings                      */
  __IOM uint32_t  SELRES;                       /*!< (@ 0x000005A4) NFC-A SEL_RES auto-response settings                       */
  __IM  uint32_t  RESERVED12[29];
  __IOM uint32_t  DEMODCONFIG;                  /*!< (@ 0x0000061C) Configuration settings for demodulation                    */
  __IOM uint32_t  FIELDDETECTCONFIG;            /*!< (@ 0x00000620) Configuration for NFCT_FIELDDETECT_TSMC55N                 */
  __IOM uint32_t  ANALOGTESTBUSEN;              /*!< (@ 0x00000624) Analog Testbus Enable - ATB0 only                          */
  __IOM uint32_t  SYMBOLTOLLOWER;               /*!< (@ 0x00000628) Configuration register for the tolerance of the
                                                                    received NFC pulse width                                   */
  __IOM uint32_t  SYMBOLTOLUPPER;               /*!< (@ 0x0000062C) Configuration register for the tolerance of the
                                                                    received NFC pulse width                                   */
  __IOM uint32_t  CONTINUOUSSUBCARRIER;         /*!< (@ 0x00000630) Selects continuous sub-carrier transmission                */
  __IM  uint32_t  RESERVED13[2];
  __IOM uint32_t  CLOCKRECCONFIG;               /*!< (@ 0x0000063C) Configuration for NFCT_CLOCKREC_TSMC55N                    */
  __IOM uint32_t  CLOCKSOURCE;                  /*!< (@ 0x00000640) Deprecated register - Clock source                         */
  __IOM uint32_t  FRAMECONTENT1;                /*!< (@ 0x00000644) Deprecated register - Buffer for custom-frame
                                                                    autoresponse frame-content, when no DMA
                                                                    is available                                               */
  __IOM uint32_t  FRAMECONTENT2;                /*!< (@ 0x00000648) Deprecated register - Buffer for custom-frame
                                                                    autoresponse, when no DMA is available                     */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  OVERRIDEENABLE;               /*!< (@ 0x00000650) Enables override functionality.                            */
  __IM  uint32_t  RESERVED15[3];
  __IOM uint32_t  OVRVALPWRUPNFC;               /*!< (@ 0x00000660) Override value for pwrupNfc                                */
  __IOM uint32_t  OVRVALMODULATION;             /*!< (@ 0x00000664) Override value for modulation on/off                       */
  __IOM uint32_t  OVRVALLOADINACTIVE;           /*!< (@ 0x00000668) Override value for the load control when modulation
                                                                    is off                                                     */
  __IOM uint32_t  OVRVALLOADACTIVE;             /*!< (@ 0x0000066C) Override value for the load control when modulation
                                                                    is on                                                      */
  __IOM uint32_t  OVRVALPWRUPRES;               /*!< (@ 0x00000670) Override value for power up resistor in the analog
                                                                    pad                                                        */
  __IOM uint32_t  OVRVALROSCCALCODE;            /*!< (@ 0x00000674) Override value for the calibration word for the
                                                                    oscillator                                                 */
  __IOM uint32_t  OVRVALROSCCALEN;              /*!< (@ 0x00000678) Override value for the signal CALEN going to
                                                                    the oscillator                                             */
  __IOM uint32_t  OVRVALCLAMPEN2V2;             /*!< (@ 0x0000067C) Override value for the 2V2 clamp                           */
  __IOM uint32_t  OVRVALCLAMPEN3V6;             /*!< (@ 0x00000680) Override value for the 3V6 clamp                           */
  __IOM uint32_t  AUTOCAL;                      /*!< (@ 0x00000684) Controls auto-calibration at NFCT module enabling          */
  __IM  uint32_t  RESERVED16;
  __IOM uint32_t  SHUNTREGCONFIG;               /*!< (@ 0x0000068C) Configuration for NFCT_SHUNTREG_TSMC55N                    */
  __IOM uint32_t  LOADMODCONFIG;                /*!< (@ 0x00000690) Configuration for load modulation                          */
  __IOM uint32_t  SHUNTNMOSADJUST;              /*!< (@ 0x00000694) Size adjustment for the shunt NMOS in shunt regulator      */
  __IOM uint32_t  RSHUNTCTRL;                   /*!< (@ 0x00000698) Adjust internal shunt resistance                           */
  __IOM uint32_t  OVRVALPEAKDETECTREF;          /*!< (@ 0x0000069C) Override value for the peak detect reference
                                                                    voltage                                                    */
  __IOM uint32_t  LOCKDETECTWINDOW;             /*!< (@ 0x000006A0) Adjust window size on falling edge of lock detect
                                                                    filter used for demodulation                               */
} NRF_NFCT_Type;                                /*!< Size = 1700 (0x6a4)                                                       */



/* =========================================================================================================================== */
/* ================                                         MUTEX_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief MUTEX 0 (MUTEX_NS)
  */

typedef struct {                                /*!< (@ 0x40030000) MUTEX_NS Structure                                         */
  __IM  uint32_t  RESERVED[256];
  __IOM uint32_t  MUTEX[16];                    /*!< (@ 0x00000400) Description collection: Mutex register                     */
} NRF_MUTEX_Type;                               /*!< Size = 1088 (0x440)                                                       */



/* =========================================================================================================================== */
/* ================                                        RAMTRIM0_NS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief RAM trim values 0 (RAMTRIM0_NS)
  */

typedef struct {                                /*!< (@ 0x40031000) RAMTRIM0_NS Structure                                      */
  __IM  uint32_t  RESERVED[257];
  __IOM uint32_t  SRAMTRIM;                     /*!< (@ 0x00000404) Backdoor trim values for SRAM                              */
  __IOM uint32_t  SRAMTRIMNVM;                  /*!< (@ 0x00000408) Backdoor trim values for NVM SRAM (cache)                  */
  __IOM uint32_t  SRAMTRIMCC312;                /*!< (@ 0x0000040C) Backdoor trim values for CC312 SRAM                        */
} NRF_RAMTRIM_Type;                             /*!< Size = 1040 (0x410)                                                       */



/* =========================================================================================================================== */
/* ================                                        RCOSC32K_NS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief 32.768 kHz RC oscillator 0 (RCOSC32K_NS)
  */

typedef struct {                                /*!< (@ 0x40032000) RCOSC32K_NS Structure                                      */
  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000000) Start calibration of LFRC oscillator                       */
  __OM  uint32_t  TASKS_CTSTART;                /*!< (@ 0x00000004) Deprecated register - Start calibration timer              */
  __OM  uint32_t  TASKS_CTSTOP;                 /*!< (@ 0x00000008) Deprecated register - Stop calibration timer               */
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_CAL;                /*!< (@ 0x00000080) Subscribe configuration for task CAL                       */
  __IOM uint32_t  SUBSCRIBE_CTSTART;            /*!< (@ 0x00000084) Deprecated register - Subscribe configuration
                                                                    for task CTSTART                                           */
  __IOM uint32_t  SUBSCRIBE_CTSTOP;             /*!< (@ 0x00000088) Deprecated register - Subscribe configuration
                                                                    for task CTSTOP                                            */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_CTTO;                  /*!< (@ 0x00000100) Deprecated register - Calibration timer timeout            */
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000104) Calibration of LFCLK RC oscillator complete event          */
  __IOM uint32_t  EVENTS_CTSTARTED;             /*!< (@ 0x00000108) Deprecated register - Calibration timer started            */
  __IOM uint32_t  EVENTS_CTSTOPPED;             /*!< (@ 0x0000010C) Deprecated register - Calibration timer stopped            */
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_CTTO;                 /*!< (@ 0x00000180) Deprecated register - Publish configuration for
                                                                    event CTTO                                                 */
  __IOM uint32_t  PUBLISH_DONE;                 /*!< (@ 0x00000184) Publish configuration for event DONE                       */
  __IOM uint32_t  PUBLISH_CTSTARTED;            /*!< (@ 0x00000188) Deprecated register - Publish configuration for
                                                                    event CTSTARTED                                            */
  __IOM uint32_t  PUBLISH_CTSTOPPED;            /*!< (@ 0x0000018C) Deprecated register - Publish configuration for
                                                                    event CTSTOPPED                                            */
  __IM  uint32_t  RESERVED3[164];
  __IM  uint32_t  RCOSC32KIFINE;                /*!< (@ 0x00000420) Fine calibration read value for 32.768 kHz RC
                                                                    oscillator                                                 */
  __IM  uint32_t  RCOSC32KICOARSE;              /*!< (@ 0x00000424) Coarse calibration read value for 32.768 kHz
                                                                    RC oscillator                                              */
  __IM  uint32_t  RESERVED4[67];
  __IOM uint32_t  RCOSC32KICALTEST;             /*!< (@ 0x00000534) 32.768 kHz RC oscillator calibration debug register
                                                                    NOTE: This register should not be written
                                                                    to while the RCOSC source is running.                      */
  __IOM uint32_t  CTIV;                         /*!< (@ 0x00000538) Deprecated register - Calibration timer interval
                                                                    NOTE: This register should not be written
                                                                    to while the calibration timer is running.                 */
  __IOM uint32_t  RCOSC32KICALLENGTH;           /*!< (@ 0x0000053C) 32kHz RC oscillator calibration length This value
                                                                    is read from FICR                                          */
  __IOM uint32_t  RCOSC32KICOARSEIN;            /*!< (@ 0x00000540) RCOSC coarse calibration input This value is
                                                                    read from FICR                                             */
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  RCOSC32KICABD;                /*!< (@ 0x0000054C) Comparator adaptive biasing disable                        */
  __IM  uint32_t  RESERVED6[13];
  __IOM uint32_t  ATECLOCK;                     /*!< (@ 0x00000584) Analog test bus control for clock modules                  */
  __IM  uint32_t  RESERVED7[11];
  __IOM uint32_t  LFRCMODE;                     /*!< (@ 0x000005B4) LFRC mode configuration                                    */
  __IOM uint32_t  LFULP32KICOARSEIN;            /*!< (@ 0x000005B8) Deprecated register - LFULP coarse calibration
                                                                    input This value is read from FICR                         */
  __IOM uint32_t  LFULP32KICALLENGTH;           /*!< (@ 0x000005BC) Deprecated register - 32kHz LFULP RC oscillator
                                                                    calibration length This value is read from
                                                                    FICR                                                       */
  __IM  uint32_t  RESERVED8[399];
  __IOM uint32_t  DISABLERCOSC32KIPOWERUPCONTROL;/*!< (@ 0x00000BFC) Backdoor for disabling Rcosc32KiPowerUpControl
                                                                    module in Rcosc32KiGenerator.                              */
} NRF_RCOSC32K_Type;                            /*!< Size = 3072 (0xc00)                                                       */



/* =========================================================================================================================== */
/* ================                                         QDEC0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder 0 (QDEC0_NS)
  */

typedef struct {                                /*!< (@ 0x40033000) QDEC0_NS Structure                                         */
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the quadrature decoder                       */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
  __OM  uint32_t  TASKS_READCLRACC;             /*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
  __OM  uint32_t  TASKS_RDCLRACC;               /*!< (@ 0x0000000C) Read and clear ACC                                         */
  __OM  uint32_t  TASKS_RDCLRDBL;               /*!< (@ 0x00000010) Read and clear ACCDBL                                      */
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_START;              /*!< (@ 0x00000080) Subscribe configuration for task START                     */
  __IOM uint32_t  SUBSCRIBE_STOP;               /*!< (@ 0x00000084) Subscribe configuration for task STOP                      */
  __IOM uint32_t  SUBSCRIBE_READCLRACC;         /*!< (@ 0x00000088) Subscribe configuration for task READCLRACC                */
  __IOM uint32_t  SUBSCRIBE_RDCLRACC;           /*!< (@ 0x0000008C) Subscribe configuration for task RDCLRACC                  */
  __IOM uint32_t  SUBSCRIBE_RDCLRDBL;           /*!< (@ 0x00000090) Subscribe configuration for task RDCLRDBL                  */
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;             /*!< (@ 0x00000104) Non-null report ready                                      */
  __IOM uint32_t  EVENTS_ACCOF;                 /*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
  __IOM uint32_t  EVENTS_DBLRDY;                /*!< (@ 0x0000010C) Double displacement(s) detected                            */
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000110) QDEC has been stopped                                      */
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  PUBLISH_SAMPLERDY;            /*!< (@ 0x00000180) Publish configuration for event SAMPLERDY                  */
  __IOM uint32_t  PUBLISH_REPORTRDY;            /*!< (@ 0x00000184) Publish configuration for event REPORTRDY                  */
  __IOM uint32_t  PUBLISH_ACCOF;                /*!< (@ 0x00000188) Publish configuration for event ACCOF                      */
  __IOM uint32_t  PUBLISH_DBLRDY;               /*!< (@ 0x0000018C) Publish configuration for event DBLRDY                     */
  __IOM uint32_t  PUBLISH_STOPPED;              /*!< (@ 0x00000190) Publish configuration for event STOPPED                    */
  __IM  uint32_t  RESERVED3[27];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED5[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable the quadrature decoder                              */
  __IOM uint32_t  LEDPOL;                       /*!< (@ 0x00000504) LED output pin polarity                                    */
  __IOM uint32_t  SAMPLEPER;                    /*!< (@ 0x00000508) Sample period                                              */
  __IM  int32_t   SAMPLE;                       /*!< (@ 0x0000050C) Motion sample value                                        */
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
                                                                    and DBLRDY events can be generated                         */
  __IM  int32_t   ACC;                          /*!< (@ 0x00000514) Register accumulating the valid transitions                */
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC or RDCLRACC task                                */
  __IOM QDEC_PSEL_Type PSEL;                    /*!< (@ 0x0000051C) Unspecified                                                */
  __IOM uint32_t  DBFEN;                        /*!< (@ 0x00000528) Enable input debounce filters                              */
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  LEDPRE;                       /*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    or RDCLRDBL task                                           */
} NRF_QDEC_Type;                                /*!< Size = 1356 (0x54c)                                                       */



/* =========================================================================================================================== */
/* ================                                          USBD_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal serial bus device 0 (USBD_NS)
  */

typedef struct {                                /*!< (@ 0x40036000) USBD_NS Structure                                          */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTEPIN[8];           /*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
                                                                    and EPIN[n].MAXCNT registers values, and
                                                                    enables endpoint IN n to respond to traffic
                                                                    from host EPIN[n].CONFIG is also captured                  */
  __OM  uint32_t  TASKS_STARTISOIN;             /*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
                                                                    values, and enables sending data on ISO
                                                                    endpoint ISOIN.CONFIG is also captured                     */
  __OM  uint32_t  TASKS_STARTEPOUT[8];          /*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
                                                                    and EPOUT[n].MAXCNT registers values, and
                                                                    enables endpoint n to respond to traffic
                                                                    from host EPOUT[n].CONFIG is also captured                 */
  __OM  uint32_t  TASKS_STARTISOOUT;            /*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
                                                                    values, and enables receiving of data on
                                                                    ISO endpoint ISOOUT.CONFIG is also captured                */
  __OM  uint32_t  TASKS_EP0RCVOUT;              /*!< (@ 0x0000004C) Allows OUT data stage on control endpoint 0                */
  __OM  uint32_t  TASKS_EP0STATUS;              /*!< (@ 0x00000050) Allows status stage on control endpoint 0                  */
  __OM  uint32_t  TASKS_EP0STALL;               /*!< (@ 0x00000054) Stalls data and status stage on control endpoint
                                                                    0                                                          */
  __OM  uint32_t  TASKS_DPDMDRIVE;              /*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
                                                                    in the DPDMVALUE register                                  */
  __OM  uint32_t  TASKS_DPDMNODRIVE;            /*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
                                                                    (USB engine takes control)                                 */
  __IOM uint32_t  TASK_TRIG_ZERO_PENALTY_DIG4;  /*!< (@ 0x00000060) PcgcSlaveDig zero penalty                                  */
  __IOM uint32_t  TASK_TRIG_FULL_PENALTY_DIG4;  /*!< (@ 0x00000064) PcgcSlaveDig full penalty                                  */
  __IOM uint32_t  TASK_TRIG_ZERO_PENALTY_DIG3;  /*!< (@ 0x00000068) PcgcSlaveDig zero penalty                                  */
  __IOM uint32_t  TASK_TRIG_FULL_PENALTY_DIG3;  /*!< (@ 0x0000006C) PcgcSlaveDig full penalty                                  */
  __IOM uint32_t  TASK_TRIG_ZERO_PENALTY_DIG2;  /*!< (@ 0x00000070) PcgcSlaveDig zero penalty                                  */
  __IOM uint32_t  TASK_TRIG_FULL_PENALTY_DIG2;  /*!< (@ 0x00000074) PcgcSlaveDig full penalty                                  */
  __IOM uint32_t  TASK_TRIG_ZERO_PENALTY_DIG1;  /*!< (@ 0x00000078) PcgcSlaveDig zero penalty                                  */
  __IOM uint32_t  TASK_TRIG_FULL_PENALTY_DIG1;  /*!< (@ 0x0000007C) PcgcSlaveDig full penalty                                  */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  SUBSCRIBE_STARTEPIN[8];       /*!< (@ 0x00000084) Description collection: Subscribe configuration
                                                                    for task STARTEPIN[n]                                      */
  __IOM uint32_t  SUBSCRIBE_STARTISOIN;         /*!< (@ 0x000000A4) Subscribe configuration for task STARTISOIN                */
  __IOM uint32_t  SUBSCRIBE_STARTEPOUT[8];      /*!< (@ 0x000000A8) Description collection: Subscribe configuration
                                                                    for task STARTEPOUT[n]                                     */
  __IOM uint32_t  SUBSCRIBE_STARTISOOUT;        /*!< (@ 0x000000C8) Subscribe configuration for task STARTISOOUT               */
  __IOM uint32_t  SUBSCRIBE_EP0RCVOUT;          /*!< (@ 0x000000CC) Subscribe configuration for task EP0RCVOUT                 */
  __IOM uint32_t  SUBSCRIBE_EP0STATUS;          /*!< (@ 0x000000D0) Subscribe configuration for task EP0STATUS                 */
  __IOM uint32_t  SUBSCRIBE_EP0STALL;           /*!< (@ 0x000000D4) Subscribe configuration for task EP0STALL                  */
  __IOM uint32_t  SUBSCRIBE_DPDMDRIVE;          /*!< (@ 0x000000D8) Subscribe configuration for task DPDMDRIVE                 */
  __IOM uint32_t  SUBSCRIBE_DPDMNODRIVE;        /*!< (@ 0x000000DC) Subscribe configuration for task DPDMNODRIVE               */
  __IOM uint32_t  TASK_TRIG_ZERO_PENALTY_MAIN1; /*!< (@ 0x000000E0) PcgcSlaveMain zero penalty                                 */
  __IOM uint32_t  TASK_TRIG_FULL_PENALTY_MAIN1; /*!< (@ 0x000000E4) PcgcSlaveMain full penalty                                 */
  __IM  uint32_t  RESERVED2[6];
  __IOM uint32_t  EVENTS_USBRESET;              /*!< (@ 0x00000100) Signals that a USB reset condition has been detected
                                                                    on USB lines                                               */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
                                                                    or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
                                                                    have been captured on all endpoints reported
                                                                    in the EPSTATUS register EPIN[n].CONFIG
                                                                    is also confirmed captured                                 */
  __IOM uint32_t  EVENTS_ENDEPIN[8];            /*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_EP0DATADONE;           /*!< (@ 0x00000128) An acknowledged data transfer has taken place
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_ENDISOIN;              /*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_ENDEPOUT[8];           /*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_ENDISOOUT;             /*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_SOF;                   /*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
                                                                    has been detected on USB lines                             */
  __IOM uint32_t  EVENTS_USBEVENT;              /*!< (@ 0x00000158) An event or an error not covered by specific
                                                                    events has occurred. Check EVENTCAUSE register
                                                                    to find the cause.                                         */
  __IOM uint32_t  EVENTS_EP0SETUP;              /*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_EPDATA;                /*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
                                                                    indicated by the EPDATASTATUS register                     */
  __IOM uint32_t  EVENTS_ACCESSFAULT;           /*!< (@ 0x00000164) Access to an unavailable USB register has been
                                                                    attempted (software or EasyDMA). This event
                                                                    can be generated even when USBD is not enabled.            */
  __IM  uint32_t  RESERVED3[6];
  __IOM uint32_t  PUBLISH_USBRESET;             /*!< (@ 0x00000180) Publish configuration for event USBRESET                   */
  __IOM uint32_t  PUBLISH_STARTED;              /*!< (@ 0x00000184) Publish configuration for event STARTED                    */
  __IOM uint32_t  PUBLISH_ENDEPIN[8];           /*!< (@ 0x00000188) Description collection: Publish configuration
                                                                    for event ENDEPIN[n]                                       */
  __IOM uint32_t  PUBLISH_EP0DATADONE;          /*!< (@ 0x000001A8) Publish configuration for event EP0DATADONE                */
  __IOM uint32_t  PUBLISH_ENDISOIN;             /*!< (@ 0x000001AC) Publish configuration for event ENDISOIN                   */
  __IOM uint32_t  PUBLISH_ENDEPOUT[8];          /*!< (@ 0x000001B0) Description collection: Publish configuration
                                                                    for event ENDEPOUT[n]                                      */
  __IOM uint32_t  PUBLISH_ENDISOOUT;            /*!< (@ 0x000001D0) Publish configuration for event ENDISOOUT                  */
  __IOM uint32_t  PUBLISH_SOF;                  /*!< (@ 0x000001D4) Publish configuration for event SOF                        */
  __IOM uint32_t  PUBLISH_USBEVENT;             /*!< (@ 0x000001D8) Publish configuration for event USBEVENT                   */
  __IOM uint32_t  PUBLISH_EP0SETUP;             /*!< (@ 0x000001DC) Publish configuration for event EP0SETUP                   */
  __IOM uint32_t  PUBLISH_EPDATA;               /*!< (@ 0x000001E0) Publish configuration for event EPDATA                     */
  __IOM uint32_t  PUBLISH_ACCESSFAULT;          /*!< (@ 0x000001E4) Publish configuration for event ACCESSFAULT                */
  __IM  uint32_t  RESERVED4[6];
  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED6[61];
  __IOM uint32_t  EVENTCAUSE;                   /*!< (@ 0x00000400) Details on what caused the USBEVENT event                  */
  __IM  uint32_t  BUSSTATE;                     /*!< (@ 0x00000404) Provides the logic state of D+ and D- lines                */
  __IM  uint32_t  RESERVED7[6];
  __IOM USBD_HALTED_Type HALTED;                /*!< (@ 0x00000420) Unspecified                                                */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  EPSTATUS;                     /*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
                                                                    registers have been captured                               */
  __IOM uint32_t  EPDATASTATUS;                 /*!< (@ 0x0000046C) Provides information on which endpoint(s) an
                                                                    acknowledged data transfer has occurred
                                                                    (EPDATA event)                                             */
  __IM  uint32_t  USBADDR;                      /*!< (@ 0x00000470) Device USB address                                         */
  __IM  uint32_t  DMASTATE;                     /*!< (@ 0x00000474) Indicates activity state of the DMA                        */
  __IM  uint32_t  RESERVED9[2];
  __IM  uint32_t  BMREQUESTTYPE;                /*!< (@ 0x00000480) SETUP data, byte 0, bmRequestType                          */
  __IM  uint32_t  BREQUEST;                     /*!< (@ 0x00000484) SETUP data, byte 1, bRequest                               */
  __IM  uint32_t  WVALUEL;                      /*!< (@ 0x00000488) SETUP data, byte 2, LSB of wValue                          */
  __IM  uint32_t  WVALUEH;                      /*!< (@ 0x0000048C) SETUP data, byte 3, MSB of wValue                          */
  __IM  uint32_t  WINDEXL;                      /*!< (@ 0x00000490) SETUP data, byte 4, LSB of wIndex                          */
  __IM  uint32_t  WINDEXH;                      /*!< (@ 0x00000494) SETUP data, byte 5, MSB of wIndex                          */
  __IM  uint32_t  WLENGTHL;                     /*!< (@ 0x00000498) SETUP data, byte 6, LSB of wLength                         */
  __IM  uint32_t  WLENGTHH;                     /*!< (@ 0x0000049C) SETUP data, byte 7, MSB of wLength                         */
  __IOM USBD_SIZE_Type SIZE;                    /*!< (@ 0x000004A0) Unspecified                                                */
  __IM  uint32_t  RESERVED10[15];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable USB                                                 */
  __IOM uint32_t  USBPULLUP;                    /*!< (@ 0x00000504) Control of the USB pull-up                                 */
  __IOM uint32_t  DPDMVALUE;                    /*!< (@ 0x00000508) State D+ and D- lines will be forced into by
                                                                    the DPDMDRIVE task. The DPDMNODRIVE task
                                                                    reverts the control of the lines to MAC
                                                                    IP (no forcing).                                           */
  __IOM uint32_t  DTOGGLE;                      /*!< (@ 0x0000050C) Data toggle control and status                             */
  __IOM uint32_t  EPINEN;                       /*!< (@ 0x00000510) Endpoint IN enable                                         */
  __IOM uint32_t  EPOUTEN;                      /*!< (@ 0x00000514) Endpoint OUT enable                                        */
  __OM  uint32_t  EPSTALL;                      /*!< (@ 0x00000518) STALL endpoints                                            */
  __IOM uint32_t  ISOSPLIT;                     /*!< (@ 0x0000051C) Controls the split of ISO buffers                          */
  __IM  uint32_t  FRAMECNTR;                    /*!< (@ 0x00000520) Returns the current value of the start of frame
                                                                    counter                                                    */
  __IOM uint32_t  TESTUSBPULLUP;                /*!< (@ 0x00000524) Control of the USB pull-up value, for test purposes        */
  __IOM uint32_t  RAMCONFIG;                    /*!< (@ 0x00000528) Trim value for internal PDM RAM                            */
  __IOM uint32_t  LOWPOWER;                     /*!< (@ 0x0000052C) Controls USBD peripheral low power mode during
                                                                    USB suspend                                                */
  __IOM uint32_t  ISOINCONFIG;                  /*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
                                                                    to an IN token when no data is ready to
                                                                    be sent                                                    */
  __IM  uint32_t  RESERVED11[51];
  __IOM USBD_EPIN_Type EPIN[8];                 /*!< (@ 0x00000600) Unspecified                                                */
  __IOM USBD_ISOIN_Type ISOIN;                  /*!< (@ 0x000006A0) Unspecified                                                */
  __IM  uint32_t  RESERVED12[20];
  __IOM USBD_EPOUT_Type EPOUT[8];               /*!< (@ 0x00000700) Unspecified                                                */
  __IOM USBD_ISOOUT_Type ISOOUT;                /*!< (@ 0x000007A0) Unspecified                                                */
  __IM  uint32_t  RESERVED13[20];
  __IOM uint32_t  RAWADDR;                      /*!< (@ 0x00000800) Address to be used for accessing the MAC IP4000            */
  __IOM uint32_t  RAWDATA;                      /*!< (@ 0x00000804) Actual read or write access to the raw IP, using
                                                                    RAWADDR address                                            */
  __IM  uint32_t  RESERVED14[254];
  __IOM uint32_t  PENALTY_DIG[5];               /*!< (@ 0x00000C00) Description collection: PcgcSlaveDig                       */
  __IOM uint32_t  PENALTY_MAIN0[2];             /*!< (@ 0x00000C14) Description collection: PcgcSlaveMain                      */
  __IOM uint32_t  FORCE_OVERRIDE_DIG[5];        /*!< (@ 0x00000C1C) Description collection: Clock and power request
                                                                    override register for PCPn in PcgcSlaveDig                 */
  __IOM uint32_t  FORCE_OVERRIDE_MAIN[2];       /*!< (@ 0x00000C30) Description collection: Similar to FORCE_OVERRIDE_DIG[0]
                                                                    but for PCP0 in PcgcSlaveMain                              */
  __IM  uint32_t  RESERVED15[17];
  __IOM uint32_t  TURN_OFF_AUTO_CLOCKSOURCE_REQ;/*!< (@ 0x00000C7C) Unused                                                     */
} NRF_USBD_Type;                                /*!< Size = 3200 (0xc80)                                                       */



/* =========================================================================================================================== */
/* ================                                      USBREGULATOR_NS                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief USB Regulator 0 (USBREGULATOR_NS)
  */

typedef struct {                                /*!< (@ 0x40037000) USBREGULATOR_NS Structure                                  */
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_USBDETECTED;           /*!< (@ 0x00000100) Voltage supply detected on VBUS                            */
  __IOM uint32_t  EVENTS_USBREMOVED;            /*!< (@ 0x00000104) Voltage supply removed from VBUS                           */
  __IOM uint32_t  EVENTS_USBPWRRDY;             /*!< (@ 0x00000108) USB 3.3 V supply ready                                     */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  PUBLISH_USBDETECTED;          /*!< (@ 0x00000180) Publish configuration for event USBDETECTED                */
  __IOM uint32_t  PUBLISH_USBREMOVED;           /*!< (@ 0x00000184) Publish configuration for event USBREMOVED                 */
  __IOM uint32_t  PUBLISH_USBPWRRDY;            /*!< (@ 0x00000188) Publish configuration for event USBPWRRDY                  */
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  USBREGSTATUS;                 /*!< (@ 0x00000400) USB supply status                                          */
} NRF_USBREG_Type;                              /*!< Size = 1028 (0x404)                                                       */



/* =========================================================================================================================== */
/* ================                                         VFSCTRL_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Voltage and frequency scaling control (VFSCTRL_S)
  */

typedef struct {                                /*!< (@ 0x50038000) VFSCTRL_S Structure                                        */
  __IM  uint32_t  RESERVED[257];
  __IM  uint32_t  HIGHVOLTAGEREADY;             /*!< (@ 0x00000404) High voltage ready                                         */
  __IM  uint32_t  VOLTAGEFSMSTATE;              /*!< (@ 0x00000408) Current state of the voltage state machine                 */
  __IM  uint32_t  VOLTAGEFSMINPUTS;             /*!< (@ 0x0000040C) High voltage ready                                         */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  HIGHVOLTAGEREQUEST;           /*!< (@ 0x00000504) Backdoor for high voltage requests                         */
  __IOM uint32_t  VOLTAGEFSMOVERRIDE;           /*!< (@ 0x00000508) Voltage state machine output override                      */
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  HFCLKFLEXOVERRIDE;            /*!< (@ 0x00000608) Override clock division factor (flex setting)              */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  HFCLK192MBASEFREQOVERRIDE;    /*!< (@ 0x00000610) Override clock source frequency setting                    */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  HFCLK192MFLEXOVERRIDE;        /*!< (@ 0x00000618) Override clock division factor (flex setting)              */
} NRF_VFSCTRL_Type;                             /*!< Size = 1564 (0x61c)                                                       */



/* =========================================================================================================================== */
/* ================                                          KMU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Key management unit 0 (KMU_NS)
  */

typedef struct {                                /*!< (@ 0x40039000) KMU_NS Structure                                           */
  __OM  uint32_t  TASKS_PUSH_KEYSLOT;           /*!< (@ 0x00000000) Push a key slot over secure APB                            */
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_KEYSLOT_PUSHED;        /*!< (@ 0x00000100) Key slot successfully pushed over secure APB               */
  __IOM uint32_t  EVENTS_KEYSLOT_REVOKED;       /*!< (@ 0x00000104) Key slot has been revoked and cannot be tasked
                                                                    for selection                                              */
  __IOM uint32_t  EVENTS_KEYSLOT_ERROR;         /*!< (@ 0x00000108) No key slot selected, no destination address
                                                                    defined, or error during push operation                    */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
  __IM  uint32_t  INTPEND;                      /*!< (@ 0x0000030C) Pending interrupts                                         */
  __IM  uint32_t  RESERVED2[63];
  __IM  uint32_t  STATUS;                       /*!< (@ 0x0000040C) Status bits for KMU operation                              */
  __IM  uint32_t  RESERVED3[60];
  __IOM uint32_t  SELECTKEYSLOT;                /*!< (@ 0x00000500) Select key slot to be read over AHB or pushed
                                                                    over secure APB when TASKS_PUSH_KEYSLOT
                                                                    is started                                                 */
} NRF_KMU_Type;                                 /*!< Size = 1284 (0x504)                                                       */



/* =========================================================================================================================== */
/* ================                                          NVMC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Non-volatile memory controller 0 (NVMC_NS)
  */

typedef struct {                                /*!< (@ 0x40039000) NVMC_NS Structure                                          */
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;                        /*!< (@ 0x00000400) Ready flag                                                 */
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;                    /*!< (@ 0x00000408) Ready flag                                                 */
  __IM  uint32_t  RESERVED2[62];
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  ERASEALL;                     /*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  ERASEPAGEPARTIALCFG;          /*!< (@ 0x0000051C) Register for partial erase configuration                   */
  __IM  uint32_t  RESERVED5[4];
  __IOM uint32_t  WAITSTATENUM;                 /*!< (@ 0x00000530) Register to set the number of wait-state for
                                                                    flash access. To update the WAITSTATENUM
                                                                    field, the ACCESSCODE must be correct.                     */
  __IM  uint32_t  RESERVED6[20];
  __IOM uint32_t  CONFIGNS;                     /*!< (@ 0x00000584) Unspecified                                                */
  __OM  uint32_t  WRITEUICRNS;                  /*!< (@ 0x00000588) Non-secure APPROTECT enable register                       */
  __IM  uint32_t  RESERVED7[29];
  __IOM uint32_t  TESTMODE;                     /*!< (@ 0x00000600) Register for entering test mode. Refer to the
                                                                    flash IP test documentation for more details.              */
  __IOM uint32_t  LVEN;                         /*!< (@ 0x00000604) Low voltage mode                                           */
  __IM  uint32_t  RESERVED8[2];
  __OM  uint32_t  TESTMASSERASE;                /*!< (@ 0x00000610) Self-timed mass-erase operation                            */
  __OM  uint32_t  TESTERASEREFCELL;             /*!< (@ 0x00000614) Self-timed erase reference cell operation                  */
  __IM  uint32_t  TESTTC;                       /*!< (@ 0x00000618) Observe the TC output from the flash macro                 */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  TESTDATA128[4];               /*!< (@ 0x00000620) Description collection: Direct flash test data
                                                                    word n                                                     */
  __IM  uint32_t  TESTDATA128INC[4];            /*!< (@ 0x00000630) Description collection: Direct flash test data
                                                                    word n. Post-increments TESTCONTROLADDR.                   */
  __IM  uint32_t  TESTCMPINC;                   /*!< (@ 0x00000640) Reads and compares last flash row to TESTDATA128
                                                                    content. Post-increments TESTCONTROLADDR.                  */
  __IM  uint32_t  TESTNCMPINC;                  /*!< (@ 0x00000644) Reads and compares last flash row to complement
                                                                    of TESTDATA128 content. Post-increments
                                                                    TESTCONTROLADDR.                                           */
  __IOM uint32_t  TESTCONTROLLINES;             /*!< (@ 0x00000648) Direct flash test, control lines. Refer to the
                                                                    flash IP test documentation for more details.              */
  __IOM uint32_t  TESTCONTROLADDR;              /*!< (@ 0x0000064C) Direct flash test control, address lines                   */
  __IOM uint32_t  TESTCOUNTERRELOAD;            /*!< (@ 0x00000650) Counter reload value, used when counting from
                                                                    SE or YE rising edge to latching of data                   */
  __IM  uint32_t  TESTCOUNTERRUNNING;           /*!< (@ 0x00000654) Returns the state (counting or not) of the counter         */
  __IOM uint32_t  TESTCONFIG;                   /*!< (@ 0x00000658) Mode of operation of the counter                           */
  __IOM uint32_t  TESTTMVPPANAEN;               /*!< (@ 0x0000065C) Controls analog signals for flash measurements             */
  __IM  uint32_t  RESERVED10[40];
  __IOM uint32_t  FORCEONNVM;                   /*!< (@ 0x00000700) Force on all NVM supplies. Also see the internal
                                                                    section in the NVMC chapter.                               */
  __IM  uint32_t  RESERVED11[9];
  __IOM uint32_t  FORCEOFFNVM;                  /*!< (@ 0x00000728) Force off NVM supply. Also see the internal section
                                                                    in the NVMC chapter.                                       */
} NRF_NVMC_Type;                                /*!< Size = 1836 (0x72c)                                                       */



/* =========================================================================================================================== */
/* ================                                           P0_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (P0_NS)
  */

typedef struct {                                /*!< (@ 0x40842500) P0_NS Structure                                            */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  OUT;                          /*!< (@ 0x00000004) Write GPIO port                                            */
  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000008) Set individual bits in GPIO port                           */
  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000000C) Clear individual bits in GPIO port                         */
  __IM  uint32_t  IN;                           /*!< (@ 0x00000010) Read GPIO port                                             */
  __IOM uint32_t  DIR;                          /*!< (@ 0x00000014) Direction of GPIO pins                                     */
  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000018) DIR set register                                           */
  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000001C) DIR clear register                                         */
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000020) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000024) Select between default DETECT signal behavior
                                                                    and LDETECT mode (For non-secure pin only)                 */
  __IOM uint32_t  DETECTMODE_SEC;               /*!< (@ 0x00000028) Select between default DETECT signal behavior
                                                                    and LDETECT mode (For secure pin only)                     */
  __IM  uint32_t  RESERVED1[53];
  __IOM GPIO_PIN_Type PIN[32];                  /*!< (@ 0x00000100) Pin n direct access                                        */
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000200) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;                                /*!< Size = 640 (0x280)                                                        */



/* =========================================================================================================================== */
/* ================                                      GPIOINTERNAL_NS                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Static 0 (GPIOINTERNAL_NS)
  */

typedef struct {                                /*!< (@ 0x50842800) GPIOINTERNAL_NS Structure                                  */
  __IM  uint32_t  RESERVED[896];
  __IOM uint32_t  LATCHCLRWAITCNT;              /*!< (@ 0x00000E00) Select the number of wait cycles inserted on
                                                                    the bus when a LATCH register is cleared.
                                                                    Note: this register is only accessible from
                                                                    secure code.                                               */
  __IOM uint32_t  FORCELDETECTLOWCNT;           /*!< (@ 0x00000E04) Select the number of cycles that LDETECT is forced
                                                                    low after clearing a LATCH register. Note:
                                                                    this register is only accessible from secure
                                                                    code.                                                      */
  __IOM uint32_t  RESET;                        /*!< (@ 0x00000E08) Reset all GPIO registers. Note: this register
                                                                    is only accessible from secure code.                       */
  __IOM uint32_t  SENSECONFIGCHANGECNT;         /*!< (@ 0x00000E0C) Selects the number of cycles before the SENSE
                                                                    configuration takes effect when it is changed.
                                                                    Setting this register lower than the reset
                                                                    value can lead to unwanted LATCH set when
                                                                    SENSE and INPUT fields (PIN_CNF) are changed
                                                                    simultaneously. Note: this register is only
                                                                    accessible from secure code.                               */
} NRF_GPIOSTATIC_Type;                          /*!< Size = 3600 (0xe10)                                                       */



/* =========================================================================================================================== */
/* ================                                       CRYPTOCELL_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief ARM TrustZone CryptoCell register interface (CRYPTOCELL_S)
  */

typedef struct {                                /*!< (@ 0x50844000) CRYPTOCELL_S Structure                                     */
  __IM  uint32_t  RESERVED[26];
  __OM  uint32_t  TASKZEROPENALTY2;             /*!< (@ 0x00000068) CRYPTOCELL PcgcSlave: Set the penalty to zero
                                                                    for power/clock pair 2                                     */
  __OM  uint32_t  TASKFULLPENALTY2;             /*!< (@ 0x0000006C) CRYPTOCELL PcgcSlave: Set the penalty to full
                                                                    for power/clock pair 2                                     */
  __OM  uint32_t  TASKZEROPENALTY1;             /*!< (@ 0x00000070) CRYPTOCELL PcgcSlave: Set the penalty to zero
                                                                    for power/clock pair 1                                     */
  __OM  uint32_t  TASKFULLPENALTY1;             /*!< (@ 0x00000074) CRYPTOCELL PcgcSlave: Set the penalty to full
                                                                    for power/clock pair 1                                     */
  __OM  uint32_t  TASKZEROPENALTY0;             /*!< (@ 0x00000078) CRYPTOCELL PcgcSlave: Set the penalty to zero
                                                                    for power/clock pair 0                                     */
  __OM  uint32_t  TASKFULLPENALTY0;             /*!< (@ 0x0000007C) CRYPTOCELL PcgcSlave: Set the penalty to full
                                                                    for power/clock pair 0                                     */
  __IM  uint32_t  RESERVED1[288];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable CRYPTOCELL subsystem.                               */
  __IM  uint32_t  RESERVED2[447];
  __IOM uint32_t  PENALTYRG0;                   /*!< (@ 0x00000C00) CRYPTOCELL PcgcSlave: Penalty reg power/clock
                                                                    pair 0                                                     */
  __IOM uint32_t  PENALTYRG1;                   /*!< (@ 0x00000C04) CRYPTOCELL PcgcSlave: Penalty reg power/clock
                                                                    pair 1                                                     */
  __IOM uint32_t  PENALTYRG2;                   /*!< (@ 0x00000C08) CRYPTOCELL PcgcSlave: Penalty reg power/clock
                                                                    pair 2                                                     */
  __IM  uint32_t  RESERVED3[29];
  __IOM uint32_t  FORCEOVERRIDE0;               /*!< (@ 0x00000C80) CRYPTOCELL and CC312KmuInterface PcgcSlave: Override
                                                                    power/clock pair 0                                         */
  __IOM uint32_t  FORCEOVERRIDE1;               /*!< (@ 0x00000C84) CRYPTOCELL PcgcSlave: Override power/clock pair
                                                                    1                                                          */
  __IOM uint32_t  FORCEOVERRIDE2;               /*!< (@ 0x00000C88) CRYPTOCELL PcgcSlave: Override power/clock pair
                                                                    2                                                          */
} NRF_CRYPTOCELL_Type;                          /*!< Size = 3212 (0xc8c)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_AES_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell AES (CC_AES_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_AES_S Structure                                         */
  __IM  uint32_t  RESERVED[256];
  __OM  uint32_t  AES_KEY_0_0;                  /*!< (@ 0x00000400) Bits 31:0 of AES_KEY_0 (used as the AES key in
                                                                    non-tunneling operations, and as the first
                                                                    tunnel stage key in tunneling operations).                 */
  __OM  uint32_t  AES_KEY_0_1;                  /*!< (@ 0x00000404) Bits 63:32 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_2;                  /*!< (@ 0x00000408) Bits 95:64 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_3;                  /*!< (@ 0x0000040C) Bits 127:96 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_4;                  /*!< (@ 0x00000410) Bits 159:128 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_5;                  /*!< (@ 0x00000414) Bits 191:160 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_6;                  /*!< (@ 0x00000418) Bits 223:192 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_0_7;                  /*!< (@ 0x0000041C) Bits 255:224 of AES_KEY_0 (used as the AES key
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage key in tunneling operations).           */
  __OM  uint32_t  AES_KEY_1_0;                  /*!< (@ 0x00000420) Bits 31:0 of AES_KEY_1 (used as the second AES
                                                                    tunnel stage key in tunneling operations).                 */
  __OM  uint32_t  AES_KEY_1_1;                  /*!< (@ 0x00000424) Bits 63:32 of AES_KEY_1 (used as the second AES
                                                                    tunnel stage key in tunneling operations).                 */
  __OM  uint32_t  AES_KEY_1_2;                  /*!< (@ 0x00000428) Bits 95:64 of AES_KEY_1 (used as the second AES
                                                                    tunnel stage key in tunneling operations).                 */
  __OM  uint32_t  AES_KEY_1_3;                  /*!< (@ 0x0000042C) Bits 127:96 of AES_KEY_1 (used as the second
                                                                    AES tunnel stage key in tunneling operations).             */
  __OM  uint32_t  AES_KEY_1_4;                  /*!< (@ 0x00000430) Bits 159:128 of AES_KEY_1 (used as the second
                                                                    AES tunnel stage key in tunneling operations).             */
  __OM  uint32_t  AES_KEY_1_5;                  /*!< (@ 0x00000434) Bits 191:160 of AES_KEY_1 (used as the second
                                                                    AES tunnel stage key in tunneling operations).             */
  __OM  uint32_t  AES_KEY_1_6;                  /*!< (@ 0x00000438) Bits 223:192 of AES_KEY_1 (used as the second
                                                                    AES tunnel stage key in tunneling operations).             */
  __OM  uint32_t  AES_KEY_1_7;                  /*!< (@ 0x0000043C) Bits 255:224 of AES_KEY_1 (used as the second
                                                                    AES tunnel stage key in tunneling operations).             */
  __IOM uint32_t  AES_IV_0_0;                   /*!< (@ 0x00000440) Bits 31:0 of AES_IV0 register. AES_IV0 is used
                                                                    as the AES IV (initialization value) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage iv register in tunneling
                                                                    operations. The IV register should be loaded
                                                                    according to the AES mode: in AES CBC/CBC-MAC
                                                                    the AES IV register should be loaded with
                                                                    the IV (initialization vector), in XTS-AES
                                                                    the AES IV register should be loaded with
                                                                    the 'T' value (unless the HW T calculation
                                                                    mode is active, in which the 'T' value is
                                                                    calculated by th                                           */
  __IOM uint32_t  AES_IV_0_1;                   /*!< (@ 0x00000444) Bits 63:32 of AES_IV0 128b register. For the
                                                                    description of AES_IV0, see the AES_IV_0_0
                                                                    register description                                       */
  __IOM uint32_t  AES_IV_0_2;                   /*!< (@ 0x00000448) Bits 95:64 of AES_IV0 128b register. For the
                                                                    description of AES_IV0, see the AES_IV_0_0
                                                                    register description                                       */
  __IOM uint32_t  AES_IV_0_3;                   /*!< (@ 0x0000044C) Bits 127:96 of AES_IV0 128b register. For the
                                                                    description of AES_IV0, see the AES_IV_0_0
                                                                    register description                                       */
  __IOM uint32_t  AES_IV_1_0;                   /*!< (@ 0x00000450) Bits 31:0 of AES_IV1 128b register. AES_IV1 is
                                                                    used as the AES IV (initialization value)
                                                                    register as the second tunnel stage iv register
                                                                    in tunneling operations. The IV register
                                                                    should be loaded according to the AES mode:
                                                                    in AES CBC/CBC-MAC the AES IV register should
                                                                    be loaded with the IV (initialization vector),
                                                                    in XTS-AES the AES IV register should be
                                                                    loaded with the 'T' value (unless the HW
                                                                    T calculation mode is active, in which the
                                                                    'T' value is calculated by the HW.                         */
  __IOM uint32_t  AES_IV_1_1;                   /*!< (@ 0x00000454) Bits 63:32 of AES_IV1 128b register. For the
                                                                    description of AES_IV1, see the AES_IV_1_0
                                                                    register description                                       */
  __IOM uint32_t  AES_IV_1_2;                   /*!< (@ 0x00000458) Bits 95:64 of AES_IV1 128b register. For the
                                                                    description of AES_IV1, see the AES_IV_1_0
                                                                    register description                                       */
  __IOM uint32_t  AES_IV_1_3;                   /*!< (@ 0x0000045C) Bits 127:96 of AES_IV1 128b register. For the
                                                                    description of AES_IV1, see the AES_IV_1_0
                                                                    register description                                       */
  __IOM uint32_t  AES_CTR_0_0;                  /*!< (@ 0x00000460) Bits 31:0 of AES_CTR0 128b register. AES_CTR_0
                                                                    is used as the AES CTR (counter) register
                                                                    in non-tunneling operations, and as the
                                                                    first tunnel stage CTR register in tunneling
                                                                    operations. The CTR register should be loaded
                                                                    according to the AES mode: in AES CTR/GCTR
                                                                    the AES CTR register should be loaded with
                                                                    the counter value, in XTS-AES the AES CTR
                                                                    register should be loaded with the 'i' value
                                                                    (in order to calculate the T value from
                                                                    it, if HW T calculation is supported).                     */
  __IOM uint32_t  AES_CTR_0_1;                  /*!< (@ 0x00000464) Bits 63:32 of AES_CTR0 128b register. For the
                                                                    description of AES_CTR0, see the AES_CTR_0_0
                                                                    register description.                                      */
  __IOM uint32_t  AES_CTR_0_2;                  /*!< (@ 0x00000468) Bits 95:64 of AES_CTR0 128b register. For the
                                                                    description of AES_CTR0, see the AES_CTR_0_0
                                                                    register description.                                      */
  __IOM uint32_t  AES_CTR_0_3;                  /*!< (@ 0x0000046C) Bits 127:96 of AES_CTR0 128b register. For the
                                                                    description of AES_CTR0, see the AES_CTR_0_0
                                                                    register description.                                      */
  __IM  uint32_t  AES_BUSY;                     /*!< (@ 0x00000470) This register is set when the AES core is active           */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  AES_SK;                       /*!< (@ 0x00000478) Writing to this address causes sampling of the
                                                                    HW key to the AES_KEY0 register                            */
  __OM  uint32_t  AES_CMAC_INIT;                /*!< (@ 0x0000047C) Writing to this address triggers the AES engine
                                                                    generating of K1 and K2 for AES CMAC operations.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  RESERVED2[13];
  __OM  uint32_t  AES_SK1;                      /*!< (@ 0x000004B4) Writing to this address causes sampling of the
                                                                    HW key to the AES_KEY1 register                            */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  AES_REMAINING_BYTES;          /*!< (@ 0x000004BC) This register should be set with the amount of
                                                                    remaining bytes until the end of the current
                                                                    AES operation. The AES engine counts down
                                                                    from this value to determine the last /
                                                                    one before last blocks in AES CMAC, XTS
                                                                    AES and AES CCM.                                           */
  __IOM uint32_t  AES_CONTROL;                  /*!< (@ 0x000004C0) This register holds the configuration of the
                                                                    AES engine. Note: This is a special register,
                                                                    affected by internal logic. test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  RESERVED4;
  __IM  uint32_t  AES_HW_FLAGS;                 /*!< (@ 0x000004C8) This register holds the pre-synthesis hw flag
                                                                    configuration of the AES engine                            */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  AES_CTR_NO_INCREMENT;         /*!< (@ 0x000004D8) This register enables the AES CTR no increment
                                                                    mode in which the counter mode is not incremented
                                                                    between 2 blocks                                           */
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  AES_DFA_IS_ON;                /*!< (@ 0x000004F0) This register disable/enable the AES DFA. Note:
                                                                    This is a special register, affected by
                                                                    internal logic. test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  RESERVED7;
  __IM  uint32_t  AES_DFA_ERR_STATUS;           /*!< (@ 0x000004F8) DFA error status register.                                 */
  __IM  uint32_t  RESERVED8[10];
  __OM  uint32_t  AES_CMAC_SIZE0_KICK;          /*!< (@ 0x00000524) Writing to this address triggers the AES engine
                                                                    to perform a CMAC operation with size 0.
                                                                    The CMAC result can be read from the AES_IV0
                                                                    register.                                                  */
} NRF_CC_AES_Type;                              /*!< Size = 1320 (0x528)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_AHB_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell AHB (CC_AHB_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_AHB_S Structure                                         */
  __IM  uint32_t  RESERVED[704];
  __IOM uint32_t  AHBM_SINGLES;                 /*!< (@ 0x00000B00) This register forces the AHB transactions from
                                                                    CRYPTOCELL master to be always singles.                    */
  __IOM uint32_t  AHBM_HPROT;                   /*!< (@ 0x00000B04) This register holds the AHB HPROT value                    */
  __IOM uint32_t  AHBM_HMASTLOCK;               /*!< (@ 0x00000B08) This register holds AHB HMASTLOCK value                    */
  __IOM uint32_t  AHBM_HNONSEC;                 /*!< (@ 0x00000B0C) This register holds AHB HNONSEC value                      */
} NRF_CC_AHB_Type;                              /*!< Size = 2832 (0xb10)                                                       */



/* =========================================================================================================================== */
/* ================                                          CC_AO_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell AO (CC_AO_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_AO_S Structure                                          */
  __IM  uint32_t  RESERVED[1920];
  __IOM uint32_t  HOST_DCU_EN0;                 /*!< (@ 0x00001E00) The DCU [31:0] enable register. Note: This is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  HOST_DCU_EN1;                 /*!< (@ 0x00001E04) The DCU [63:32] enable register. Note: This is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  HOST_DCU_EN2;                 /*!< (@ 0x00001E08) The DCU [95:64] enable register. Note: This is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  HOST_DCU_EN3;                 /*!< (@ 0x00001E0C) The DCU [1271:96] enable register. Note: This
                                                                    is a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  HOST_DCU_LOCK0;               /*!< (@ 0x00001E10) The DCU lock register. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IOM uint32_t  HOST_DCU_LOCK1;               /*!< (@ 0x00001E14) The DCU lock register. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IOM uint32_t  HOST_DCU_LOCK2;               /*!< (@ 0x00001E18) The DCU lock register. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IOM uint32_t  HOST_DCU_LOCK3;               /*!< (@ 0x00001E1C) The DCU lock register. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IM  uint32_t  AO_ICV_DCU_RESTRICTION_MASK0; /*!< (@ 0x00001E20) The dcu lock register.                                     */
  __IM  uint32_t  AO_ICV_DCU_RESTRICTION_MASK1; /*!< (@ 0x00001E24) The 'ICV_DCU_RESTRICTION_MASK' parameter is read
                                                                    by FW during the secure debug verification
                                                                    to prevent OEM from setting specific DCUs
                                                                    that protect ICV secrets                                   */
  __IM  uint32_t  AO_ICV_DCU_RESTRICTION_MASK2; /*!< (@ 0x00001E28) The 'ICV_DCU_RESTRICTION_MASK' parameter is read
                                                                    by FW during the secure debug verification
                                                                    to prevent OEM from setting specific DCUs
                                                                    that protect ICV secrets                                   */
  __IM  uint32_t  AO_ICV_DCU_RESTRICTION_MASK3; /*!< (@ 0x00001E2C) The 'ICV_DCU_RESTRICTION_MASK' parameter is read
                                                                    by FW during the secure debug verification
                                                                    to prevent OEM from setting specific DCUs
                                                                    that protect ICV secrets                                   */
  __IM  uint32_t  AO_CC_SEC_DEBUG_RESET;        /*!< (@ 0x00001E30) The reset-upon-debug indication                            */
  __IOM uint32_t  HOST_AO_LOCK_BITS;            /*!< (@ 0x00001E34) These masks will define, per LCS, which DCU bits
                                                                    will be tied to zero, even if the host tries
                                                                    to set them. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IOM uint32_t  AO_APB_FILTERING;             /*!< (@ 0x00001E38) This register holds the AO_APB_FILTERING data.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  AO_CC_GPPC;                   /*!< (@ 0x00001E3C) Holds the AO_CC_GPPC value from AO. Note: This
                                                                    is a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __OM  uint32_t  HOST_RGF_CC_SW_RST;           /*!< (@ 0x00001E40) Writing to this register trigger a reset to CRYPTOCELL.
                                                                    This reset takes about 4 core clock cycles.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA.                                                     */
} NRF_CC_AO_Type;                               /*!< Size = 7748 (0x1e44)                                                      */



/* =========================================================================================================================== */
/* ================                                        CC_CHACHA_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell CHACHA (CC_CHACHA_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_CHACHA_S Structure                                      */
  __IM  uint32_t  RESERVED[224];
  __IOM uint32_t  CHACHA_CONTROL_REG;           /*!< (@ 0x00000380) ChaCha general configuration.                              */
  __IM  uint32_t  CHACHA_VERSION;               /*!< (@ 0x00000384) ChaCha version                                             */
  __OM  uint32_t  CHACHA_KEY0;                  /*!< (@ 0x00000388) Bits [255:224] of ChaCha key                               */
  __OM  uint32_t  CHACHA_KEY1;                  /*!< (@ 0x0000038C) Bits [223:192] of ChaCha key                               */
  __OM  uint32_t  CHACHA_KEY2;                  /*!< (@ 0x00000390) Bits [191:160] of ChaCha key                               */
  __OM  uint32_t  CHACHA_KEY3;                  /*!< (@ 0x00000394) Bits [159:128] of ChaCha key                               */
  __OM  uint32_t  CHACHA_KEY4;                  /*!< (@ 0x00000398) Bits [127:96] of ChaCha key                                */
  __OM  uint32_t  CHACHA_KEY5;                  /*!< (@ 0x0000039C) Bits [95:64] of ChaCha key                                 */
  __OM  uint32_t  CHACHA_KEY6;                  /*!< (@ 0x000003A0) Bits [63:32] of ChaCha key                                 */
  __OM  uint32_t  CHACHA_KEY7;                  /*!< (@ 0x000003A4) Bits [31:0] of ChaCha key                                  */
  __IOM uint32_t  CHACHA_IV_0;                  /*!< (@ 0x000003A8) Bits [31:0] of ChaCha init-vector zero register            */
  __IOM uint32_t  CHACHA_IV_1;                  /*!< (@ 0x000003AC) Bits [31:0] of ChaCha init-vector register                 */
  __IM  uint32_t  CHACHA_BUSY;                  /*!< (@ 0x000003B0) This register is asserted whenever the ChaCha/Salsa
                                                                    core is active                                             */
  __IM  uint32_t  CHACHA_HW_FLAGS;              /*!< (@ 0x000003B4) This register holds the pre-synthesis HW flag
                                                                    configuration of the ChaCha/Salsa engine                   */
  __IOM uint32_t  CHACHA_BLOCK_CNT_LSB;         /*!< (@ 0x000003B8) The two first words (n) in the last row of the
                                                                    cipher matrix are the block counter. At
                                                                    the end of each block (512b), the block_cnt
                                                                    for the next block is written by HW to the
                                                                    CHACHA_BLOCK_CNT_LSB and CHACHA_BLOCK_CNT_MSB
                                                                    registers. If starting a new message the
                                                                    block counter must also be reset.                          */
  __IOM uint32_t  CHACHA_BLOCK_CNT_MSB;         /*!< (@ 0x000003BC) The two first words (n) in the last row of the
                                                                    cipher matrix are the block counter. at
                                                                    the end of each block (512b), the block_cnt
                                                                    for the next block is written by HW to the
                                                                    CHACHA_BLOCK_CNT_LSB and CHACHA_BLOCK_CNT_MSB
                                                                    registers. If starting a new message the
                                                                    block counter must also be reset.                          */
  __OM  uint32_t  CHACHA_SW_RESET;              /*!< (@ 0x000003C0) Resets ChaCha/Salsa engine.                                */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY0;         /*!< (@ 0x000003C4) Bits [255:224] of CHACHA_FOR_POLY_KEY0                     */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY1;         /*!< (@ 0x000003C8) Bits [223:192] of CHACHA_FOR_POLY_KEY1                     */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY2;         /*!< (@ 0x000003CC) Bits191:160 of CHACHA_FOR_POLY_KEY2                        */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY3;         /*!< (@ 0x000003D0) Bits159:128 of CHACHA_FOR_POLY_KEY3                        */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY4;         /*!< (@ 0x000003D4) Bits 127:96 of CHACHA_FOR_POLY_KEY4                        */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY5;         /*!< (@ 0x000003D8) Bits 95:64 of CHACHA_FOR_POLY_KEY5                         */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY6;         /*!< (@ 0x000003DC) Bits 63:32 of CHACHA_FOR_POLY_KEY6                         */
  __IM  uint32_t  CHACHA_FOR_POLY_KEY7;         /*!< (@ 0x000003E0) Bits 31:0 of CHACHA_FOR_POLY_KEY7                          */
  __IOM uint32_t  CHACHA_BYTE_WORD_ORDER_CNTL_REG;/*!< (@ 0x000003E4) ChaCha/Salsa data order configuration.                   */
  __IM  uint32_t  CHACHA_DEBUG_REG;             /*!< (@ 0x000003E8) This register is used to debug the ChaCha engine           */
} NRF_CC_CHACHA_Type;                           /*!< Size = 1004 (0x3ec)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_CTL_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell CTL (CC_CTL_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_CTL_S Structure                                         */
  __IM  uint32_t  RESERVED[576];
  __OM  uint32_t  CRYPTO_CTL;                   /*!< (@ 0x00000900) Defines the cryptographic flow.                            */
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CRYPTO_BUSY;                  /*!< (@ 0x00000910) This register is asserted when the cryptographic
                                                                    core is busy.                                              */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  HASH_BUSY;                    /*!< (@ 0x0000091C) This register is set when the HASH engine is
                                                                    busy.                                                      */
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  CONTEXT_ID;                   /*!< (@ 0x00000930) A generic R/W register for firmware use.                   */
} NRF_CC_CTL_Type;                              /*!< Size = 2356 (0x934)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_DIN_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell Data-In (DIN) block (CC_DIN_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_DIN_S Structure                                         */
  __IM  uint32_t  RESERVED[768];
  __OM  uint32_t  DIN_BUFFER;                   /*!< (@ 0x00000C00) This address can be used by the CPU to write
                                                                    data directly to the DIN buffer to be sent
                                                                    to engines.                                                */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DIN_MEM_DMA_BUSY;             /*!< (@ 0x00000C20) DIN memory DMA busy - indicates that DIN DMA
                                                                    memory source is busy.                                     */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  SRC_LLI_WORD0;                /*!< (@ 0x00000C28) This register is used in direct LLI mode, and
                                                                    holds the location of the data source in
                                                                    the memory.                                                */
  __OM  uint32_t  SRC_LLI_WORD1;                /*!< (@ 0x00000C2C) This register is used in direct LLI mode, and
                                                                    holds the number of bytes to be read from
                                                                    the memory. Writing to this register triggers
                                                                    the DMA. Note: this is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IOM uint32_t  SRAM_SRC_ADDR;                /*!< (@ 0x00000C30) Location of data (source address) to be read
                                                                    from RNG_SRAM. Note: this is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IOM uint32_t  DIN_SRAM_BYTES_LEN;           /*!< (@ 0x00000C34) This register holds the size of the data (in
                                                                    bytes) to be read from the RNG_SRAM. Note:
                                                                    This is a special register, affected by
                                                                    internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  DIN_SRAM_DMA_BUSY;            /*!< (@ 0x00000C38) This register holds the status of the RNG_SRAM
                                                                    DMA DIN.                                                   */
  __IOM uint32_t  DIN_SRAM_ENDIANNESS;          /*!< (@ 0x00000C3C) This register defines the endianness of the DIN
                                                                    interface to RNG_SRAM.                                     */
  __IM  uint32_t  RESERVED3[2];
  __OM  uint32_t  DIN_CPU_DATA_SIZE;            /*!< (@ 0x00000C48) This register hold the number of bytes to be
                                                                    written to the DIN buffer. Note: This is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IM  uint32_t  RESERVED4;
  __IM  uint32_t  FIFO_IN_EMPTY;                /*!< (@ 0x00000C50) DIN FIFO empty indication                                  */
  __IM  uint32_t  RESERVED5;
  __OM  uint32_t  DIN_FIFO_RST_PNTR;            /*!< (@ 0x00000C58) Writing to this register resets the DIN_FIFO
                                                                    pointers.                                                  */
} NRF_CC_DIN_Type;                              /*!< Size = 3164 (0xc5c)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_DOUT_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell DOUT (CC_DOUT_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_DOUT_S Structure                                        */
  __IM  uint32_t  RESERVED[832];
  __IM  uint32_t  DOUT_BUFFER;                  /*!< (@ 0x00000D00) Cryptographic result - CPU can directly access
                                                                    this register. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DOUT_MEM_DMA_BUSY;            /*!< (@ 0x00000D20) DOUT memory DMA busy - indicates that DOUT DMA
                                                                    memory destination is busy                                 */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  DST_LLI_WORD0;                /*!< (@ 0x00000D28) This register is used in direct LLI mode, and
                                                                    holds the location of the data destination
                                                                    in the memory.                                             */
  __IOM uint32_t  DST_LLI_WORD1;                /*!< (@ 0x00000D2C) This register is used in direct LLI mode, and
                                                                    holds the number of bytes to be written
                                                                    to the memory. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IOM uint32_t  SRAM_DEST_ADDR;               /*!< (@ 0x00000D30) Location of data (destination address) to be
                                                                    written to RNG_SRAM. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IOM uint32_t  DOUT_SRAM_BYTES_LEN;          /*!< (@ 0x00000D34) This register holds the size of the data (in
                                                                    bytes) to be written to the RNG_SRAM. Note:
                                                                    This is a special register, affected by
                                                                    internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  DOUT_SRAM_DMA_BUSY;           /*!< (@ 0x00000D38) This register holds the status of the RNG_SRAM
                                                                    DMA DOUT.                                                  */
  __IOM uint32_t  DOUT_SRAM_ENDIANNESS;         /*!< (@ 0x00000D3C) This register defines the endianness of the DOUT
                                                                    interface from RNG_SRAM.                                   */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  READ_ALIGN_LAST;              /*!< (@ 0x00000D44) Indication that the next read from the CPU is
                                                                    the last one. This is needed only when the
                                                                    data size is NOT modulo 4 (e.g. HASH padding).             */
  __IM  uint32_t  RESERVED4[2];
  __IM  uint32_t  DOUT_FIFO_EMPTY;              /*!< (@ 0x00000D50) DOUT FIFO empty indication                                 */
} NRF_CC_DOUT_Type;                             /*!< Size = 3412 (0xd54)                                                       */



/* =========================================================================================================================== */
/* ================                                        CC_GHASH_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL GHASH engine (CC_GHASH_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_GHASH_S Structure                                       */
  __IM  uint32_t  RESERVED[600];
  __OM  uint32_t  GHASH_SUBKEY_0_0;             /*!< (@ 0x00000960) Bits [31:0] of GHASH key 0 (used as the GHASH
                                                                    module key).                                               */
  __OM  uint32_t  GHASH_SUBKEY_0_1;             /*!< (@ 0x00000964) Bits [63:32] of GHASH key 0 (used as the GHASH
                                                                    module key).                                               */
  __OM  uint32_t  GHASH_SUBKEY_0_2;             /*!< (@ 0x00000968) Bits [95:64] of GHASH key 0 (used as the GHASH
                                                                    module key).                                               */
  __OM  uint32_t  GHASH_SUBKEY_0_3;             /*!< (@ 0x0000096C) Bits [127:96] of GHASH key 0 (used as the GHASH
                                                                    module key).                                               */
  __IOM uint32_t  GHASH_IV_0_0;                 /*!< (@ 0x00000970) Bits [31:0] of GHASH_IV0 register. GHASH_IV0
                                                                    is used as the GHASH IV (initialization
                                                                    value) register.                                           */
  __IOM uint32_t  GHASH_IV_0_1;                 /*!< (@ 0x00000974) Bits [63:32] of GHASH_IV0. GHASH_IV0 is used
                                                                    as the GHASH IV (initialization value) register.           */
  __IOM uint32_t  GHASH_IV_0_2;                 /*!< (@ 0x00000978) Bits [95:64] of GHASH_IV0 register. GHASH IV0
                                                                    is used as the GHASH IV (initialization
                                                                    value) register.                                           */
  __IOM uint32_t  GHASH_IV_0_3;                 /*!< (@ 0x0000097C) Bits [127:96] of GHASH_IV0 register. GHASH IV0
                                                                    is used as the GHASH IV (initialization
                                                                    value) register.                                           */
  __IM  uint32_t  GHASH_BUSY;                   /*!< (@ 0x00000980) The GHASH engine busy register. This register
                                                                    is set when the GHASH engine is active.                    */
  __OM  uint32_t  GHASH_INIT;                   /*!< (@ 0x00000984) Initialize the GHASH engine for a new GHASH operation.     */
} NRF_CC_GHASH_Type;                            /*!< Size = 2440 (0x988)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_HASH_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell HASH (CC_HASH_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_HASH_S Structure                                        */
  __IM  uint32_t  RESERVED[400];
  __IOM uint32_t  HASH_H0;                      /*!< (@ 0x00000640) H0 data. Can only be written in the following
                                                                    HASH_CONTROL modes: MD5 SHA1 SHA224 SHA256
                                                                    SHA384 SHA512                                              */
  __IOM uint32_t  HASH_H1;                      /*!< (@ 0x00000644) H1 data. Can only be written in the following
                                                                    HASH_CONTROL modes: MD5 SHA1 SHA224 SHA256
                                                                    SHA384 SHA512                                              */
  __IOM uint32_t  HASH_H2;                      /*!< (@ 0x00000648) H2 data. Can only be written in the following
                                                                    HASH_CONTROL modes: MD5 SHA1 SHA224 SHA256
                                                                    SHA384 SHA512                                              */
  __IOM uint32_t  HASH_H3;                      /*!< (@ 0x0000064C) H3 data. Can only be written in the following
                                                                    HASH_CONTROL modes: MD5 SHA1 SHA224 SHA256
                                                                    SHA384 SHA512                                              */
  __IOM uint32_t  HASH_H4;                      /*!< (@ 0x00000650) H4 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA1 SHA224 SHA256 SHA384
                                                                    SHA512                                                     */
  __IOM uint32_t  HASH_H5;                      /*!< (@ 0x00000654) H5 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256 SHA384
                                                                    SHA512                                                     */
  __IOM uint32_t  HASH_H6;                      /*!< (@ 0x00000658) H6 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256 SHA384
                                                                    SHA512                                                     */
  __IOM uint32_t  HASH_H7;                      /*!< (@ 0x0000065C) H7 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA224 SHA256 SHA384
                                                                    SHA512                                                     */
  __IOM uint32_t  HASH_H8;                      /*!< (@ 0x00000660) H8 data. Can only be written in the following
                                                                    HASH_CONTROL modes: SHA384 SHA512                          */
  __IM  uint32_t  RESERVED1[8];
  __OM  uint32_t  AUTO_HW_PADDING;              /*!< (@ 0x00000684) HW padding automatically activated by engine.
                                                                    For the special case of ZERO bytes data
                                                                    vector this register should not be used.
                                                                    Instead use register HASH_PAD_CFG.                         */
  __IOM uint32_t  HASH_XOR_DIN;                 /*!< (@ 0x00000688) This register is always XOR with the input to
                                                                    the HASH engine. Set to '0' if XOR is not
                                                                    reqiured.                                                  */
  __IM  uint32_t  RESERVED2[2];
  __OM  uint32_t  LOAD_INIT_STATE;              /*!< (@ 0x00000694) Indication to HASH that the following data is
                                                                    to be loaded into initial value registers
                                                                    HASH_H0:HASH_H8 or IV to AES MAC.                          */
  __IM  uint32_t  RESERVED3[3];
  __OM  uint32_t  HASH_SEL_AES_MAC;             /*!< (@ 0x000006A4) Select the HASH or AES MAC module                          */
  __IM  uint32_t  RESERVED4[66];
  __IM  uint32_t  HASH_VERSION;                 /*!< (@ 0x000007B0) Hash version register                                      */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  HASH_CONTROL;                 /*!< (@ 0x000007C0) Hash_control register. selects which hash mode
                                                                    to run                                                     */
  __IOM uint32_t  HASH_PAD_EN;                  /*!< (@ 0x000007C4) This register enables the HASH HW padding.                 */
  __IOM uint32_t  HASH_PAD_CFG;                 /*!< (@ 0x000007C8) HASH_PADP_CFG register. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IOM uint32_t  HASH_CUR_LEN_0;               /*!< (@ 0x000007CC) This register hold the length of current hash
                                                                    operation bit 31:0.                                        */
  __IOM uint32_t  HASH_CUR_LEN_1;               /*!< (@ 0x000007D0) This register hold the length of current hash
                                                                    operation bit 63:32.                                       */
  __IM  uint32_t  RESERVED6[2];
  __IM  uint32_t  HASH_PARAM;                   /*!< (@ 0x000007DC) Hash_param register.                                       */
  __IM  uint32_t  RESERVED7;
  __OM  uint32_t  HASH_AES_SW_RESET;            /*!< (@ 0x000007E4) Hash_aes_sw_reset register.                                */
  __IOM uint32_t  HASH_ENDIANESS;               /*!< (@ 0x000007E8) This register hold the hash_endianess configuration.       */
} NRF_CC_HASH_Type;                             /*!< Size = 2028 (0x7ec)                                                       */



/* =========================================================================================================================== */
/* ================                                       CC_HOST_RGF_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell HOST_RGF (CC_HOST_RGF_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_HOST_RGF_S Structure                                    */
  __IM  uint32_t  RESERVED[640];
  __IM  uint32_t  HOST_RGF_IRR;                 /*!< (@ 0x00000A00) The interrupt request register. Each bit of this
                                                                    register holds the interrupt status of a
                                                                    single interrupt source.                                   */
  __IOM uint32_t  HOST_RGF_IMR;                 /*!< (@ 0x00000A04) The interrupt mask register. Each bit of this
                                                                    register holds the mask of a single interrupt
                                                                    source.                                                    */
  __OM  uint32_t  HOST_RGF_ICR;                 /*!< (@ 0x00000A08) Interrupt clear register.                                  */
  __IOM uint32_t  HOST_RGF_ENDIAN;              /*!< (@ 0x00000A0C) This register defines the endianness of the host-accessible
                                                                    registers. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  HOST_RGF_SIGNATURE;           /*!< (@ 0x00000A24) This register holds the CRYPTOCELL product signature.      */
  __IM  uint32_t  HOST_BOOT;                    /*!< (@ 0x00000A28) This register holds the values of CRYPTOCELL
                                                                    pre-synthesis flags                                        */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  HOST_CRYPTOKEY_SEL;           /*!< (@ 0x00000A38) AES hardware key select. Note: This is a special
                                                                    register, affected by internal logic. Test
                                                                    result of this register is NA.                             */
  __IM  uint32_t  RESERVED3[15];
  __IOM uint32_t  HOST_CORE_CLK_GATING_ENABLE;  /*!< (@ 0x00000A78) This register enables the core clk gating by
                                                                    masking/enabling the cc_idle_state output
                                                                    signal.                                                    */
  __IM  uint32_t  HOST_CC_IS_IDLE;              /*!< (@ 0x00000A7C) This register holds the idle indication of CRYPTOCELL.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IOM uint32_t  HOST_POWERDOWN;               /*!< (@ 0x00000A80) This register start the power-down sequence.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA.                                                     */
  __IM  uint32_t  HOST_REMOVE_GHASH_ENGINE;     /*!< (@ 0x00000A84) Asserted if the GHASH engine has been removed
                                                                    during synthesis These inputs are to be
                                                                    statically tied to 0 or 1 by the customers.
                                                                    When such an input is set, the matching
                                                                    engines inputs are tied to zero and its
                                                                    outputs are disconnected, so that the engine
                                                                    will be entirely removed by synthesis                      */
  __IM  uint32_t  HOST_REMOVE_CHACHA_ENGINE;    /*!< (@ 0x00000A88) Asserted if the CHACHA engine has been removed
                                                                    during synthesis These inputs are to be
                                                                    statically tied to 0 or 1 by the customers.
                                                                    When such an input is set, the matching
                                                                    engines inputs are tied to zero and its
                                                                    outputs are disconnected, so that the engine
                                                                    will be entirely removed by synthesis                      */
} NRF_CC_HOST_RGF_Type;                         /*!< Size = 2700 (0xa8c)                                                       */



/* =========================================================================================================================== */
/* ================                                      CC_HOST_SRAM_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell HOST_SRAM (CC_HOST_SRAM_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_HOST_SRAM_S Structure                                   */
  __IM  uint32_t  RESERVED[960];
  __IOM uint32_t  SRAM_DATA;                    /*!< (@ 0x00000F00) Read and write data from RNG_SRAM. Note: This
                                                                    is a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __OM  uint32_t  SRAM_ADDR;                    /*!< (@ 0x00000F04) First address given to RNG_SRAM DMA for read/write
                                                                    transactions from RNG_SRAM.                                */
  __IM  uint32_t  SRAM_DATA_READY;              /*!< (@ 0x00000F08) The RNG_SRAM content is ready for read in SRAM_DATA.       */
} NRF_CC_HOST_SRAM_Type;                        /*!< Size = 3852 (0xf0c)                                                       */



/* =========================================================================================================================== */
/* ================                                     CC_ID_REGISTERS_S                                     ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell ID_REGISTERS (CC_ID_REGISTERS_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_ID_REGISTERS_S Structure                                */
  __IM  uint32_t  RESERVED[1012];
  __IM  uint32_t  PERIPHERAL_ID_4;              /*!< (@ 0x00000FD0) No register description provided                           */
  __IM  uint32_t  PIDRESERVED0;                 /*!< (@ 0x00000FD4) No register description provided                           */
  __IM  uint32_t  PIDRESERVED1;                 /*!< (@ 0x00000FD8) No register description provided                           */
  __IM  uint32_t  PIDRESERVED2;                 /*!< (@ 0x00000FDC) No register description provided                           */
  __IM  uint32_t  PERIPHERAL_ID_0;              /*!< (@ 0x00000FE0) No register description provided                           */
  __IM  uint32_t  PERIPHERAL_ID_1;              /*!< (@ 0x00000FE4) No register description provided                           */
  __IM  uint32_t  PERIPHERAL_ID_2;              /*!< (@ 0x00000FE8) No register description provided                           */
  __IM  uint32_t  PERIPHERAL_ID_3;              /*!< (@ 0x00000FEC) No register description provided                           */
  __IM  uint32_t  COMPONENT_ID_0;               /*!< (@ 0x00000FF0) No register description provided                           */
  __IM  uint32_t  COMPONENT_ID_1;               /*!< (@ 0x00000FF4) No register description provided                           */
  __IM  uint32_t  COMPONENT_ID_2;               /*!< (@ 0x00000FF8) No register description provided                           */
  __IM  uint32_t  COMPONENT_ID_3;               /*!< (@ 0x00000FFC) No register description provided                           */
} NRF_CC_ID_REGISTERS_Type;                     /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         CC_MISC_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell MISC (CC_MISC_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_MISC_S Structure                                        */
  __IM  uint32_t  RESERVED[516];
  __IOM uint32_t  AES_CLK_ENABLE;               /*!< (@ 0x00000810) The AES clock enable register. Note: this is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  HASH_CLK_ENABLE;              /*!< (@ 0x00000818) The HASH clock enable register. Note: this is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  PKA_CLK_ENABLE;               /*!< (@ 0x0000081C) The PKA clock enable register. Note: this is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IOM uint32_t  DMA_CLK_ENABLE;               /*!< (@ 0x00000820) The DMA clock enable register. Note: this is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IM  uint32_t  CLK_STATUS;                   /*!< (@ 0x00000824) The CRYPTOCELL clock status register. Note: this
                                                                    is a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IM  uint32_t  RESERVED2[12];
  __OM  uint32_t  CHACHA_CLK_ENABLE;            /*!< (@ 0x00000858) CHACHA / SALSA clock enable register. Note: this
                                                                    is a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
} NRF_CC_MISC_Type;                             /*!< Size = 2140 (0x85c)                                                       */



/* =========================================================================================================================== */
/* ================                                         CC_NVM_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell NVM (CC_NVM_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_NVM_S Structure                                         */
  __IM  uint32_t  RESERVED[1985];
  __IM  uint32_t  AIB_FUSE_PROG_COMPLETED;      /*!< (@ 0x00001F04) This register reflects the FUSE_AIB_PROG_COMPLETED
                                                                    input, which indicates that the fuse programming
                                                                    was completed. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  NVM_DEBUG_STATUS;             /*!< (@ 0x00001F08) NVM FSM debug status register. Note: This is
                                                                    a special register, affected by internal
                                                                    logic. Test result of this register is NA.                 */
  __IM  uint32_t  LCS_IS_VALID;                 /*!< (@ 0x00001F0C) Indicates that the LCS register holds a valid
                                                                    value. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  NVM_IS_IDLE;                  /*!< (@ 0x00001F10) Indicates that the LCS register holds a valid
                                                                    value. Note: This is a special register,
                                                                    affected by internal logic. Test result
                                                                    of this register is NA.                                    */
  __IM  uint32_t  LCS_REG;                      /*!< (@ 0x00001F14) The lifecycle state register. Note: This is a
                                                                    special register, affected by internal logic.
                                                                    Test result of this register is NA.                        */
  __OM  uint32_t  HOST_SHADOW_KDR_REG;          /*!< (@ 0x00001F18) This register interface is used to update the
                                                                    KDR registers when the device LCS is in
                                                                    CM or DM mode. Register is write-once (per
                                                                    warm boot) in LCS=RMA. The KDR is updated
                                                                    by shifting.                                               */
  __OM  uint32_t  HOST_SHADOW_KCP_REG;          /*!< (@ 0x00001F1C) This register interface is used to update the
                                                                    KCP registers when the device LCS is in
                                                                    CM or DM mode. The KCP is updated by shifting.             */
  __OM  uint32_t  HOST_SHADOW_KCE_REG;          /*!< (@ 0x00001F20) This register interface is used to update the
                                                                    KCE registers when the device LCS is in
                                                                    CM or DM mode. The KCE is updated by shifting.             */
  __OM  uint32_t  HOST_SHADOW_KPICV_REG;        /*!< (@ 0x00001F24) This register interface is used to update the
                                                                    KPICV registers when the device LCS is in
                                                                    CM or DM mode. The KPICV is updated by shifting.           */
  __OM  uint32_t  HOST_SHADOW_KCEICV_REG;       /*!< (@ 0x00001F28) This register interface is used to update the
                                                                    KCEICV registers when the device LCS is
                                                                    in CM or DM mode. The KCEICV is updated
                                                                    by shifting.                                               */
  __IM  uint32_t  OTP_ADDR_WIDTH_DEF;           /*!< (@ 0x00001F2C) Define the integrated OTP address width in words.
                                                                    Note: This is a special register, affected
                                                                    by internal logic. Test result of this register
                                                                    is NA. The supported sizes are 6 (for 2
                                                                    kbits), and 7,8,9,11 (for 64 kbits). The
                                                                    default value in the provided RTL will be
                                                                    6.                                                         */
} NRF_CC_NVM_Type;                              /*!< Size = 7984 (0x1f30)                                                      */



/* =========================================================================================================================== */
/* ================                                         CC_PKA_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell PKA (CC_PKA_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_PKA_S Structure                                         */
  __IOM uint32_t  MEMORY_MAP0;                  /*!< (@ 0x00000000) This register maps the virtual register r0 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP1;                  /*!< (@ 0x00000004) This register maps the virtual register r1 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP2;                  /*!< (@ 0x00000008) This register maps the virtual register r2 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP3;                  /*!< (@ 0x0000000C) This register maps the virtual register r3 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP4;                  /*!< (@ 0x00000010) This register maps the virtual register r4 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP5;                  /*!< (@ 0x00000014) This register maps the virtual register r5 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP6;                  /*!< (@ 0x00000018) This register maps the virtual register r6 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP7;                  /*!< (@ 0x0000001C) This register maps the virtual register r7 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP8;                  /*!< (@ 0x00000020) This register maps the virtual register r8 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP9;                  /*!< (@ 0x00000024) This register maps the virtual register r9 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP10;                 /*!< (@ 0x00000028) This register maps the virtual register r10 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP11;                 /*!< (@ 0x0000002C) This register maps the virtual register r11 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP12;                 /*!< (@ 0x00000030) This register maps the virtual register r12 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP13;                 /*!< (@ 0x00000034) This register maps the virtual register r13 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP14;                 /*!< (@ 0x00000038) This register maps the virtual register r14 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP15;                 /*!< (@ 0x0000003C) This register maps the virtual register r15 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP16;                 /*!< (@ 0x00000040) This register maps the virtual register r16 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP17;                 /*!< (@ 0x00000044) This register maps the virtual register r17 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP18;                 /*!< (@ 0x00000048) This register maps the virtual register r18 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP19;                 /*!< (@ 0x0000004C) This register maps the virtual register r19 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP20;                 /*!< (@ 0x00000050) This register maps the virtual register r20 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP21;                 /*!< (@ 0x00000054) This register maps the virtual register r21 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP22;                 /*!< (@ 0x00000058) This register maps the virtual register r22 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP23;                 /*!< (@ 0x0000005C) This register maps the virtual register r23 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP24;                 /*!< (@ 0x00000060) This register maps the virtual register r24 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP25;                 /*!< (@ 0x00000064) This register maps the virtual register r25 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP26;                 /*!< (@ 0x00000068) This register maps the virtual register r26 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP27;                 /*!< (@ 0x0000006C) This register maps the virtual register r27 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP28;                 /*!< (@ 0x00000070) This register maps the virtual register r28 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP29;                 /*!< (@ 0x00000074) This register maps the virtual register r29 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP30;                 /*!< (@ 0x00000078) This register maps the virtual register r30 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  MEMORY_MAP31;                 /*!< (@ 0x0000007C) This register maps the virtual register r31 to
                                                                    a physical address in memory.                              */
  __IOM uint32_t  OPCODE;                       /*!< (@ 0x00000080) This register holds the PKA opcode.                        */
  __IOM uint32_t  N_NP_T0_T1_ADDR;              /*!< (@ 0x00000084) This register maps n_np_t0_t1 to a virtual address.        */
  __IM  uint32_t  PKA_STATUS;                   /*!< (@ 0x00000088) This register holds the pka pipe status.                   */
  __OM  uint32_t  PKA_SW_RESET;                 /*!< (@ 0x0000008C) Writing to this register triggers a software
                                                                    reset of the pka.                                          */
  __IOM uint32_t  PKA_L0;                       /*!< (@ 0x00000090) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L1;                       /*!< (@ 0x00000094) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L2;                       /*!< (@ 0x00000098) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L3;                       /*!< (@ 0x0000009C) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L4;                       /*!< (@ 0x000000A0) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L5;                       /*!< (@ 0x000000A4) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L6;                       /*!< (@ 0x000000A8) This register holds the size of the operation.             */
  __IOM uint32_t  PKA_L7;                       /*!< (@ 0x000000AC) This register holds the size of the operation.             */
  __IM  uint32_t  PKA_PIPE_RDY;                 /*!< (@ 0x000000B0) This register indicates whether the PKA pipe
                                                                    is ready to receive a new OPCODE.                          */
  __IM  uint32_t  PKA_DONE;                     /*!< (@ 0x000000B4) This register indicates whether PKA operation
                                                                    is completed.                                              */
  __IOM uint32_t  PKA_MON_SELECT;               /*!< (@ 0x000000B8) This register defines which PKA FSM monitor is
                                                                    being output.                                              */
  __IM  uint32_t  RESERVED[2];
  __IM  uint32_t  PKA_VERSION;                  /*!< (@ 0x000000C4) This register holds the PKA version                        */
  __IM  uint32_t  RESERVED1[2];
  __IM  uint32_t  PKA_MON_READ;                 /*!< (@ 0x000000D0) The PKA monitor bus register.                              */
  __OM  uint32_t  PKA_SRAM_ADDR;                /*!< (@ 0x000000D4) First address given to PKA SRAM for write transactions.    */
  __OM  uint32_t  PKA_SRAM_WDATA;               /*!< (@ 0x000000D8) Write data to PKA SRAM.                                    */
  __IOM uint32_t  PKA_SRAM_RDATA;               /*!< (@ 0x000000DC) Read data from PKA SRAM.                                   */
  __OM  uint32_t  PKA_SRAM_WR_CLR;              /*!< (@ 0x000000E0) Write buffer clean.                                        */
  __OM  uint32_t  PKA_SRAM_RADDR;               /*!< (@ 0x000000E4) First address given to PKA SRAM for read transactions.     */
  __IM  uint32_t  RESERVED2[2];
  __OM  uint32_t  PKA_WORD_ACCESS;              /*!< (@ 0x000000F0) This register holds data to write to or read
                                                                    from the PKA when using special read or
                                                                    write word operation.                                      */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  PKA_BUFF_ADDR;                /*!< (@ 0x000000F8) This register maps the virtual buffer registers
                                                                    to a physical address in memory.                           */
} NRF_CC_PKA_Type;                              /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                         CC_RNG_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell RNG (CC_RNG_S)
  */

typedef struct {                                /*!< (@ 0x50845000) CC_RNG_S Structure                                         */
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  RNG_IMR;                      /*!< (@ 0x00000100) Interrupt masking register. Consists of PRNG_IMR[31:16]
                                                                    and TRNG_IMR[15:0]. (PRNG bits exists only
                                                                    if PRNG_EXISTS flag is set)                                */
  __IM  uint32_t  RNG_ISR;                      /*!< (@ 0x00000104) Status register. If corresponding RNG_IMR bit
                                                                    is unmasked, an interrupt is generated.
                                                                    Consists of PRNG_ISR[31:16] and TRNG_ISR[15:0].            */
  __OM  uint32_t  RNG_ICR;                      /*!< (@ 0x00000108) Interrupt/status bit clear register. Consists
                                                                    of PRNG_ICR[31:16] and TRNG_ICR[15:0].                     */
  __IOM uint32_t  TRNG_CONFIG;                  /*!< (@ 0x0000010C) This register handles TRNG configuration                   */
  __IM  uint32_t  TRNG_VALID;                   /*!< (@ 0x00000110) This register indicates that the trng data is
                                                                    valid.                                                     */
  __IM  uint32_t  EHR_DATA_0;                   /*!< (@ 0x00000114) This register contains the data collected in
                                                                    the TRNG[31:0]. Note: can only be set if
                                                                    the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set).                                                   */
  __IM  uint32_t  EHR_DATA_1;                   /*!< (@ 0x00000118) This register contains the data collected in
                                                                    the TRNG[63:32]. Note: can only be set if
                                                                    the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set)                                                    */
  __IM  uint32_t  EHR_DATA_2;                   /*!< (@ 0x0000011C) This register contains the data collected in
                                                                    the trng[95_64]. Note: can only be set if
                                                                    the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set).                                                   */
  __IM  uint32_t  EHR_DATA_3;                   /*!< (@ 0x00000120) This register contains the data collected in
                                                                    the trng[127_96]. Note: can only be set
                                                                    if the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set).                                                   */
  __IM  uint32_t  EHR_DATA_4;                   /*!< (@ 0x00000124) This register contains the data collected in
                                                                    the trng[159_128]. Note: can only be set
                                                                    if the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set).                                                   */
  __IM  uint32_t  EHR_DATA_5;                   /*!< (@ 0x00000128) This register contains the data collected in
                                                                    the trng[191_160]. Note: can only be set
                                                                    if the RNG engine is in debug mode (RNG_DEBUG_EN_INPUT
                                                                    is set).                                                   */
  __IOM uint32_t  RND_SOURCE_ENABLE;            /*!< (@ 0x0000012C) This register holds the enable signal for the
                                                                    random source.                                             */
  __IOM uint32_t  SAMPLE_CNT1;                  /*!< (@ 0x00000130) Number of clock cycles between sampling of a
                                                                    random bit.                                                */
  __IOM uint32_t  AUTOCORR_STATISTIC;           /*!< (@ 0x00000134) Statistics about autocorrelation test activations.         */
  __IOM uint32_t  TRNG_DEBUG_CONTROL;           /*!< (@ 0x00000138) This register is used to debug the trng                    */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  RNG_SW_RESET;                 /*!< (@ 0x00000140) Generate a reset for the RNG engine.                       */
  __IM  uint32_t  RESERVED2[28];
  __IM  uint32_t  RNG_DEBUG_EN_INPUT;           /*!< (@ 0x000001B4) Reflects if RNG engine debug mode is enabled               */
  __IM  uint32_t  RNG_BUSY;                     /*!< (@ 0x000001B8) Rng busy indication                                        */
  __OM  uint32_t  RST_BITS_COUNTER;             /*!< (@ 0x000001BC) Resets the counter of collected bits in the TRNG.          */
  __IM  uint32_t  RNG_VERSION;                  /*!< (@ 0x000001C0) This register holds the RNG version                        */
  __OM  uint32_t  RNG_CLK_ENABLE;               /*!< (@ 0x000001C4) Writing to this register enables/disables the
                                                                    RNG clock.                                                 */
  __IOM uint32_t  RNG_DMA_ENABLE;               /*!< (@ 0x000001C8) Writing to this register enables/disables the
                                                                    RNG DMA.                                                   */
  __IOM uint32_t  RNG_DMA_SRC_MASK;             /*!< (@ 0x000001CC) This register defines which ring-oscillator length
                                                                    should be used when using the RNG DMA.                     */
  __IOM uint32_t  RNG_DMA_SRAM_ADDR;            /*!< (@ 0x000001D0) This register defines the start address of the
                                                                    DMA for the TRNG data.                                     */
  __IOM uint32_t  RNG_DMA_SAMPLES_NUM;          /*!< (@ 0x000001D4) This register defines the number of 192-bits
                                                                    samples that the DMA collects per RNG configuration.       */
  __IOM uint32_t  RNG_WATCHDOG_VAL;             /*!< (@ 0x000001D8) This register defines the maximum number of clock
                                                                    cycles per TRNG collection of 192 samples.
                                                                    If the number of cycles for a collection
                                                                    exceeds this threshold, TRNG signals an
                                                                    interrupt.                                                 */
  __IM  uint32_t  RNG_DMA_STATUS;               /*!< (@ 0x000001DC) This register holds the RNG DMA status.                    */
} NRF_CC_RNG_Type;                              /*!< Size = 480 (0x1e0)                                                        */



/* =========================================================================================================================== */
/* ================                                          VMC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Volatile Memory controller 0 (VMC_NS)
  */

typedef struct {                                /*!< (@ 0x40081000) VMC_NS Structure                                           */
  __IM  uint32_t  RESERVED[384];
  __IOM VMC_RAM_Type RAM[8];                    /*!< (@ 0x00000600) Unspecified                                                */
} NRF_VMC_Type;                                 /*!< Size = 1664 (0x680)                                                       */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_CACHEDATA_S_BASE        0x00F00000UL
#define NRF_CACHEINFO_S_BASE        0x00F08000UL
#define NRF_FICR_S_BASE             0x00FF0000UL
#define NRF_UICR_S_BASE             0x00FF8000UL
#define NRF_PCGCMASTER_CM4SS_S_BASE 0x50002000UL
#define NRF_GPIOCONFIG_S_BASE       0x50042000UL
#define NRF_PCGCMASTER_APPMAIN_S_BASE 0x50100000UL
#define NRF_PCGCMASTER_APPMCU_S_BASE 0x50101000UL
#define NRF_PCGCSLAVE0_S_BASE       0x50102000UL
#define NRF_INFOCONF_S_BASE         0x50104000UL
#define NRF_PPIMATRIX_MCU_S_BASE    0x50105000UL
#define NRF_WAKEUPPDTIMERS_S_BASE   0x50106000UL
#define NRF_POWERSWITCH_SLAVE_S_BASE 0x50107000UL
#define NRF_PCGCSLAVE_RAMBISTHUB_S_BASE 0x50108000UL
#define NRF_RAMBISTHUB_S_BASE       0x50108000UL
#define NRF_PCGCSLAVE_AMLI_S_BASE   0x50109000UL
#define NRF_PCGCSLAVE_RESETHANDLER_S_BASE 0x5010A000UL
#define NRF_PCGCSLAVE_APPMAIN_S_BASE 0x5010B000UL
#define NRF_APBWUP_TIMER_S_BASE     0x50200000UL
#define NRF_PCGCMASTER_PERMCU_S_BASE 0x50201000UL
#define NRF_PCGCMASTER_PERMAIN_S_BASE 0x50202000UL
#define NRF_PCGCMASTER_TIMERS_S_BASE 0x50203000UL
#define NRF_PPIMATRIX_TIMERS_S_BASE 0x50204000UL
#define NRF_PPIMATRIX_PERIPHERALS_S_BASE 0x50205000UL
#define NRF_PPIMATRIX_IPC_S_BASE    0x50206000UL
#define NRF_APBWUP_IPC_S_BASE       0x50207000UL
#define NRF_PCGCMASTER_PAC_S_BASE   0x50300000UL
#define NRF_CTI_S_BASE              0xE0042000UL
#define NRF_TAD_S_BASE              0xE0080000UL
#define NRF_AMLI_NS_BASE            0x40000000UL
#define NRF_DCNF_NS_BASE            0x40000000UL
#define NRF_FPU_NS_BASE             0x40000000UL
#define NRF_AMLI_S_BASE             0x50000000UL
#define NRF_DCNF_S_BASE             0x50000000UL
#define NRF_FPU_S_BASE              0x50000000UL
#define NRF_CACHE_S_BASE            0x50001000UL
#define NRF_SPU_S_BASE              0x50003000UL
#define NRF_OSCILLATORS_NS_BASE     0x40004000UL
#define NRF_REGULATORS_NS_BASE      0x40004000UL
#define NRF_OSCILLATORS_S_BASE      0x50004000UL
#define NRF_REGULATORS_S_BASE       0x50004000UL
#define NRF_CLOCK_NS_BASE           0x40005000UL
#define NRF_POWER_NS_BASE           0x40005000UL
#define NRF_RESET_NS_BASE           0x40005000UL
#define NRF_CLOCK_S_BASE            0x50005000UL
#define NRF_POWER_S_BASE            0x50005000UL
#define NRF_RESET_S_BASE            0x50005000UL
#define NRF_CTRLAP_NS_BASE          0x40006000UL
#define NRF_CTRLAP_S_BASE           0x50006000UL
#define NRF_PAMLI_NS_BASE           0x40007000UL
#define NRF_PAMLI_S_BASE            0x50007000UL
#define NRF_SPI0_NS_BASE            0x40008000UL
#define NRF_SPIM0_NS_BASE           0x40008000UL
#define NRF_SPIS0_NS_BASE           0x40008000UL
#define NRF_TWI0_NS_BASE            0x40008000UL
#define NRF_TWIM0_NS_BASE           0x40008000UL
#define NRF_TWIS0_NS_BASE           0x40008000UL
#define NRF_UART0_NS_BASE           0x40008000UL
#define NRF_UARTE0_NS_BASE          0x40008000UL
#define NRF_SPI0_S_BASE             0x50008000UL
#define NRF_SPIM0_S_BASE            0x50008000UL
#define NRF_SPIS0_S_BASE            0x50008000UL
#define NRF_TWI0_S_BASE             0x50008000UL
#define NRF_TWIM0_S_BASE            0x50008000UL
#define NRF_TWIS0_S_BASE            0x50008000UL
#define NRF_UART0_S_BASE            0x50008000UL
#define NRF_UARTE0_S_BASE           0x50008000UL
#define NRF_SPI1_NS_BASE            0x40009000UL
#define NRF_SPIM1_NS_BASE           0x40009000UL
#define NRF_SPIS1_NS_BASE           0x40009000UL
#define NRF_TWI1_NS_BASE            0x40009000UL
#define NRF_TWIM1_NS_BASE           0x40009000UL
#define NRF_TWIS1_NS_BASE           0x40009000UL
#define NRF_UART1_NS_BASE           0x40009000UL
#define NRF_UARTE1_NS_BASE          0x40009000UL
#define NRF_SPI1_S_BASE             0x50009000UL
#define NRF_SPIM1_S_BASE            0x50009000UL
#define NRF_SPIS1_S_BASE            0x50009000UL
#define NRF_TWI1_S_BASE             0x50009000UL
#define NRF_TWIM1_S_BASE            0x50009000UL
#define NRF_TWIS1_S_BASE            0x50009000UL
#define NRF_UART1_S_BASE            0x50009000UL
#define NRF_UARTE1_S_BASE           0x50009000UL
#define NRF_SPIM4_NS_BASE           0x4000A000UL
#define NRF_SPIM4_S_BASE            0x5000A000UL
#define NRF_SPI2_NS_BASE            0x4000B000UL
#define NRF_SPIM2_NS_BASE           0x4000B000UL
#define NRF_SPIS2_NS_BASE           0x4000B000UL
#define NRF_TWI2_NS_BASE            0x4000B000UL
#define NRF_TWIM2_NS_BASE           0x4000B000UL
#define NRF_TWIS2_NS_BASE           0x4000B000UL
#define NRF_UART2_NS_BASE           0x4000B000UL
#define NRF_UARTE2_NS_BASE          0x4000B000UL
#define NRF_SPI2_S_BASE             0x5000B000UL
#define NRF_SPIM2_S_BASE            0x5000B000UL
#define NRF_SPIS2_S_BASE            0x5000B000UL
#define NRF_TWI2_S_BASE             0x5000B000UL
#define NRF_TWIM2_S_BASE            0x5000B000UL
#define NRF_TWIS2_S_BASE            0x5000B000UL
#define NRF_UART2_S_BASE            0x5000B000UL
#define NRF_UARTE2_S_BASE           0x5000B000UL
#define NRF_SPI3_NS_BASE            0x4000C000UL
#define NRF_SPIM3_NS_BASE           0x4000C000UL
#define NRF_SPIS3_NS_BASE           0x4000C000UL
#define NRF_TWI3_NS_BASE            0x4000C000UL
#define NRF_TWIM3_NS_BASE           0x4000C000UL
#define NRF_TWIS3_NS_BASE           0x4000C000UL
#define NRF_UART3_NS_BASE           0x4000C000UL
#define NRF_UARTE3_NS_BASE          0x4000C000UL
#define NRF_SPI3_S_BASE             0x5000C000UL
#define NRF_SPIM3_S_BASE            0x5000C000UL
#define NRF_SPIS3_S_BASE            0x5000C000UL
#define NRF_TWI3_S_BASE             0x5000C000UL
#define NRF_TWIM3_S_BASE            0x5000C000UL
#define NRF_TWIS3_S_BASE            0x5000C000UL
#define NRF_UART3_S_BASE            0x5000C000UL
#define NRF_UARTE3_S_BASE           0x5000C000UL
#define NRF_GPIOTE0_S_BASE          0x5000D000UL
#define NRF_SAADC_NS_BASE           0x4000E000UL
#define NRF_SAADC_S_BASE            0x5000E000UL
#define NRF_TIMER0_NS_BASE          0x4000F000UL
#define NRF_TIMER0_S_BASE           0x5000F000UL
#define NRF_TIMER1_NS_BASE          0x40010000UL
#define NRF_TIMER1_S_BASE           0x50010000UL
#define NRF_TIMER2_NS_BASE          0x40011000UL
#define NRF_TIMER2_S_BASE           0x50011000UL
#define NRF_RTC0_NS_BASE            0x40014000UL
#define NRF_RTC0_S_BASE             0x50014000UL
#define NRF_RTC1_NS_BASE            0x40015000UL
#define NRF_RTC1_S_BASE             0x50015000UL
#define NRF_DPPIC_NS_BASE           0x40017000UL
#define NRF_DPPIC_S_BASE            0x50017000UL
#define NRF_WDT0_NS_BASE            0x40018000UL
#define NRF_WDT0_S_BASE             0x50018000UL
#define NRF_WDT1_NS_BASE            0x40019000UL
#define NRF_WDT1_S_BASE             0x50019000UL
#define NRF_COMP_NS_BASE            0x4001A000UL
#define NRF_LPCOMP_NS_BASE          0x4001A000UL
#define NRF_COMP_S_BASE             0x5001A000UL
#define NRF_LPCOMP_S_BASE           0x5001A000UL
#define NRF_EGU0_NS_BASE            0x4001B000UL
#define NRF_EGU0_S_BASE             0x5001B000UL
#define NRF_EGU1_NS_BASE            0x4001C000UL
#define NRF_EGU1_S_BASE             0x5001C000UL
#define NRF_EGU2_NS_BASE            0x4001D000UL
#define NRF_EGU2_S_BASE             0x5001D000UL
#define NRF_EGU3_NS_BASE            0x4001E000UL
#define NRF_EGU3_S_BASE             0x5001E000UL
#define NRF_EGU4_NS_BASE            0x4001F000UL
#define NRF_EGU4_S_BASE             0x5001F000UL
#define NRF_EGU5_NS_BASE            0x40020000UL
#define NRF_EGU5_S_BASE             0x50020000UL
#define NRF_PWM0_NS_BASE            0x40021000UL
#define NRF_PWM0_S_BASE             0x50021000UL
#define NRF_PWM1_NS_BASE            0x40022000UL
#define NRF_PWM1_S_BASE             0x50022000UL
#define NRF_PWM2_NS_BASE            0x40023000UL
#define NRF_PWM2_S_BASE             0x50023000UL
#define NRF_PWM3_NS_BASE            0x40024000UL
#define NRF_PWM3_S_BASE             0x50024000UL
#define NRF_PDM0_NS_BASE            0x40026000UL
#define NRF_PDM0_S_BASE             0x50026000UL
#define NRF_I2S0_NS_BASE            0x40028000UL
#define NRF_I2S0_S_BASE             0x50028000UL
#define NRF_IPC_NS_BASE             0x4002A000UL
#define NRF_IPC_S_BASE              0x5002A000UL
#define NRF_QSPI_NS_BASE            0x4002B000UL
#define NRF_QSPI_S_BASE             0x5002B000UL
#define NRF_NFCT_NS_BASE            0x4002D000UL
#define NRF_NFCT_S_BASE             0x5002D000UL
#define NRF_GPIOTE1_NS_BASE         0x4002F000UL
#define NRF_MUTEX_NS_BASE           0x40030000UL
#define NRF_MUTEX_S_BASE            0x50030000UL
#define NRF_RAMTRIM0_NS_BASE        0x40031000UL
#define NRF_RAMTRIM0_S_BASE         0x50031000UL
#define NRF_RCOSC32K_NS_BASE        0x40032000UL
#define NRF_RCOSC32K_S_BASE         0x50032000UL
#define NRF_QDEC0_NS_BASE           0x40033000UL
#define NRF_QDEC0_S_BASE            0x50033000UL
#define NRF_QDEC1_NS_BASE           0x40034000UL
#define NRF_QDEC1_S_BASE            0x50034000UL
#define NRF_USBD_NS_BASE            0x40036000UL
#define NRF_USBD_S_BASE             0x50036000UL
#define NRF_USBREGULATOR_NS_BASE    0x40037000UL
#define NRF_USBREGULATOR_S_BASE     0x50037000UL
#define NRF_VFSCTRL_S_BASE          0x50038000UL
#define NRF_KMU_NS_BASE             0x40039000UL
#define NRF_NVMC_NS_BASE            0x40039000UL
#define NRF_KMU_S_BASE              0x50039000UL
#define NRF_NVMC_S_BASE             0x50039000UL
#define NRF_P0_NS_BASE              0x40842500UL
#define NRF_P1_NS_BASE              0x40842800UL
#define NRF_P0_S_BASE               0x50842500UL
#define NRF_GPIOINTERNAL_NS_BASE    0x50842800UL
#define NRF_GPIOINTERNAL_S_BASE     0x50842800UL
#define NRF_P1_S_BASE               0x50842800UL
#define NRF_CRYPTOCELL_S_BASE       0x50844000UL
#define NRF_CC_AES_S_BASE           0x50845000UL
#define NRF_CC_AHB_S_BASE           0x50845000UL
#define NRF_CC_AO_S_BASE            0x50845000UL
#define NRF_CC_CHACHA_S_BASE        0x50845000UL
#define NRF_CC_CTL_S_BASE           0x50845000UL
#define NRF_CC_DIN_S_BASE           0x50845000UL
#define NRF_CC_DOUT_S_BASE          0x50845000UL
#define NRF_CC_GHASH_S_BASE         0x50845000UL
#define NRF_CC_HASH_S_BASE          0x50845000UL
#define NRF_CC_HOST_RGF_S_BASE      0x50845000UL
#define NRF_CC_HOST_SRAM_S_BASE     0x50845000UL
#define NRF_CC_ID_REGISTERS_S_BASE  0x50845000UL
#define NRF_CC_MISC_S_BASE          0x50845000UL
#define NRF_CC_NVM_S_BASE           0x50845000UL
#define NRF_CC_PKA_S_BASE           0x50845000UL
#define NRF_CC_RNG_S_BASE           0x50845000UL
#define NRF_VMC_NS_BASE             0x40081000UL
#define NRF_VMC_S_BASE              0x50081000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_CACHEDATA_S             ((NRF_CACHEDATA_Type*)     NRF_CACHEDATA_S_BASE)
#define NRF_CACHEINFO_S             ((NRF_CACHEINFO_Type*)     NRF_CACHEINFO_S_BASE)
#define NRF_FICR_S                  ((NRF_FICR_Type*)          NRF_FICR_S_BASE)
#define NRF_UICR_S                  ((NRF_UICR_Type*)          NRF_UICR_S_BASE)
#define NRF_PCGCMASTER_CM4SS_S      ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_CM4SS_S_BASE)
#define NRF_GPIOCONFIG_S            ((NRF_PCGCSLAVE_Type*)     NRF_GPIOCONFIG_S_BASE)
#define NRF_PCGCMASTER_APPMAIN_S    ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_APPMAIN_S_BASE)
#define NRF_PCGCMASTER_APPMCU_S     ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_APPMCU_S_BASE)
#define NRF_PCGCSLAVE0_S            ((NRF_PCGCSLAVE_Type*)     NRF_PCGCSLAVE0_S_BASE)
#define NRF_INFOCONF_S              ((NRF_PCGCSLAVE_Type*)     NRF_INFOCONF_S_BASE)
#define NRF_PPIMATRIX_MCU_S         ((NRF_PCGCSLAVE_Type*)     NRF_PPIMATRIX_MCU_S_BASE)
#define NRF_WAKEUPPDTIMERS_S        ((NRF_PCGCSLAVE_Type*)     NRF_WAKEUPPDTIMERS_S_BASE)
#define NRF_POWERSWITCH_SLAVE_S     ((NRF_PCGCSLAVE_Type*)     NRF_POWERSWITCH_SLAVE_S_BASE)
#define NRF_PCGCSLAVE_RAMBISTHUB_S  ((NRF_PCGCSLAVE_Type*)     NRF_PCGCSLAVE_RAMBISTHUB_S_BASE)
#define NRF_RAMBISTHUB_S            ((NRF_RAMBISTHUB_Type*)    NRF_RAMBISTHUB_S_BASE)
#define NRF_PCGCSLAVE_AMLI_S        ((NRF_PCGCSLAVE_Type*)     NRF_PCGCSLAVE_AMLI_S_BASE)
#define NRF_PCGCSLAVE_RESETHANDLER_S ((NRF_PCGCSLAVE_Type*)    NRF_PCGCSLAVE_RESETHANDLER_S_BASE)
#define NRF_PCGCSLAVE_APPMAIN_S     ((NRF_PCGCSLAVE_Type*)     NRF_PCGCSLAVE_APPMAIN_S_BASE)
#define NRF_APBWUP_TIMER_S          ((NRF_PCGCSLAVE_Type*)     NRF_APBWUP_TIMER_S_BASE)
#define NRF_PCGCMASTER_PERMCU_S     ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_PERMCU_S_BASE)
#define NRF_PCGCMASTER_PERMAIN_S    ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_PERMAIN_S_BASE)
#define NRF_PCGCMASTER_TIMERS_S     ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_TIMERS_S_BASE)
#define NRF_PPIMATRIX_TIMERS_S      ((NRF_PCGCSLAVE_Type*)     NRF_PPIMATRIX_TIMERS_S_BASE)
#define NRF_PPIMATRIX_PERIPHERALS_S ((NRF_PCGCSLAVE_Type*)     NRF_PPIMATRIX_PERIPHERALS_S_BASE)
#define NRF_PPIMATRIX_IPC_S         ((NRF_PCGCSLAVE_Type*)     NRF_PPIMATRIX_IPC_S_BASE)
#define NRF_APBWUP_IPC_S            ((NRF_PCGCSLAVE_Type*)     NRF_APBWUP_IPC_S_BASE)
#define NRF_PCGCMASTER_PAC_S        ((NRF_PCGCMASTER_Type*)    NRF_PCGCMASTER_PAC_S_BASE)
#define NRF_CTI_S                   ((NRF_CTI_Type*)           NRF_CTI_S_BASE)
#define NRF_TAD_S                   ((NRF_TAD_Type*)           NRF_TAD_S_BASE)
#define NRF_AMLI_NS                 ((NRF_AMLI_Type*)          NRF_AMLI_NS_BASE)
#define NRF_DCNF_NS                 ((NRF_DCNF_Type*)          NRF_DCNF_NS_BASE)
#define NRF_FPU_NS                  ((NRF_FPU_Type*)           NRF_FPU_NS_BASE)
#define NRF_AMLI_S                  ((NRF_AMLI_Type*)          NRF_AMLI_S_BASE)
#define NRF_DCNF_S                  ((NRF_DCNF_Type*)          NRF_DCNF_S_BASE)
#define NRF_FPU_S                   ((NRF_FPU_Type*)           NRF_FPU_S_BASE)
#define NRF_CACHE_S                 ((NRF_CACHE_Type*)         NRF_CACHE_S_BASE)
#define NRF_SPU_S                   ((NRF_SPU_Type*)           NRF_SPU_S_BASE)
#define NRF_OSCILLATORS_NS          ((NRF_OSCILLATORS_Type*)   NRF_OSCILLATORS_NS_BASE)
#define NRF_REGULATORS_NS           ((NRF_REGULATORS_Type*)    NRF_REGULATORS_NS_BASE)
#define NRF_OSCILLATORS_S           ((NRF_OSCILLATORS_Type*)   NRF_OSCILLATORS_S_BASE)
#define NRF_REGULATORS_S            ((NRF_REGULATORS_Type*)    NRF_REGULATORS_S_BASE)
#define NRF_CLOCK_NS                ((NRF_CLOCK_Type*)         NRF_CLOCK_NS_BASE)
#define NRF_POWER_NS                ((NRF_POWER_Type*)         NRF_POWER_NS_BASE)
#define NRF_RESET_NS                ((NRF_RESET_Type*)         NRF_RESET_NS_BASE)
#define NRF_CLOCK_S                 ((NRF_CLOCK_Type*)         NRF_CLOCK_S_BASE)
#define NRF_POWER_S                 ((NRF_POWER_Type*)         NRF_POWER_S_BASE)
#define NRF_RESET_S                 ((NRF_RESET_Type*)         NRF_RESET_S_BASE)
#define NRF_CTRLAP_NS               ((NRF_CTRLAPPERI_Type*)    NRF_CTRLAP_NS_BASE)
#define NRF_CTRLAP_S                ((NRF_CTRLAPPERI_Type*)    NRF_CTRLAP_S_BASE)
#define NRF_PAMLI_NS                ((NRF_PAMLI_Type*)         NRF_PAMLI_NS_BASE)
#define NRF_PAMLI_S                 ((NRF_PAMLI_Type*)         NRF_PAMLI_S_BASE)
#define NRF_SPI0_NS                 ((NRF_SPI_Type*)           NRF_SPI0_NS_BASE)
#define NRF_SPIM0_NS                ((NRF_SPIM_Type*)          NRF_SPIM0_NS_BASE)
#define NRF_SPIS0_NS                ((NRF_SPIS_Type*)          NRF_SPIS0_NS_BASE)
#define NRF_TWI0_NS                 ((NRF_TWI_Type*)           NRF_TWI0_NS_BASE)
#define NRF_TWIM0_NS                ((NRF_TWIM_Type*)          NRF_TWIM0_NS_BASE)
#define NRF_TWIS0_NS                ((NRF_TWIS_Type*)          NRF_TWIS0_NS_BASE)
#define NRF_UART0_NS                ((NRF_UART_Type*)          NRF_UART0_NS_BASE)
#define NRF_UARTE0_NS               ((NRF_UARTE_Type*)         NRF_UARTE0_NS_BASE)
#define NRF_SPI0_S                  ((NRF_SPI_Type*)           NRF_SPI0_S_BASE)
#define NRF_SPIM0_S                 ((NRF_SPIM_Type*)          NRF_SPIM0_S_BASE)
#define NRF_SPIS0_S                 ((NRF_SPIS_Type*)          NRF_SPIS0_S_BASE)
#define NRF_TWI0_S                  ((NRF_TWI_Type*)           NRF_TWI0_S_BASE)
#define NRF_TWIM0_S                 ((NRF_TWIM_Type*)          NRF_TWIM0_S_BASE)
#define NRF_TWIS0_S                 ((NRF_TWIS_Type*)          NRF_TWIS0_S_BASE)
#define NRF_UART0_S                 ((NRF_UART_Type*)          NRF_UART0_S_BASE)
#define NRF_UARTE0_S                ((NRF_UARTE_Type*)         NRF_UARTE0_S_BASE)
#define NRF_SPI1_NS                 ((NRF_SPI_Type*)           NRF_SPI1_NS_BASE)
#define NRF_SPIM1_NS                ((NRF_SPIM_Type*)          NRF_SPIM1_NS_BASE)
#define NRF_SPIS1_NS                ((NRF_SPIS_Type*)          NRF_SPIS1_NS_BASE)
#define NRF_TWI1_NS                 ((NRF_TWI_Type*)           NRF_TWI1_NS_BASE)
#define NRF_TWIM1_NS                ((NRF_TWIM_Type*)          NRF_TWIM1_NS_BASE)
#define NRF_TWIS1_NS                ((NRF_TWIS_Type*)          NRF_TWIS1_NS_BASE)
#define NRF_UART1_NS                ((NRF_UART_Type*)          NRF_UART1_NS_BASE)
#define NRF_UARTE1_NS               ((NRF_UARTE_Type*)         NRF_UARTE1_NS_BASE)
#define NRF_SPI1_S                  ((NRF_SPI_Type*)           NRF_SPI1_S_BASE)
#define NRF_SPIM1_S                 ((NRF_SPIM_Type*)          NRF_SPIM1_S_BASE)
#define NRF_SPIS1_S                 ((NRF_SPIS_Type*)          NRF_SPIS1_S_BASE)
#define NRF_TWI1_S                  ((NRF_TWI_Type*)           NRF_TWI1_S_BASE)
#define NRF_TWIM1_S                 ((NRF_TWIM_Type*)          NRF_TWIM1_S_BASE)
#define NRF_TWIS1_S                 ((NRF_TWIS_Type*)          NRF_TWIS1_S_BASE)
#define NRF_UART1_S                 ((NRF_UART_Type*)          NRF_UART1_S_BASE)
#define NRF_UARTE1_S                ((NRF_UARTE_Type*)         NRF_UARTE1_S_BASE)
#define NRF_SPIM4_NS                ((NRF_SPIM_Type*)          NRF_SPIM4_NS_BASE)
#define NRF_SPIM4_S                 ((NRF_SPIM_Type*)          NRF_SPIM4_S_BASE)
#define NRF_SPI2_NS                 ((NRF_SPI_Type*)           NRF_SPI2_NS_BASE)
#define NRF_SPIM2_NS                ((NRF_SPIM_Type*)          NRF_SPIM2_NS_BASE)
#define NRF_SPIS2_NS                ((NRF_SPIS_Type*)          NRF_SPIS2_NS_BASE)
#define NRF_TWI2_NS                 ((NRF_TWI_Type*)           NRF_TWI2_NS_BASE)
#define NRF_TWIM2_NS                ((NRF_TWIM_Type*)          NRF_TWIM2_NS_BASE)
#define NRF_TWIS2_NS                ((NRF_TWIS_Type*)          NRF_TWIS2_NS_BASE)
#define NRF_UART2_NS                ((NRF_UART_Type*)          NRF_UART2_NS_BASE)
#define NRF_UARTE2_NS               ((NRF_UARTE_Type*)         NRF_UARTE2_NS_BASE)
#define NRF_SPI2_S                  ((NRF_SPI_Type*)           NRF_SPI2_S_BASE)
#define NRF_SPIM2_S                 ((NRF_SPIM_Type*)          NRF_SPIM2_S_BASE)
#define NRF_SPIS2_S                 ((NRF_SPIS_Type*)          NRF_SPIS2_S_BASE)
#define NRF_TWI2_S                  ((NRF_TWI_Type*)           NRF_TWI2_S_BASE)
#define NRF_TWIM2_S                 ((NRF_TWIM_Type*)          NRF_TWIM2_S_BASE)
#define NRF_TWIS2_S                 ((NRF_TWIS_Type*)          NRF_TWIS2_S_BASE)
#define NRF_UART2_S                 ((NRF_UART_Type*)          NRF_UART2_S_BASE)
#define NRF_UARTE2_S                ((NRF_UARTE_Type*)         NRF_UARTE2_S_BASE)
#define NRF_SPI3_NS                 ((NRF_SPI_Type*)           NRF_SPI3_NS_BASE)
#define NRF_SPIM3_NS                ((NRF_SPIM_Type*)          NRF_SPIM3_NS_BASE)
#define NRF_SPIS3_NS                ((NRF_SPIS_Type*)          NRF_SPIS3_NS_BASE)
#define NRF_TWI3_NS                 ((NRF_TWI_Type*)           NRF_TWI3_NS_BASE)
#define NRF_TWIM3_NS                ((NRF_TWIM_Type*)          NRF_TWIM3_NS_BASE)
#define NRF_TWIS3_NS                ((NRF_TWIS_Type*)          NRF_TWIS3_NS_BASE)
#define NRF_UART3_NS                ((NRF_UART_Type*)          NRF_UART3_NS_BASE)
#define NRF_UARTE3_NS               ((NRF_UARTE_Type*)         NRF_UARTE3_NS_BASE)
#define NRF_SPI3_S                  ((NRF_SPI_Type*)           NRF_SPI3_S_BASE)
#define NRF_SPIM3_S                 ((NRF_SPIM_Type*)          NRF_SPIM3_S_BASE)
#define NRF_SPIS3_S                 ((NRF_SPIS_Type*)          NRF_SPIS3_S_BASE)
#define NRF_TWI3_S                  ((NRF_TWI_Type*)           NRF_TWI3_S_BASE)
#define NRF_TWIM3_S                 ((NRF_TWIM_Type*)          NRF_TWIM3_S_BASE)
#define NRF_TWIS3_S                 ((NRF_TWIS_Type*)          NRF_TWIS3_S_BASE)
#define NRF_UART3_S                 ((NRF_UART_Type*)          NRF_UART3_S_BASE)
#define NRF_UARTE3_S                ((NRF_UARTE_Type*)         NRF_UARTE3_S_BASE)
#define NRF_GPIOTE0_S               ((NRF_GPIOTE_Type*)        NRF_GPIOTE0_S_BASE)
#define NRF_SAADC_NS                ((NRF_SAADC_Type*)         NRF_SAADC_NS_BASE)
#define NRF_SAADC_S                 ((NRF_SAADC_Type*)         NRF_SAADC_S_BASE)
#define NRF_TIMER0_NS               ((NRF_TIMER_Type*)         NRF_TIMER0_NS_BASE)
#define NRF_TIMER0_S                ((NRF_TIMER_Type*)         NRF_TIMER0_S_BASE)
#define NRF_TIMER1_NS               ((NRF_TIMER_Type*)         NRF_TIMER1_NS_BASE)
#define NRF_TIMER1_S                ((NRF_TIMER_Type*)         NRF_TIMER1_S_BASE)
#define NRF_TIMER2_NS               ((NRF_TIMER_Type*)         NRF_TIMER2_NS_BASE)
#define NRF_TIMER2_S                ((NRF_TIMER_Type*)         NRF_TIMER2_S_BASE)
#define NRF_RTC0_NS                 ((NRF_RTC_Type*)           NRF_RTC0_NS_BASE)
#define NRF_RTC0_S                  ((NRF_RTC_Type*)           NRF_RTC0_S_BASE)
#define NRF_RTC1_NS                 ((NRF_RTC_Type*)           NRF_RTC1_NS_BASE)
#define NRF_RTC1_S                  ((NRF_RTC_Type*)           NRF_RTC1_S_BASE)
#define NRF_DPPIC_NS                ((NRF_DPPIC_Type*)         NRF_DPPIC_NS_BASE)
#define NRF_DPPIC_S                 ((NRF_DPPIC_Type*)         NRF_DPPIC_S_BASE)
#define NRF_WDT0_NS                 ((NRF_WDT_Type*)           NRF_WDT0_NS_BASE)
#define NRF_WDT0_S                  ((NRF_WDT_Type*)           NRF_WDT0_S_BASE)
#define NRF_WDT1_NS                 ((NRF_WDT_Type*)           NRF_WDT1_NS_BASE)
#define NRF_WDT1_S                  ((NRF_WDT_Type*)           NRF_WDT1_S_BASE)
#define NRF_COMP_NS                 ((NRF_COMP_Type*)          NRF_COMP_NS_BASE)
#define NRF_LPCOMP_NS               ((NRF_LPCOMP_Type*)        NRF_LPCOMP_NS_BASE)
#define NRF_COMP_S                  ((NRF_COMP_Type*)          NRF_COMP_S_BASE)
#define NRF_LPCOMP_S                ((NRF_LPCOMP_Type*)        NRF_LPCOMP_S_BASE)
#define NRF_EGU0_NS                 ((NRF_EGU_Type*)           NRF_EGU0_NS_BASE)
#define NRF_EGU0_S                  ((NRF_EGU_Type*)           NRF_EGU0_S_BASE)
#define NRF_EGU1_NS                 ((NRF_EGU_Type*)           NRF_EGU1_NS_BASE)
#define NRF_EGU1_S                  ((NRF_EGU_Type*)           NRF_EGU1_S_BASE)
#define NRF_EGU2_NS                 ((NRF_EGU_Type*)           NRF_EGU2_NS_BASE)
#define NRF_EGU2_S                  ((NRF_EGU_Type*)           NRF_EGU2_S_BASE)
#define NRF_EGU3_NS                 ((NRF_EGU_Type*)           NRF_EGU3_NS_BASE)
#define NRF_EGU3_S                  ((NRF_EGU_Type*)           NRF_EGU3_S_BASE)
#define NRF_EGU4_NS                 ((NRF_EGU_Type*)           NRF_EGU4_NS_BASE)
#define NRF_EGU4_S                  ((NRF_EGU_Type*)           NRF_EGU4_S_BASE)
#define NRF_EGU5_NS                 ((NRF_EGU_Type*)           NRF_EGU5_NS_BASE)
#define NRF_EGU5_S                  ((NRF_EGU_Type*)           NRF_EGU5_S_BASE)
#define NRF_PWM0_NS                 ((NRF_PWM_Type*)           NRF_PWM0_NS_BASE)
#define NRF_PWM0_S                  ((NRF_PWM_Type*)           NRF_PWM0_S_BASE)
#define NRF_PWM1_NS                 ((NRF_PWM_Type*)           NRF_PWM1_NS_BASE)
#define NRF_PWM1_S                  ((NRF_PWM_Type*)           NRF_PWM1_S_BASE)
#define NRF_PWM2_NS                 ((NRF_PWM_Type*)           NRF_PWM2_NS_BASE)
#define NRF_PWM2_S                  ((NRF_PWM_Type*)           NRF_PWM2_S_BASE)
#define NRF_PWM3_NS                 ((NRF_PWM_Type*)           NRF_PWM3_NS_BASE)
#define NRF_PWM3_S                  ((NRF_PWM_Type*)           NRF_PWM3_S_BASE)
#define NRF_PDM0_NS                 ((NRF_PDM_Type*)           NRF_PDM0_NS_BASE)
#define NRF_PDM0_S                  ((NRF_PDM_Type*)           NRF_PDM0_S_BASE)
#define NRF_I2S0_NS                 ((NRF_I2S_Type*)           NRF_I2S0_NS_BASE)
#define NRF_I2S0_S                  ((NRF_I2S_Type*)           NRF_I2S0_S_BASE)
#define NRF_IPC_NS                  ((NRF_IPC_Type*)           NRF_IPC_NS_BASE)
#define NRF_IPC_S                   ((NRF_IPC_Type*)           NRF_IPC_S_BASE)
#define NRF_QSPI_NS                 ((NRF_QSPI_Type*)          NRF_QSPI_NS_BASE)
#define NRF_QSPI_S                  ((NRF_QSPI_Type*)          NRF_QSPI_S_BASE)
#define NRF_NFCT_NS                 ((NRF_NFCT_Type*)          NRF_NFCT_NS_BASE)
#define NRF_NFCT_S                  ((NRF_NFCT_Type*)          NRF_NFCT_S_BASE)
#define NRF_GPIOTE1_NS              ((NRF_GPIOTE_Type*)        NRF_GPIOTE1_NS_BASE)
#define NRF_MUTEX_NS                ((NRF_MUTEX_Type*)         NRF_MUTEX_NS_BASE)
#define NRF_MUTEX_S                 ((NRF_MUTEX_Type*)         NRF_MUTEX_S_BASE)
#define NRF_RAMTRIM0_NS             ((NRF_RAMTRIM_Type*)       NRF_RAMTRIM0_NS_BASE)
#define NRF_RAMTRIM0_S              ((NRF_RAMTRIM_Type*)       NRF_RAMTRIM0_S_BASE)
#define NRF_RCOSC32K_NS             ((NRF_RCOSC32K_Type*)      NRF_RCOSC32K_NS_BASE)
#define NRF_RCOSC32K_S              ((NRF_RCOSC32K_Type*)      NRF_RCOSC32K_S_BASE)
#define NRF_QDEC0_NS                ((NRF_QDEC_Type*)          NRF_QDEC0_NS_BASE)
#define NRF_QDEC0_S                 ((NRF_QDEC_Type*)          NRF_QDEC0_S_BASE)
#define NRF_QDEC1_NS                ((NRF_QDEC_Type*)          NRF_QDEC1_NS_BASE)
#define NRF_QDEC1_S                 ((NRF_QDEC_Type*)          NRF_QDEC1_S_BASE)
#define NRF_USBD_NS                 ((NRF_USBD_Type*)          NRF_USBD_NS_BASE)
#define NRF_USBD_S                  ((NRF_USBD_Type*)          NRF_USBD_S_BASE)
#define NRF_USBREGULATOR_NS         ((NRF_USBREG_Type*)        NRF_USBREGULATOR_NS_BASE)
#define NRF_USBREGULATOR_S          ((NRF_USBREG_Type*)        NRF_USBREGULATOR_S_BASE)
#define NRF_VFSCTRL_S               ((NRF_VFSCTRL_Type*)       NRF_VFSCTRL_S_BASE)
#define NRF_KMU_NS                  ((NRF_KMU_Type*)           NRF_KMU_NS_BASE)
#define NRF_NVMC_NS                 ((NRF_NVMC_Type*)          NRF_NVMC_NS_BASE)
#define NRF_KMU_S                   ((NRF_KMU_Type*)           NRF_KMU_S_BASE)
#define NRF_NVMC_S                  ((NRF_NVMC_Type*)          NRF_NVMC_S_BASE)
#define NRF_P0_NS                   ((NRF_GPIO_Type*)          NRF_P0_NS_BASE)
#define NRF_P1_NS                   ((NRF_GPIO_Type*)          NRF_P1_NS_BASE)
#define NRF_P0_S                    ((NRF_GPIO_Type*)          NRF_P0_S_BASE)
#define NRF_GPIOINTERNAL_NS         ((NRF_GPIOSTATIC_Type*)    NRF_GPIOINTERNAL_NS_BASE)
#define NRF_GPIOINTERNAL_S          ((NRF_GPIOSTATIC_Type*)    NRF_GPIOINTERNAL_S_BASE)
#define NRF_P1_S                    ((NRF_GPIO_Type*)          NRF_P1_S_BASE)
#define NRF_CRYPTOCELL_S            ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_S_BASE)
#define NRF_CC_AES_S                ((NRF_CC_AES_Type*)        NRF_CC_AES_S_BASE)
#define NRF_CC_AHB_S                ((NRF_CC_AHB_Type*)        NRF_CC_AHB_S_BASE)
#define NRF_CC_AO_S                 ((NRF_CC_AO_Type*)         NRF_CC_AO_S_BASE)
#define NRF_CC_CHACHA_S             ((NRF_CC_CHACHA_Type*)     NRF_CC_CHACHA_S_BASE)
#define NRF_CC_CTL_S                ((NRF_CC_CTL_Type*)        NRF_CC_CTL_S_BASE)
#define NRF_CC_DIN_S                ((NRF_CC_DIN_Type*)        NRF_CC_DIN_S_BASE)
#define NRF_CC_DOUT_S               ((NRF_CC_DOUT_Type*)       NRF_CC_DOUT_S_BASE)
#define NRF_CC_GHASH_S              ((NRF_CC_GHASH_Type*)      NRF_CC_GHASH_S_BASE)
#define NRF_CC_HASH_S               ((NRF_CC_HASH_Type*)       NRF_CC_HASH_S_BASE)
#define NRF_CC_HOST_RGF_S           ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_S_BASE)
#define NRF_CC_HOST_SRAM_S          ((NRF_CC_HOST_SRAM_Type*)  NRF_CC_HOST_SRAM_S_BASE)
#define NRF_CC_ID_REGISTERS_S       ((NRF_CC_ID_REGISTERS_Type*)  NRF_CC_ID_REGISTERS_S_BASE)
#define NRF_CC_MISC_S               ((NRF_CC_MISC_Type*)       NRF_CC_MISC_S_BASE)
#define NRF_CC_NVM_S                ((NRF_CC_NVM_Type*)        NRF_CC_NVM_S_BASE)
#define NRF_CC_PKA_S                ((NRF_CC_PKA_Type*)        NRF_CC_PKA_S_BASE)
#define NRF_CC_RNG_S                ((NRF_CC_RNG_Type*)        NRF_CC_RNG_S_BASE)
#define NRF_VMC_NS                  ((NRF_VMC_Type*)           NRF_VMC_NS_BASE)
#define NRF_VMC_S                   ((NRF_VMC_Type*)           NRF_VMC_S_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


#ifdef __cplusplus
}
#endif

#endif /* NRF5340_APPLICATION_H */


/** @} */ /* End of group nrf5340_application */

/** @} */ /* End of group Nordic Semiconductor */
